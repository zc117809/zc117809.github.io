[{"title":"csrf 跨站请求伪造","date":"2020-07-09T14:00:21.116Z","path":"2020/07/09/csrf 跨站请求伪造/","text":"csrf 跨站请求伪造简介CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性 可以这样来理解： 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户 csrf 攻击原理crsf应用form表单里应用 1234567&lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;p&gt;username:&lt;input type=\"text\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;target_user:&lt;input type=\"text\" name=\"target_user\"&gt;&lt;/p&gt; &lt;p&gt;money:&lt;input type=\"text\" name=\"money\"&gt;&lt;/p&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 在ajax应用 1234567# ajax如何符合校验// 第一种 利用标签查找获取页面上的随机字符串&#123;#data:&#123;\"username\":'jason','csrfmiddlewaretoken':$('[name=csrfmiddlewaretoken]').val()&#125;,#&#125;// 第二种 利用模版语法提供的快捷书写&#123;#data:&#123;\"username\":'jason','csrfmiddlewaretoken':'&#123;&#123; csrf_token &#125;&#125;'&#125;,#&#125;// 第三种 通用方式直接拷贝js代码并应用到自己的html页面上即可data:&#123;\"username\":'jason'&#125; 第三种方式的js代码 123456789101112131415161718192021222324252627282930function getCookie(name) &#123; var cookieValue = null; if (document.cookie &amp;&amp; document.cookie !== '') &#123; var cookies = document.cookie.split(';'); for (var i = 0; i &lt; cookies.length; i++) &#123; var cookie = jQuery.trim(cookies[i]); // Does this cookie string begin with the name we want? if (cookie.substring(0, name.length + 1) === (name + '=')) &#123; cookieValue = decodeURIComponent(cookie.substring(name.length + 1)); break; &#125; &#125; &#125; return cookieValue;&#125;var csrftoken = getCookie('csrftoken');function csrfSafeMethod(method) &#123; // these HTTP methods do not require CSRF protection return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));&#125;$.ajaxSetup(&#123; beforeSend: function (xhr, settings) &#123; if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) &#123; xhr.setRequestHeader(\"X-CSRFToken\", csrftoken); &#125; &#125;&#125;); csrf 相关装饰器全站禁用：注释掉中间件 ‘django.middleware.csrf.CsrfViewMiddleware’, FBV使用 123456789101112from django.views.decorators.csrf import csrf_exempt,csrf_protect# 不注释csrf，让整体通过csrf，（忽视校验）# @csrf_exempt# 注释掉csrf，整体不校验，这个函数需要校验（需要校验）# @csrf_protectdef index(request): if request.method == 'POST': username = request.POST.get('username') target_user = request.POST.get('target_user') money = request.POST.get('money') print(f'&#123;username&#125; 向&#123;target_user&#125; 转了&#123;money&#125;元') return render(request,'index.html') CBV使用 12345678910111213from django.views.decorators.csrf import csrf_protect,csrf_exemptfrom django.utils.decorators import method_decorator# 注释掉csrf# @method_decorator(csrf_protect,name='post') # 针对csrf_protect第二种 可以需要校验class MyCsrf(View): @method_decorator(csrf_protect)# 针对csrf_protect第三种 可以需要校验 def dispatch(self, request, *args, **kwargs): return super(MyCsrf,self).dispatch(request,*args,**kwargs) def get(self,request): return HttpResponse('get') # @method_decorator(csrf_protect) # 针对csrf_protect第一种 可以需要校验 def post(self,request): return HttpResponse('post') 1234567891011121314# 不注释csrf#@method_decorator(csrf_exempt,name='post')# 第二种针对csrf_exempt,想忽略全局校验 还是需要校验class MyCsrf(View): # @method_decorator(csrf_exempt) # 第三种针对csrf_exempt,想忽略全局校验 可以不需要 def dispatch(self, request, *args, **kwargs): return super(MyCsrf,self).dispatch(request,*args,**kwargs) def get(self,request): return HttpResponse('get') # @method_decorator(csrf_exempt) # 第一种针对csrf_exempt,想忽略全局校验 还是需要校验 def post(self,request): return HttpResponse('post') 针对不注释掉csrf的，第三种可以忽略校验，但是一和二不行，还是需要校验","tags":[]},{"title":"前端之CSS","date":"2020-07-09T14:00:04.208Z","path":"2020/07/09/前端之CSS/","text":"前端之CSSCSS是层叠样式表，就是给html标签添加样式，让其更美观 CSS的注释 123456789/*单行注释*//*多行注释1多行注释2多行注释3*/# 通常我们在写css样式的时候也会用注释来划定样式区域(因为HTML代码多所以对呀的css代码也会很多) CSS语法结构 123456选择器 &#123; 属性1:值1; 属性2:值2; 属性3:值3; 属性4:值4;&#125; CSS的三种引入方式 style标签直接书写css代码 12345&lt;style&gt; h1&#123; color: burlywood; &#125;&lt;/style&gt; link标签引入外部css文件，正规 1&lt;link rel=\"stylesheet\" href=\"mycss.css\"&gt; 行内式，直接html标签内书写样式，一般不推荐 1&lt;h1 style=\"color: green\"&gt;老板好 要上课吗?&lt;/h1&gt; CSS选择器所谓选择器，就是确定标签位置的方法 基本选择器123456789&lt;body&gt; &lt;div id=\"d1\" class=\"c1 c2\"&gt;div &lt;p&gt;div里面的p&lt;/p&gt; &lt;span&gt;div里面的span&lt;/span&gt; &lt;/div&gt; &lt;p id=\"d2\" class=\"c1 c2\"&gt;ppp&lt;/p&gt; &lt;span id=\"d3\" class=\"c2\"&gt;span111&lt;/span&gt; &lt;span id=\"d4\" class=\"c3\"&gt;span222&lt;/span&gt;&lt;/body&gt; id选择器，根据id值确定一个标签 123#id_name&#123; /*找到id是d1的标签 将文本颜色变成红色*/ color:red;&#125; class选择器，根据class值确定一类标签 123.class_name&#123; /* 找到class值里面包含c1的标签*/ color:red;&#125; 元素/标签选择器，根据标签名确定一堆span标签 123span&#123;/*找到所有的span标签*/ color:red;&#125; 通用选择器，选择所有标签 123*&#123;/*将html页面上所有的标签全部找到*/ color:red;&#125; 组合选择器12345678910111213141516&lt;body&gt; &lt;span&gt;span1&lt;/span&gt; &lt;span&gt;span2&lt;/span&gt; &lt;div&gt;div &lt;p&gt;div p&lt;/p&gt; &lt;p&gt;div p &lt;span&gt;div p span&lt;/span&gt; &lt;/p&gt; &lt;span&gt;span&lt;/span&gt; &lt;span&gt;span&lt;/span&gt; &lt;/div&gt; &lt;span&gt;span&lt;/span&gt; &lt;span&gt;span&lt;/span&gt; &lt;p&gt;ppp&lt;/p&gt; &lt;span&gt;span&lt;/span&gt;&lt;/body&gt; 12345678910111213141516\"\"\"在前端 我们将标签的嵌套用亲戚关系来表述层级 &lt;div&gt;div &lt;p&gt;div p&lt;/p&gt; &lt;p&gt;div p &lt;span&gt;div p span&lt;/span&gt; &lt;/p&gt; &lt;span&gt;span&lt;/span&gt; &lt;span&gt;span&lt;/span&gt; &lt;/div&gt; div里面的p span都是div的后代 p是div的儿子 p里面的span是p的儿子 是div的孙子 div是p的父亲 ...\"\"\" 后代选择器，空格隔开，选择div 里面的所有span 123div span&#123; color:red;&#125; 儿子选择器，&gt;连接，选择内部第一层的所有span 123div&gt;span&#123; color:red;&#125; 毗邻选择器，+连接，选择div同级别的紧挨着的下面一个span，隔着一个都不行 123div+span&#123; /*同级别紧挨着的下面的第一个*/ color:red;&#125; 弟弟选择器，~连接，选择同级别下面所有的span 123div~span&#123;/*同级别下面所有的span*/ color:red;&#125; 属性选择器属性选择器，以[]作为标志。 12345678&lt;body&gt; &lt;input type=\"text\" username&gt; &lt;input type=\"text\" username=\"jason\"&gt; &lt;input type=\"text\" username=\"kevin\"&gt; &lt;p username=\"tank\"&gt;水箱老师&lt;/p&gt; &lt;div username=\"egon\"&gt;矮子老师&lt;/div&gt; &lt;span username=\"jason\"&gt;jason老师 &lt;/span&gt;&lt;/body&gt; 含有某个属性的标签 123[username]&#123; /*将所有含有属性名是username的标签背景色改为红色*/ color:red;&#125; 含有某个属性且有某个值的标签，选择属性名为 123[username='jason']&#123; /*找到所有属性名是username并且属性值是jason的标签*/ color:red;&#125; 含有某个属性且有某个值的某个标签 123input[username='jason']&#123;/*找到所有属性名是username并且属性值是jason的input标签*/ color:red;&#125;","tags":[]},{"title":"路由和认证","date":"2020-07-09T13:59:47.370Z","path":"2020/07/09/路由和认证/","text":"路由1 三种路由的配置 在urls.py里面的配置的常规配置 12path('books4/', views.Book4View.as_view()),re_path('books4/(?P&lt;pk&gt;\\d+)', views.Book4DetailView.as_view()) 视图类中继承了ViewSetMixin 12path('books5/', views.Book5View.as_view(actions=&#123;'get':'list','post':'create'&#125;)), #当路径匹配，又是get请求，会执行Book5View的list方法re_path('books5/(?P&lt;pk&gt;\\d+)', views.Book5View.as_view(actions=&#123;'get':'retrieve','put':'update','delete':'destroy'&#125;)), 继承视图类ModelViewSet路由的写法 配置路由导入模块 1from rest_framework import routers 两个类,实例化得到对象 1234567891011121314151617routers.DefaultRouter····^books/$ [name='book-list'] # 根^books\\.(?P&lt;format&gt;[a-z0-9]+)/?$ [name='book-list']# simple的差不多^books/(?P&lt;pk&gt;[^/.]+)/$ [name='book-detail']^books/(?P&lt;pk&gt;[^/.]+)\\.(?P&lt;format&gt;[a-z0-9]+)/?$ [name='book-detail']# 和simple的差不多^$ [name='api-root']# 根路径会显示出所有可以访问的地址^\\.(?P&lt;format&gt;[a-z0-9]+)/?$ [name='api-root']····自动生成的6个路由routers.SimpleRouter\"\"\"[&lt;RegexURLPattern book-list ^books/$&gt;,&lt;RegexURLPattern book-detail ^books/(?P&lt;pk&gt;[^/.]+)/$&gt;]\"\"\"\"自动生成的2个路由 注册 1router.register('books',views.BookViewSet)# 后面可以加别名 自动生成路由，加入到原来的路由中去 1urlpatterns+=router.urls action的使用是为了给继承ModelViewSet视图类定义的函数也添加路由 123456789class BookViewSet(ModelViewSet): queryset = models.Book.objects.all() serializer_class = BookModelSerializer @action(methods=['GET','post'], detail=True) def get_5(self, request,pk): book = self.get_queryset()[:5] # 从0开始截取 ser = self.get_serializer(book, many=True) return Response(ser.data) methods:第一个参数，传一个列表，列表中放请求方式，如get，post等 detail: 1234^books/get_1/$ [name='book-get-1'] 当向这个地址发送get请求，会执行下面的函数detail：布尔类型 如果是True^books/(?P&lt;pk&gt;[^/.]+)/get_1/$ [name='book-get-1']http://127.0.0.1:8000/books/1/get_5/ 认证1 认证的实现1 写一个类，继承BaseAuthentication，重写authenticate，认证的逻辑写在里面，认证通过，返回两个值，一个值最终给了Requet对象的user，认证失败，抛异常：APIException或者AuthenticationFailed 2 全局使用，局部使用2 drf认证的源码分析入口点 12在APIView--&gt; as_view--&gt; dispatch方法--&gt; self.initial(request, *args, **kwargs)这个方法中有认证，权限，频率 dispatch方法源码 12345678910111213141516171819202122232425def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 在try里面 self.initial这个方法点进去，在APIView里面 initital方法 1234567891011121314def initial(self, request, *args, **kwargs): \"\"\" Runs anything that needs to occur prior to calling the method handler. \"\"\" self.format_kwarg = self.get_format_suffix(**kwargs) neg = self.perform_content_negotiation(request) request.accepted_renderer, request.accepted_media_type = neg version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme self.perform_authentication(request) self.check_permissions(request) self.check_throttles(request) self.perform_authentication(request)只读这个认证的功能 ，传个request过来，这个request是包装后的， perform_authentication方法的源码 12def perform_authentication(self, request): request.user 因为这个是包装过后的Request，所以我们要到包装过后的request对象里面的user属性 user属性源码 123456@property def user(self): if not hasattr(self, '_user'): with wrap_attributeerrors(): self._authenticate() return self._user 判断self里面有没有_user这个属性，一开始是没有的，它就会走下面的上下文管理器， self._authenticate() 点_authenticate这个方法，这个方法还在Request对象里面， _authenticate源码 1234567891011121314def _authenticate(self): for authenticator in self.authenticators: try: user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise if user_auth_tuple is not None: self._authenticator = authenticator self.user, self.auth = user_auth_tuple return self._not_authenticated() 这里的for循环的authenticators一定是一个可迭代对象，我们要到Request对象里面去找， 123456789101112class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( 'The `request` argument must be an instance of ' '`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.' .format(request.__class__.__module__, request.__class__.__name__) ) self._request = request self.authenticators = authenticators or () 我们发现是在这个类里面初始化得到的，这个类是dispatch包装request得到的，request = self.initialize_request(request, *args, **kwargs)点击initialize_request这个方法 我们发现了authenticators 12345678return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context) 123def get_authenticators(self): return [auth() for auth in self.authentication_classes] 这个是列表生成式，从自己`authentication_classes去取，取出一个加括号执行，这个self是APIView里面的对象的属性，因为自己视图类里面没有 1authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 列表中是一对对象，是视图类中配置的authentication_classes=[类名]对象， 所以Request对象中的authenticators=self.get_authenticators()是列表[类的对象]，被传到了Request对象定义的这个 self.authenticators = authenticators or ()传给了authenticators里面， _authenticate源码里面的for循环，就是self.authenticators 配置的一堆认证产生类对象组成的list，每次循环拿到一个对象 1234567891011121314def _authenticate(self): for authenticator in self.authenticators: try: user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise if user_auth_tuple is not None: self._authenticator = authenticator self.user, self.auth = user_auth_tuple return self._not_authenticated() authenticator.authenticate这个就是为什么要重写这个方法，执行这个方法，返回的时候是两个值，解压赋值，认证逻辑通过，返回两个值，一个值给了Request对象的user，认证失败，抛出异常APIException，也可以抛出AuthenticationFailed它里面也是继承了APIException 3 认证组件的使用12345678910111213141516from rest_framework.authentication import BaseAuthenticationfrom rest_framework.exceptions import AuthenticationFailedclass MyAuthentication(BaseAuthentication): def authenticate(self, request): # 认证逻辑，通过返回两个值 token = request.GET.get('token') #token = request.META.get('HTTP_TOKEN')这个是放在请求头里面 if token: from app01 import models user_token = models.UserToken.objects.filter(token=token).first() if user_token: return user_token.user,token else: raise AuthenticationFailed('认证失败') else: raise AuthenticationFailed('请求地址中需要携带token') 4 全局使用和局部禁用'12345678全局使用在settings里面配置REST_FRAMEWORK=&#123; \"DEFAULT_AUTHENTICATION_CLASSES\":[\"app01.app_auth.MyAuthentication\",]&#125;局部使用：authentication_classes=[MyAuthentication]局部禁用：在登陆的时候就不需要，因为你还没登录呢，如何做认证authentication_classes=[] 里面什么都不加就可以了","tags":[]},{"title":"序列化组件","date":"2020-07-09T13:59:31.688Z","path":"2020/07/09/序列化组件/","text":"序列化组件1.简单介绍 序列化：序列器会把模型转成字典，经过response以后变成json字符串 反序列化：把客户端传过来的数据，经过request以后变成字典，序列化器可以把字典转成模型 2.使用 建立orm，创建一个py文件，写一个序列化器，继承Serializer 在类中书写序列化的字段 在视图中导入实例化得到的序列化类的对象，把要序列化的对象传入进去 序列化类的对象.data 这里是一个字典 把字典返回，如果不适应rest_framework提供的Response,l可以使用JsonResponse 123456789101112131415# ser.pyfrom rest_framework import serializersclass BookSerializer(serializers.Serializer): price = serializers.CharField() #创建你要序列化的字段# views.pyclass BookAPIView(APIView): def get(self, request, pk): book = models.Book.objects.filter(id=pk).first() book_ser = BookSerializer(book) # 要序列化谁就把谁传过来， # 调用类的__init__ return Response(book_ser.data) # 序列化对象.data就是序列化后的字典#urlre_path('books/(?P&lt;pk&gt;\\d+)', views.BookAPIView.as_view()), 补充：还有很多的字段类型 1CharField,IntegerField,DateField 3. 单个数据的修改和展示上面是简单的使用，这个是对某一个数据的更新。 在类中写要序列化的字段，像序列化哪个就写哪个，里面还可以添加一些参数 123456max_length 最大长度 min_lenght 最小长度 allow_blank 是否允许为空 trim_whitespace 是否截断空白字符 max_value 最小值 min_value 最大值 在视图中使用，实例化得到序列化的对象，把要修改的对象传入，修改的数据传入 校验数据，通过保存 如果字段的校验规则不够我们可以自己写钩子 12345678910111213141516171819202122232425# ser.pyclass BookSerializer(serializers.Serializer): title = serializers.CharField(max_length=6,min_length=2) price = serializers.CharField() author = serializers.CharField(max_length=6,min_length=2) publish = serializers.CharField(max_length=6,min_length=2) # view.pyclass BookAPIView(APIView): def put(self,request,pk): response_msg = &#123;'state':100,'msg':'成功'&#125; book = models.Book.objects.filter(id=pk).first() # 更新或修改某个字段要传两个参数 book_obj = BookSerializer(instance=book,data=request.data) # 传两个参数对象和数据 # 验证数据 if book_obj.is_valid(): # 这里不能直接用save要重写 book_obj.save() response_msg['data']=book_obj.data else: response_msg['state']=101 response_msg['msg'] = '数据校验失败' response_msg['data']=book_obj.errors return Response(response_msg) 3.1 ser.py中的局部钩子和全局钩子123456789101112131415from rest_framework.exceptions import ValidationError # 局部钩子 def validate_author(self, data): if '啊' in data: raise ValidationError('作者名不能有啊') else: return data def validate(self, validate_data): author = validate_data.get('author') publish = validate_data.get('publish') if author==publish: raise ValidationError('作者名字不能和出版社一样哦') else: return validate_data 3.2 重写update方法 我们在修改数据的时候用save(),不能直接保存，需要我们重新在ser.py中重写update方法 1234567def update(self, instance, validated_data): instance.name = validated_data.get('title') instance.price = validated_data.get('price') instance.author = validated_data.get('author') instance.publish = validated_data.get('publish') instance.save() return instance instance 是book这个对象 validated_data是校验过的数据 instance.save()相当于book.save() 123456789&#123; \"state\": 101, \"msg\": \"数据校验失败\", \"data\": &#123; \"non_field_errors\": [ \"作者名字不能和出版社一样哦\" ] &#125;&#125; drf返回错误信息的标准写法，要有返回的错误信息 3.3 read_only 和write_only read_only 表明该字段只用于序列化输出，默认是False,设置成True，在postman里面可以看到该字段，修改的时候不需要传该字段 123456789101112131415# get方法序列化的时候输出&#123; \"title\": \"西游记\", \"price\": \"22\", \"author\": \"你得到\", \"publish\": \"西方出版社\"&#125;# put方法反序列化的时候输入&#123; \"title\": \"西游记\", \"price\": \"22\", \"publish\": \"北方出版社\"&#125; write_only 表明该字段只用于反序列化输入的时候，默认是False,设置成True，在postman里面看不到该字段，修改需要修改 12345678910111213展示时&#123; \"title\": \"西游记\", \"price\": \"22\", \"publish\": \"西方出版社\"&#125;修改时&#123; \"title\": \"西游记\", \"price\": \"22\", \"publish\": \"西方出版社\", \"author\":\"南门吹雪\"&#125; 4 查询所有和新增数据4.1 查看所有12345678class BooksAPIView(APIView): def get(self, request): response_msg = &#123;'state': 100, 'msg': '成功'&#125; books = models.Book.objects.all() books_ser = BookSerializer(books, many=True)#这里我们要查所有的字段要加参数many response_msg['data'] = books_ser.data return Response(response_msg) 这里为什么要加参数呢 4.2 many的源码123456def __new__(cls, *args, **kwargs): if kwargs.pop('many', False): return cls.many_init(*args, **kwargs) return super().__new__(cls, *args, **kwargs) 这里对象没有生成之前调用__new__方法，生成空对象，触发__init__,__new__控制对象的生成 先去BookSerializer去找_new__方法没有到父类，找到__new__方法 从kwrags取出参数pop，many默认是False，因为我们设置many是True执行下面的return，正常的实例化，many_init 1234@classmethod def many_init(cls, *args, **kwargs): list_serializer_class = getattr(meta, 'list_serializer_class', ListSerializer) return list_serializer_class(*args, **list_kwargs) 我们看到这个他是一个list，每一个都是BookModelSerializer对象 4.3 新增数据123456789def post(self,request): response_msg = &#123;'state': 100, 'msg': '成功'&#125; book_ser = BookSerializer(data=request.data) if book_ser.is_valid(): book_ser.save() def create(self, validated_data): isinstance = models.Book.objects.create(**validated_data) return isinstance 这里也遇到一个问题要重新写create方法才能保存 4.4 create方法的重写123def create(self, validated_data): isinstance = models.Book.objects.create(**validated_data) return isinstance 4.5 删除数据1234def delete(self, request, pk): models.Book.objects.filter(pk=pk).delete() response_msg = &#123;'state': 100, 'msg': '成功'&#125; return Response(response_msg) 5. 模型化类器12345678class BookModelSerializer(serializers.ModelSerializer): class Meta: model = models.Book fields = '__all__' # 序列化所有 exclude = ('title') # 排除title序列化其他字段，不能和fileds连用 extra_kwargs = &#123; # 类似于这种形式name=serializers.CharField(max_length=16,min_length=4) 'price': &#123;'write_only': True&#125;, &#125; 在3.2之后的模型类中write_only_fields弃用了 其他该写上面参数写什么参数，也可以不用重新写create和update方法 6. 自己封装Response7. Serializer高级用法 SerializerMethodField(）的使用的使用 1234567&#123; \"title\": \"西游记\", \"price\": \"12\", \"pub_date\": \"2020-07-28\", \"publish\": \"Publish object\", \"authors\": \"app01.Author.None\"&#125; 当我们跨表查询的时候，发现出版社和作者是一个对象，我们要在后端把他取出来实例化展示 123456789authors = serializers.SerializerMethodField() def get_authors(self,instance): authors = instance.authors.all() authors_list = [] for author in authors: authors_list.append(&#123;'name':author.name,'age':author.age&#125;) return authors_list 先定义一个列表，取出所有的作者，for循环把所有的作者用字典的形式添加到里面 source的使用： 1 可以改字段名字 xxx=serializers.CharField(source=&#39;title&#39;) 2 可以.跨表publish=serializers.CharField(source=&#39;publish.email&#39;) 3 可以执行方法pub_date=serializers.CharField(source=&#39;test&#39;) test是Book表模型中的方法 它里面默认的book.authors等","tags":[]},{"title":"请求和响应","date":"2020-07-09T13:59:28.811Z","path":"2020/07/09/请求和响应/","text":"请求和响应请求request常用属性：request.data,前端三种编码方式传过来都可以取出来 request.query_params和request.GET的属性一样。这个是二次封装后的属性 响应responseREST framework提供了一个响应类Response，使用该类构造响应对象时，响应的具体数据内容会被转换（render渲染）成符合前端需求的类型。 REST framework提供了Renderer 渲染器，用来根据请求头中的Accept（接收数据类型声明）来自动转换响应数据到对应格式。如果前端请求中未进行Accept声明，则会采用默认方式处理响应数据，我们可以通过配置来修改默认响应格式。 可以在rest_framework.settings查找所有的drf默认配置项： 12345678910111213141516171819REST_FRAMEWORK &#x3D; &#123; &#39;DEFAULT_RENDERER_CLASSES&#39;: ( # 默认响应渲染类 &#39;rest_framework.renderers.JSONRenderer&#39;, # json渲染器 &#39;rest_framework.renderers.BrowsableAPIRenderer&#39;, # 浏览API渲染器 )&#125;# 在视图类中局部使用：from rest_framework.renderers import JSONRenderer renderer_classes&#x3D;[JSONRenderer,] -全局使用：全局的视图类，所有请求，都有效 -在setting.py中加入如下 REST_FRAMEWORK &#x3D; &#123; &#39;DEFAULT_RENDERER_CLASSES&#39;: ( # 默认响应渲染类 &#39;rest_framework.renderers.JSONRenderer&#39;, # json渲染器 &#39;rest_framework.renderers.BrowsableAPIRenderer&#39;, # 浏览API渲染器 ) &#125; 常用属性 12345data: 返回的数据，是一个字典status：返回的状态码，默认是200tempalte_name：渲染的模板headers：响应头content_type: 响应的编码格式，application/json/text 视图基于APIView写的接口123456789101112131415161718192021222324252627282930313233343536class BookAPIView(APIView): def get(self,request,pk): book = models.Book.objects.filter(pk=pk).first() book_ser = ser.BookSerializers(book) return Response(book_ser.data) def put(self,request,pk): response_msg = &#123;'status':100,'msg':\"\"&#125; book = models.Book.objects.filter(pk=pk).first() book_ser = ser.BookSerializers(instance=book,data=request.data) if book_ser.is_valid(): book_ser.save() else: response_msg['status'] = 101 response_msg['msg'] = '失败' response_msg['data'] = request.data return Response(request.data) def delete(self,request,pk): response_msg = &#123;'status': 100, 'msg': \"\"&#125; book = models.Book.objects.filter(pk=pk).delete() return Response(response_msg)class BookSAPIView(APIView): def post(self,request): book = ser.BookSerializers(data=request.data) if book.is_valid(): book.save() return Response(book.data) def get(self, request): book = models.Book.objects.all() book_ser = ser.BookSerializers(book,many=True) return Response(book_ser.data) 基于 GenericAPIView1234567891011121314151617181920212223242526272829303132333435363738394041rom rest_framework.generics import GenericAPIViewclass Book2View(GenericAPIView): queryset = models.Book.objects serializer_class = ser.BookSerializers def get(self,request,pk): book = self.get_object() book_ser = self.get_serializer(book) return Response(book_ser.data) def put(self,request,pk): book = models.Book.objects.filter(pk=pk).first() book_ser = ser.BookSerializers(instance=book,data=request.data) if book_ser.is_valid(): book_ser.save() return Response(request.data) def delete(self,request,pk): response_msg = &#123;'status': 100, 'msg': \"\"&#125; models.Book.objects.filter(pk=pk).delete() return Response(response_msg)class Books2View(GenericAPIView): queryset = models.Book.objects serializer_class = ser.BookSerializers def get(self, request): book = self.get_queryset() book_ser = self.get_serializer(book,many=True) return Response(book_ser.data) def post(self,request): book = self.get_serializer(data=request.data) if book.is_valid(): book.save() return Response(book.data)url:url(r'^book2/(?P&lt;pk&gt;\\d+)/', views.Book2View.as_view()),url(r'^books2/', views.Books2View.as_view()), GenericAPIView+5 个视图扩展类1234567891011121314151617181920212223242526from rest_framework.mixins import ListModelMixin,CreateModelMixin,UpdateModelMixin,DestroyModelMixin,RetrieveModelMixinclass Book3View(GenericAPIView,RetrieveModelMixin,DestroyModelMixin,UpdateModelMixin): queryset = models.Book.objects serializer_class = ser.BookSerializers def get(self,request,pk): return self.retrieve(request,pk) def put(self,request,pk): return self.update(request,pk) def delete(self,request,pk): return self.destroy(request,pk)class Books3View(GenericAPIView,ListModelMixin,CreateModelMixin): queryset = models.Book.objects serializer_class = ser.BookSerializers def get(self, request): return self.list(request) def post(self,request): return self.create(request)url:url(r'^book3/(?P&lt;pk&gt;\\d+)/', views.Book3View.as_view()),url(r'^books3/', views.Books3View.as_view()), 使用ModelViewSet编写5个接口12345678from rest_framework.viewsets import ModelViewSetclass Book4View(ModelViewSet): queryset = models.Book.objects serializer_class = ser.BookSerializersurl:url(r'^book4/(?P&lt;pk&gt;\\d+)/', views.Book4View.as_view(actions=&#123;'get':'retrieve','post':'update','delete':'destroy'&#125;)),url(r'^books4/', views.Book4View.as_view(actions=&#123;'get':'list','post':'create'&#125;)) 只要使用了ModelViewSet就要重新配置路由 继承ViewSetMixin的视图类1234567891011# views.pyfrom rest_framework.viewsets import ViewSetMixinclass Book5View(ViewSetMixin,APIView): #一定要放在APIVIew前 def get_all_book(self,request): book_list = Book.objects.all() book_ser = BookSerializer(book_list, many=True) return Response(book_ser.data) # urls.py #继承ViewSetMixin的视图类，路由可以改写成这样 url(r'^books5/, views.Book5View.as_view(actions=&#123;'get': 'get_all_book'&#125;)),","tags":[]},{"title":"DRF CBV和APIView源码解读","date":"2020-07-09T13:59:25.614Z","path":"2020/07/09/DRF CBV和APIView源码解读/","text":"CBV源码1. 入口点： 1234视图class Books(View): def get(self, request): return JsonResponse(back_dic) 12from django.views import Viewurl(r'^books/',views.Book.as_view()) # 类调用的方法绑定方法 12@classonlymethoddef as_view(cls, **initkwargs): 这里我们可以看到as_view上面加了一个类方法，去@classonlymethod它继承的classmethod的方法，这个重定义的类方法比classmethod更强大，Book.as_view()，调用的时候可以不用加括号 2. 请求来时 123456789101112131415@classonlymethod def as_view(cls, **initkwargs): def view(request, *args, **kwargs): # 档次请求的request,如request.method,request.POST self = cls(**initkwargs) if hasattr(self, 'get') and not hasattr(self, 'head'): self.head = self.get self.request = request self.args = args self.kwargs = kwargs return self.dispatch(request, *args, **kwargs) view.view_class = cls view.view_initkwargs = initkwargs update_wrapper(view, cls.dispatch, assigned=()) return view ​ 请求来了，路径匹配，执行函数的内存地址(request),会把当前请求的request对象当作第一个参数传过来，执行as_view的内层函数def view(),cls(**initkwargs) 实例化得到一个对象，cls就是Books对象，用反射判断有没有get这个方法，self.request = request把当前请求的request赋值到Books对象里面的request，在视图函数里print(self.request)这个request和参数里面的request是一样的，指向一个内存地址。 ​ return self.dispatch(request, *args, **kwargs),self.dispatch,self是books，所以要到当前类视图函数寻找dispatch方法，没有才去到View去找发现了dispatch方法. 1234567def dispatch(self, request, *args, **kwargs): if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed return handler(request, *args, **kwargs) request就是当次请求的request.lower()转成小写，判断视图函数里面有没有self.http_method_names这个方法，在强调一遍这里的self始终是Book对象，没有就去父类View里面找到这个方法http_method_names = [&#39;get&#39;, &#39;post&#39;, &#39;put&#39;, &#39;patch&#39;, &#39;delete&#39;, &#39;head&#39;, &#39;options&#39;, &#39;trace&#39;],反射的意思：handler=getattr(self,&#39;get&#39;),你写的Book类的get方法的内存地址,执行get(request),原理还是FBV. 提示：如何我们只接受get请求可以在视图函数里面重写http_method_names APIView源码它的原理就是通过中间件之后执行的代码 1. 入口：123456视图class BooksAPIView(APIView) def get(self,request): passurlurl(r'^books/',views.BooksAPIView.as_view()), 这里的和CBV的原理一样，但是这里的as_view,前面加了@classmethod,这里调的是APIView里面的as_view方法 1234567@classmethod def as_view(cls, **initkwargs): view = super().as_view(**initkwargs) view.cls = cls view.initkwargs = initkwargs return csrf_exempt(view) 我们看到super调用了父类(View)的as_view方法，最后还是CBV里面的内层函数，这里的view是父类类面return 返回的view，csrf_exempt：不管你有没有把中间件里面的csrf中间件去掉， 都没有csrf认证了， 2.dispatch​ 我们把目光继续跳到父类view里面，执行到dispatch里面后，先去BooksAPIView去找发现没有这个函数，就绪它继承的父类APIView里面去找，我们可以找到这个dispatch方法，没有去APIView父类（View），如果想看查找顺序用mro， 123456789101112131415161718192021222324def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs # 重新包装一个request对象，以后再用的时候就是新的request对象 request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 这个是APIView的dispatch方法，请求来了在路由匹配上执行到了view里面的内层函数，调用了dispatch，按照查找顺序就到了这里面，request = self.initialize_request(request, *args, **kwargs)这个request是当次请求的request赋值给了self.initialize_request 1234567891011121314def initialize_request(self, request, *args, **kwargs): \"\"\" Returns the initial request object. \"\"\" parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 这个代码先忽略掉，self.initialize_request(request, *args, **kwargs)的request是当次请求的request， request = self.initialize_request，这个request是一个新的request对象，self.request = request把这个新的request赋值给了当前类的 request,视图函数里面的request已经不是django原生的request，是drf中间定义的request对象，我们导入from rest_framework.request import Request查看到， 123class BooksAPIView(APIView) def get(self,request): print(request.data) 验证：原生的request里面没有data这个属性，这个是drf的request的data属性。 3.drf的Request类3.1 原生request的封装上面我们执行到request = self.initialize_request(request, *args, **kwargs)的self调用 initialize_request这个方法，到视图类里面去找没有，再到APIView里面找到了initialize_request这个方法 12345678910111213def initialize_request(self, request, *args, **kwargs): \"\"\" Returns the initial request object. \"\"\" parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 这里return 一个Request对象，里面有一个原生的request对象，原生的request对象被封装到了Request 1234567891011121314151617181920212223242526272829303132333435363738394041class Request: \"\"\" Wrapper allowing to enhance a standard `HttpRequest` instance. Kwargs: - request(HttpRequest). The original request instance. - parsers_classes(list/tuple). The parsers to use for parsing the request content. - authentication_classes(list/tuple). The authentications used to try authenticating the request's user. \"\"\" def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( 'The `request` argument must be an instance of ' '`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.' .format(request.__class__.__module__, request.__class__.__name__) ) self._request = request self.parsers = parsers or () self.authenticators = authenticators or () self.negotiator = negotiator or self._default_negotiator() self.parser_context = parser_context self._data = Empty self._files = Empty self._full_data = Empty self._content_type = Empty self._stream = Empty if self.parser_context is None: self.parser_context = &#123;&#125; self.parser_context['request'] = self self.parser_context['encoding'] = request.encoding or settings.DEFAULT_CHARSET force_user = getattr(request, '_force_auth_user', None) force_token = getattr(request, '_force_auth_token', None) if force_user is not None or force_token is not None: forced_auth = ForcedAuthentication(force_user, force_token) self.authenticators = (forced_auth,) self._request = request在这里是原生的request对象，被包装到class Request可以用from rest_framwork.request import Request 3.2 原生method ，request.data，request.query_params123视图函数print(request.method)return HttpResponse('ok') 当我们打印的时候为什么还能打印出原来request对象的属性呢，这个是点拦截属性， 魔法语法， 点的时候会调用__getattr__ 这个是Request重新写了这个方法 123456def __getattr__(self, attr): try: return getattr(self._request, attr) except AttributeError: return self.__getattribute__(attr) 通过反射如果取method这个方法，到self._request去取出来的，如果有异常通过下面的方式取，以后是由request对象就像使用之前的request对象一样的，其实就是通过魔法方法，让你发现跟原来的一样，没有发觉。 1print(request.data),这个是方法，@property修饰了 源码：request.data 12345@property def data(self): if not _hasattr(self, '_full_data'): self._load_data_and_files() return self._full_data 我们我们一直按照_full_data点下去，其实就是一个字典，不管使用了什么方式，什么编码传过来的数据都在request.data 12345def post(self,request): print(request.data) return HttpResponse('OK') urlencoded:&lt;QueryDict: &#123;'name': ['aaaa'], 'age': ['111']&#125;&gt; json:&#123;'name': 'zzz', 'age': 333&#125; 我们发现返回的是一个QueryDict我们导入模块看一下from django.http import QueryDict 12345class QueryDict(MultiValueDict): def copy(self): \"\"\"Returns a mutable copy of this object.\"\"\" return self.__deepcopy__(&#123;&#125;) 它继承了字典，但是不能改，但是它copy一遍在修改 get请求传过来的数据 12request.GET这个能取出来，在Request又写了一个print(request.query_params)在get请求，地址参数里 123456@property def query_params(self): \"\"\" More semantically correct name for request.GET. \"\"\" return self._request.GET 这样写是为了符合rest_framwork的规范，文件也是一样重写了 好我们收回，把思路跳到我们查询请求的方式APIView里面的dispatch 123456789101112131415161718192021try: # 三大认证模块 self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed # 响应模块 response = handler(request, *args, **kwargs) except Exception as exc: # 异常模块 response = self.handle_exception(exc) # 渲染模块 self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 这里的异常处理无论出现什么错误，返回的都是json格式的错误。","tags":[]},{"title":"cookie 和session","date":"2020-07-09T13:57:51.174Z","path":"2020/07/09/cookie 和session/","text":"cookie 和sessionHTTP协议是无状态的，这意味这所有的客户端或者浏览器朝服务端发请求，服务端是不会记住客户端是谁，没办法保存用户的登录信息。 随之WEB的发展，出现了网上商城之类购物网站，这类网站的一个需求是记住当前用户是谁，并且需要记住用户的登录状态（避免每次请求页面都重新登录）。 为了解决这个需求，出现了很多总解决办法。其中最有效的一个办法是：当用户第一次登录成功后，将用户的登录信息（用户名和密码）返回给用户的浏览器，让浏览器将登录信息保存在本地浏览器(cookie)；之后用户再次访问该网站时，浏览器会携带之前保存的该网站的登录信息，这样服务端获取登录信息之后自动登录验证。 但是这种方式存在很大的安全隐患：容易泄露用户的登录信息；后来又出现了优化的解决办法。 新的解决办法是：当用户初次登录成功后，服务端会产生一个随机字符串，该字符串保存在服务端(session)，保存成键值对的形式。同时将该字符串交由客户端浏览器保存。之后再访问服务端的时候，浏览器都会带着这个随机字符串，服务端去数据库中匹配是否又这个随机字符串对应的用户信息；匹配成功则自动登录。 其实，如果截获到该随机字符串，那么就可以冒充当前用户，其实还是有安全隐患的。所以应了那句话：在web领域没有绝对的安全也没有绝对的不安全。 这就是cookie和session的出现历程。 cookie：服务端保存在客户端浏览器上的信息，它的表现形式一般都是k:v键值对(可以有多个)。cookie就是保存在客户端浏览器上的信息 session：数据是保存在服务端的并且它的表现形式一般也是k:v键值对(可以有多个)。session就是保存在服务端上的信息 session是基于cookie工作的(其实大部分的保存用户状态的操作都需要使用到cookie)。 12345678 tokensession虽然数据是保存在服务端的 但是禁不住数据量大 服务端不再保存数据 登陆成功之后 将一段用户信息进行加密处理(加密算法之后你公司开发知道) 将加密之后的结果拼接在信息后面 整体返回给浏览器保存 浏览器下次访问的时候带着该信息 服务端自动切去前面一段信息再次使用自己的加密算法 跟浏览器尾部的密文进行比对 cookiecookie基本操作虽然cookie是服务端告诉客户端浏览器需要保存内容，但是客户端浏览器可以选择拒绝保存；如果将浏览器设置为禁止保存服务端的cookie，那么只要是需要记录用户状态的网站登陆功能都无法使用了。 视图函数的返回有三种形式，HttpResponse ，render , redirect 三种形式 其实本质上内部返回的都是HttpResponse 对象，我们可以直接返回也是先将对象用一个变量保存下来在返回 123456789101112131415方式一return HttpResponse()return render()return direct()方式2obj1 = HttpResponse()return obj1 obj2 = render()return obj2 obj3 = redirect()return obj3 我们感觉用这样的方式就是多此一举，但是这种方式可以使用在cookie上面，利用返回对象的方式来设置cookie 设置cookie 1obj.set_cookie(key,value) 获取cookie 12request.COOKIES[key]request.COOKIES.get(key) 设置cookie超时时间 12345obj.set_cookie(key,value,max_age=3)obj.set_cookie(key,value,expires=3)\"\"\"这两个都是设置超时时间的，都是秒为单位，expires是针对IE浏览器的\"\"\" 删除cookie 1obj.delete_cookie(key) # 删除用户浏览器上之前设置的usercookie值 cookie版本的登录思路：# 我们完成一个真正的登陆功能，校验用户是否登陆的装饰器，用户如果在没有登陆的情下想访问一个需要登陆的页面，那么先跳转到登陆页面 当用户输入正确的用户名和密码之后 登录认证装饰器 12345678910def login_auth(func): def inner(request,*args,**kwargs): # print(request.path_info) # print(request.get_full_path()) # 能够获取到用户上一次想要访问的url target_url &#x3D; request.get_full_path() if request.COOKIES.get(&#39;username&#39;): return func(request,*args,**kwargs) else: return redirect(&#39;&#x2F;login&#x2F;?next&#x3D;%s&#39;%target_url) return inner view视图 123456789101112131415161718192021222324252627282930313233def login(request): if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') if username == 'jason' and password == '123': # 获取用户上一次想要访问的url target_url = request.GET.get('next') # 这个结果可能是None if target_url: obj = redirect(target_url) else: # 保存用户登陆状态 obj = redirect('/home/') # 让浏览器记录cookie数据 obj.set_cookie('username', 'jason666') \"\"\" 浏览器不单单会帮你存 而且后面每次访问你的时候还会带着它过来 \"\"\" # 跳转到一个需要用户登陆之后才能看的页面 return obj return render(request,'login.html')@login_authdef home(request): # 获取cookie信息 判断你有没有 # if request.COOKIES.get('username') == 'jason666': # return HttpResponse(\"我是home页面，只有登陆的用户才能进来哟~\") # # 没有登陆应该跳转到登陆页面 # return redirect('/login/') return HttpResponse(\"我是home页面，只有登陆的用户才能进来哟~\") cookie 其他操作1234567891011121314151617181920 # 获取cookierequest.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)参数： default: 默认值 salt: 加密盐 max_age: 后台控制过期时间 # 设置cookierep.set_signed_cookie(key, value, salt='加密盐', max_age=None, ...)参数： key, 键 value='', 值 max_age=None, 过期时间 expires=None, 过期时间(IE requires expires, so set it if hasn't been already.) path='/', Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问 domain=None, Cookie生效的域名 secure=False, 是否https传输 httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） sessionCookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取。因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是Session。 问题来了，基于HTTP协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的Cookie就起到桥接的作用。 我们可以给每个客户端的Cookie分配一个唯一的id，这样用户在访问时，通过Cookie，服务器就知道来的人是“谁”。然后我们再根据不同的Cookie的id，在服务器上保存一段时间的私密资料，如“账号密码”等等。 总结而言：Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在Session里保存私密的信息以及超过4096字节的文本。 另外，上述所说的Cookie和Session其实是共通性的东西，不限于语言和框架。 session 的基本操作django种的session是通过request对象下的session完成的，它类似与一个字典，操作方式和字典也是差不多的 session数据是保存在服务端的(存？)，给客户端返回的是一个随机字符串sessionid:随机字符串 在默认情况下操作session的时候需要django默认的一张django_session表 django默认session的过期时间是14天，可以认为修改它。 session是保存在服务端的，但是session的保存位置可以有多种选择：数据库、文件等等 django_session表中的数据条数是取决于浏览器的，同一个计算机上(IP地址)同一个浏览器只会有一条数据生效。主要是为了节省服务端数据库资源。 设置session 1request.session['key']=value 获取session 1request.session.get('key') 设置过期时间 123456request.session.set_expiry() 括号内可以放四种类型的参数 1.整数 多少秒 2.日期对象 到指定日期就失效 3.0 一旦当前浏览器窗口关闭立刻失效 4.不写 失效时间就取决于django内部全局session默认的失效时间 *清除session * 12345request.session.delete() # 只删服务端的 客户端的不删request.session.flush() # 浏览器和服务端都清空(推荐使用) 这用于确保前面的会话数据不可以再次被用户的浏览器访问 session内部的那些事设置session request.session[‘is_login’] = ‘yes’ 12341. django内部会自动帮你生成一个随机字符串2. django内部自动将随机字符串和对应的数据存储到django_session表中, 先在内存中产生操作数据的缓存,在响应结果django中间件的时候才真正的操作数据库3. 将产生的随机字符串返回给客户端浏览器保存 request.session.get(‘is_login’) 12341.自动从浏览器请求中获取sessionid对应的随机字符串2.拿着该随机字符串去django_session表中查找对应的数据 3. 如果比对上了 则将对应的数据取出并以字典的形式封装到request.session中 如果比对不上 则request.session.get()返回的是None session实现登录认证登录装饰器 1234567891011121314from functools import wrapsfrom django.shortcuts import redirect def login_auth(func): @wraps(func) def inner(request, *args, **kwargs): target_url = request.get_full_path() # 获取用户想要访问的url if request.session.get('login_auth_key') res = func(request, *args, **kwargs) return res else: return redirect(f'/login/?next=&#123;target_url&#125;') # 设置登录后跳转的页面url return inner 视图函数：views.py 1234567891011121314151617from utils.login_auth import login_auth def login(request): if request.method == 'POST': if login_success:# 伪代码 target_url = request.GET.get('next') or 'index' # 登录前要访问的页面或者直接到index request.session['login_auth_key'] = 'is_login' return redirect(target_url) return render(request, 'login.html', locals()) @login_authdef logout(request): request.session.flush() return redirect('login') django中的session设置12345678910111213141516171819202122232425262728 1. 数据库SessionSESSION_ENGINE = 'django.contrib.sessions.backends.db' # 引擎（默认） 2. 缓存SessionSESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 引擎SESSION_CACHE_ALIAS = 'default' # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置 3. 文件SessionSESSION_ENGINE = 'django.contrib.sessions.backends.file' # 引擎SESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() 4. 缓存+数据库SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db' # 引擎 5. 加密Cookie SessionSESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies' # 引擎 其他公用设置项：SESSION_COOKIE_NAME ＝ \"sessionid\" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）SESSION_COOKIE_PATH ＝ \"/\" # Session的cookie保存的路径（默认）SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认）SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认）SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认）SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）（默认）SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认）SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认） CBV如何添加装饰器12345678910111213141516171819from django.views import Viewfrom django.utils.decorators import method_decorator\"\"\"CBV中django不建议你直接给类的方法加装饰器无论该装饰器能都正常给你 都不建议直接加\"\"\"# @method_decorator(login_auth,name='get') # 方式2(可以添加多个针对不同的方法加不同的装饰器)# @method_decorator(login_auth,name='post')class MyLogin(View): @method_decorator(login_auth) # 方式3:它会直接作用于当前类里面的所有的方法 def dispatch(self, request, *args, **kwargs): return super().dispatch(request,*args,**kwargs) # @method_decorator(login_auth) # 方式1:指名道姓 def get(self,request): return HttpResponse(\"get请求\") def post(self,request): return HttpResponse('post请求')","tags":[]},{"title":"linux基本命令","date":"2020-07-09T13:56:52.668Z","path":"2020/07/09/linux基本命令/","text":"[linux基本命令]VMware隔离Windows和Linux、Centos.iso–Linux安装包、生成Linux操作系统。 虚拟机： 当前linux包含：centos，redhat(红帽子)，Ubuntu linux工作中的用处： 1、搭建测试环境 2、log日志排查问题（开发会将开发步骤写入日志，当其中一步出错进行不到下一步时，测试截出与开发一起解决） 软件bug: 安装过的软件， 还可以安装 3、Xshell：链接Linux系统的客户端：需要ip地址 端口号 Linux系统的用户名 ,密码 4、navicat：链接数据库的客户端 连接数据库需要：ip 地址 数据库的端口号 数据库的用户名，密码 查看电脑IP：有线网看以太网、无线网看无线局域网。 Linux命令=shell命令 Linux 1、ls –查看当前所在的位置下有哪些文件和文件夹 -a显示所有文件，包括隐藏文件（ls -a隐藏文件是白色） -l使用长格式显示 ls -l == ll （查看d开头是目录，没有d是文件。查看权限） -F附加文件类别，符号在文件名最后 -R陆续显示目录 -d列出指定的目录 2、【root@192 】root–登录的用户名、192–主机名、当前目录名称 3、绝对路径—两个没有关联的路径切换 4、相对路径—有关联的 5、父目录切子目录—cd 子目录名 6、 cd ..子目录去父目录 cd ../ yan切换到上一层目录的yan目录 7、Pwd—显示当前路径 8、家目录：root登录家目录在/root（管路员家目录），普通用户在/home/用户名 （以什么用户登录，就在此家目录下） 9、cd回车—切换到家目录下 10、mkdir—建文件夹 11、touch—建文件 12、rm—删除（rm -rf强制删除，不提示确定删除） 13、man ls 查看ls指令的帮助信息（ctrl+z退出man） 14、cp -pr [源文件或目录路径] [目的文件或目录的路径] cp 默认为cp -i（-i为提示名字重复，是否覆盖）如果想不提示直接覆盖同名文件 /cp 15、复制当前目录到别的地方（cp -r . 粘贴的路径） 16、-p保留原文件的日期属性、-r递归复制所有文件、- f 若目的地已经有相同名字的档案存在，则在复制前先予以删除再行复制而不提示。 17、移动/剪切：mv 【源文件路径】 【目的文件路径】。 改名：mv 原文件名 更改的文件名 18、Rz、—将windows的文件传到linux。Sz—将linux的文件传到windows 传输后查看文件内容：cat 文件名（内容全部显示在屏幕上，如果内容太多，只能看最后一些内容）；more 文件名，只能向下翻页。Less 文件名 上下都能翻（b向上翻页，f向下翻页）； 19、查看前后几行（看前后n行,-f实时更新。不加行数，默认10行）：①head -f -n 文件名②tail -f -n 文件名 Ctrl+Z退出 20、vi 文件名—-查看文件内容、i—编辑文件、esc退出编辑、shift+：wq! 强制保存、shift+：q! 强制不保存退出、shift+：q 不保存退出。 21、查找文件里一些内容：①vi文件路径—-/需要的内容 ②grep 需要内容 文件路径 22、grep 查找内容 文件路径 -C n行数 –color=auto （查找文件内容加色，并把上下n行显示出来） 23、①在vi在替换内容:%s/需要改的内容/修改后的内容/g（文件里需要修改的内容全部修改）eg: :%s/hello/world/g—把hello全部改成world ②直接替换内容sed -i s/hello/world/g t1.txt —-把t1.txt里的hello改成world 24、wc统计 -c字节 -w字数 -l行数 25、ll查看后 创建者权限、组员权限、其他权限 创建人名、组名 创建日期 26、权限：4 r、2 w、1 x 读写执行7=4+2+1、读写 6=4+2、读执行 5=4+1、写执行 3=2+1 用户：u创建者、g组员、o其他 27、chmod u+w 文件名 文件给用户加上写的权限 28、chmod g-r 文件名 文件给组员减去读取权限 29、chmod o+x 文件名 文件给其他加上执行权限 30、chmod -R 权限 父目录 （修改父目录及所有子目录的权限） 每建一个用户，就默认生成与用户名相同的组 31、su 用户名 切换用户 32、chown -R 用户名 文件名（修改文件及所有子目录所有者u） 33、chgrp -R 组名 文件名 （修改文件及所有子目录所属组g） 34、groups 用户名 查看用户的所属组 35、usermod -a -G 组名 用户名 将用户拉到组里 36、find 路径 -name “.t?t” （同数据库里的% 匹配多个字符、？同数据库_匹配一个字符） 37、管道符：ll|wc -l （统计ll查找下有多少行） ①取文件的10到20行，先取前20行，再取这20行的后11行 head -20 t1.txt|tail -11 ②统计文件中的某个内容 出现多少次。 先把需求内容找出来，每个一行再统计有多少行（grep -o 需要内容 文件名|wc -l） 38、clear清除屏幕、 history查看历史代码记录 39、创建用户：adduser 用户名 修改用户名：usermod -l 新用户名 老用户名 设置（修改）密码：passwd 用户名 删除用户：userdel （-r 删除用户目录） 用户名 40、查看用户信息cat /etc/passwd、 查看密码信息cat /etc/shadow 41、查看系统进程与内存：win—任务管理器/性能 ​ Linux—top -d 1（每隔1s刷新状态信息） Ctrl+Z退出刷新状态信息 42、结束系统进程：win—任务管理器右键结束 Linux—-kill -9 进程号 43、功能描述：查看系统中运行的进程。 44、范例：# ps -aef # ps -A 查看所有进程，和ps -e功能相同 查看进程的某一行内容 ps–ef|grep需要内容 45、查看系统信息：uname -ra ​ -r 显示操作系统发布版本 -a 显示系统所有标示信息 46、IP访问电脑、IP+端口号这台电脑的不同应用 47、启动程序：sh 文件名 48、查看端口状态（通过进程编号查看应用所占的端口号）：netstat -tnlup、ps -ef|grep 文件名、netstat -tnlup|grep 进程编号 49、压缩包—-①tar压缩：tar -zcvf 压缩包名 要压缩文件名 ​ tar解压：tar -zxvf 解压文件名 ​ ②zip压缩：zip -r 压缩包名 要压缩文件名 ​ zip解压：unzip 压缩包名 -d 压缩到的路径 50、df命令–功能：检查文件系统的磁盘空间占用情况 df -ah ​ -a 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc文件系统。 ​ -k 以k字节为单位显示。 ​ -h 以可读性较好的方式显示。 ​ -T 显示文件系统类型。 51、du (disk usage)命令–功能：统计目录（或文件）所占磁盘空间的大小 ​ du -sh 文件路径—-显示某个文件所占空间 ​ du -ah 文件路径—- 52、Linux安装：yum -y install 安装包名","tags":[]},{"title":"存储引擎","date":"2020-07-09T13:56:43.073Z","path":"2020/07/09/存储引擎/","text":"存储引擎针对不同的文件格式会有不同的存储方式和处理机制，针对不同的数据应该有对应不同的处理机制来存储 mysql主要的存储引擎 innodb 这个是mysql5.5版本之后默认的存储引擎，存储数据更加的安全 myisam 这个是mysql5.5版本之前默认的存储引擎，速度比innodb更快，但是数据不安全 memory 内存引擎，数据全部放在内存中，断电数据丢失 blackhole 无论存什么，都会立刻消失 12345678910111213# 查看所有引擎show engines;# 不同的存储引擎在存储表的时候的异同点create table t1(id int) engine=innodb;create table t2(id int) engine=myisam;create table t3(id int) engine=memory;create table t4(id int) engine=blackhole;# 存数据insert into t1 values(1);insert into t2 values(1);insert into t3 values(1);insert into t4 values(1);查看表发现t1 and t2有东西，但是只要mysql重新启动，t3就是空，t4会即刻释放 创建表的完整语法 1234567# 语法create table 表名( 字段名1 类型(宽度) 约束条件 字段名2 类型(宽度) 约束条件 字段名3 类型(宽度) 约束条件 字段名4 类型(宽度) 约束条件) 强调 在同一张表中字段名字不能重复 宽度和约束条件是可选的，约束条件支持多个 类型(宽度) 约束条件1 约束条件2；```1234567891011 &#96;&#96;&#96; create table t5(id); &#96;&#96;&#96;报错* 最后一行不能有逗号 &#96;&#96;&#96; python create table t6( id int, name char ) 补充说明 宽度：一般情况下指对存储数据的限制 123create table t7(name char); 默认宽度是1insert into t7 values('json');insert into t7 values(null);null是关键字 针对不同的版本是出现不同的效果 5.6版本默认没有开启严格模式，规定只能存放一个字符，多出的字符自动截取 5.7版本以上是开启了严格模式，规定存放的个数，多出自动报错 严格模式： mysql5.7之后的版本是默认开启的严格模式，使用数据库的标准就是：能尽量少的让数据库敢活就尽量少，不给数据库增加额外的压力。 约束条件：null not null不能插入rull table t8(id int,name char not null)```1234567891011121314151617181920212223242526272829303132333435363738394041* **宽度和约束条件的关系**：宽度是限制数据的存储，约束条件是在宽度的基础上增加额外的约束## 基本数据类型### 整型* **分类**： TINYINT SMALLINT MEDUIMINT INT BIGINT* **作用**： 存一些年龄，等级 id，号码等等例子：**TINYINT** 是否有符号，默认的是带符号的，超出限制存最大可接受值&#96;&#96;&#96; pythoncreate table t9(id tinyint);insert into t9 values(-129),(256);# 约束条件unsigned 无符号create table t10(id tinyint unsigned);create table t11(id int);# int 默认也是带符号的，整型默认情况下的欧式带有符号的# 针对整型 括号内的宽度有限create table t12(id int(8));insert into t12 values(123456789)&quot;&quot;&quot;特例:只有整型括号里面的数字不是表示限制位数id int(8) 如果数字没有超出8位 那么默认用空格填充至8位 如果数字超出了8位 那么有几位就存几位(但是还是要遵守最大范围)&quot;&quot;&quot;create table t13(id int(8) unsigned zerofill);# 针对整型字段括号内无需指定宽度，默认的宽度足够显示所有数据 严格模式 123456789101112131415# 如何查看严格模式show variables like \"%mode\";模糊匹配/查询 关键字 like %:匹配任意多个字符 _:匹配任意单个字符# 修改严格模式 set session 只在当前窗口有效 set global 全局有效 set global sql_mode = 'STRICT_TRANS_TABLES'; 修改完之后 重新进入服务端即可 浮点型 char(4) 数据超过4个字符直接报错，不厚的字符空格补全 varchar(4) 数据超过4个字符直接报错，不够截取 12345678910create table t18(name char(4));create table t19(name varchar(4));insert into t18 values('a');insert into t19 values('a');# 统计char_length字段长度select char_length(name) from t18;# char硬盘里存放的是真正的数据，带有空格的，但是在mysql显示会自动将多余的空格剔除# 再次修改sql_mode 让MySQL不要做自动剔除操作set global sql_mode='STRICT_TRABLES,PAD_CHAR_TO_FULL_LENGTH' char和varchar对比： 12345678char 缺点：浪费空间 优点：直接按照固定的字符存取数据 json egon alex wusir tank 存按照五个字符存，取也是五个字符取 varchar 优点：节省空间 缺点：存取比较麻烦 存的时候需要制作报头，取也需要报头，最后才能取到真实的数据， 时间类型 分类：data： 年月日2015-2-03 ​ datatime：年月日时分秒 ​ time：时分秒 ​ Year:2020 123456789create table student( id int, name varchar(6), born_year year, birth data, study_time time, reg_time datatime);insert into student values(1,'zc','1990','1999-11-11','11:11:11','2020-11-11 11:11:11'); 枚举与集合 分类：枚举（多选一） ​ 集合（多选多） 具体用法 1234567891011121314151617181920create table user( id int, name char(16), gender enum('male','female'));insert into user values(1,'zc','male')# 枚举后期存数据的时候只能从里面悬着一个存储create table teacher( id int, name char(6), gender enum('male','female'), hobby set('read','play','running'))；insert into teacher values(1,'zc','male','read');insert into teacher values(2,'zcc','female','read,running');insert into teacher values(2,'zcz','male','eat');# 集合可以写一个或选择多个，但是不能写里面没有的","tags":[]},{"title":"基于python面向对象多人聊天室","date":"2020-07-09T13:56:36.843Z","path":"2020/07/09/基于python面向对象多人聊天室/","text":"基于python面向对象多人聊天室流程项目环境 项目环境 项目名称：多人聊天室 项目模式：C/S 开发环境：win10+python3.6+pycharm 所需知识：python GUI编程，多线程编程，网络编程，数据库编程 程序设计了解一下服务器扮演的角色，下面是服务器的业务流程。大致是怎样工作的 首先服务器在指定的端口进行监听，等待客户的链接 客户端链接到服务器之后，服务器开启单线程来处理该用户的请求 处理线程等待客户端发送的请求 服务器根据客户端请求类型的不同，调用不同处理的函数 处理完客户端请求之后，再次回到第三步继续等待处理客户端新的请求 客户端退出登录，服务器也会关闭对客户端的处理线程，释放资源 响应协议设计我们都知道三次握手和四次挥手，这里呢我们约定了客户端发送什么样格式的数据给服务器，服务器又需要返回什么样格式的数据给客户端，客户端会有不同的请求，所以我们针对不同的请求个响应定义了需求个相应号，来区分不同的请求和响应 网络上一般使用json和xml格式来传输数据，但是用他们来传输，对于我们的项目有点复杂，我们的项目没有这么复杂的数据，我们采用|进行分割 ，然后拿到数据进行split一下就可以了。 登录响应格式: 1001|ret|nickname|username,其中ret 代表服务器端验证的结果，如果是0,表示服务端验证失败，后面的nickname username 会为空字符串，若是1 ，表示服务端验证成功，nickname 为服务端返回的该用户的昵称，username 是该用户的用户名。 聊天的响应格式：1002|nickname|message, nicakname 是为聊天信息发送者的昵称，message 是发送的聊天信息 下面我们定义了服务端需要的一些常量，以及为了实现客户端和服务端通信定义的一些协议编号，协议编号如下 1234567891011config.py# ----服务器相关配置----SERVER_IP = '127.0.0.1' # 服务器IP地址SERVER_PORT = 8090 # 服务器端口号# ----数据协议相关配置----REQUEST_LOGIN = '0001' # 登录请求REQUEST_CHAT = '0002' # 聊天请求RESPONSE_LOGIN_RESULT = '1001' # 登录结果响应RESPONSE_CHAT = '1002' # 聊天响应DELIMITER = '|' # 自定义协议数据分隔符 面向对象的思想","tags":[]},{"title":"批量插入","date":"2020-07-09T13:56:30.866Z","path":"2020/07/09/批量插入/","text":"批量插入12345678910111213141516171819def ab_pl(request): # 先给Book插入一万条数据 # for i in range(10000): # models.Book.objects.create(title='第%s本书'%i) # # 再将所有的数据查询并展示到前端页面 book_queryset = models.Book.objects.all() # 批量插入 # book_list = [] # for i in range(100000): # book_obj = models.Book(title='第%s本书'%i) # book_list.append(book_obj) models.Book.objects.bulk_create(book_list) \"\"\" 当你想要批量插入数据的时候 使用orm给你提供的bulk_create能够大大的减少操作时间 :param request: :return: \"\"\" return render(request,'ab_pl.html',locals())","tags":[]},{"title":"由django中间件引发的编程思想","date":"2020-07-09T13:56:26.963Z","path":"2020/07/09/由django中间件引发的编程思想/","text":"由django中间件引发的编程思想创建一个文件夹，把一个个功能写成一个个py文件,假如我们写一个消息通知，让qq， 微信，邮箱都能接收到，qq， 微信，邮箱就是一个个功能 aapp02文件夹下的qq.py 12345class Qq(object): def __init__(self): pass def send(self,content): print(f'QQ通知：&#123;content&#125;') aapp02文件夹下的wechat.py 12345class Wechat(object): def __init__(self): pass def send(self,content): print(f'微信通知：&#123;content&#125;') aapp02文件夹下的email.py 12345class Email(object): def __init__(self): pass def send(self,content): print(f'邮件通知：&#123;content&#125;') aapp02文件夹下的__init__.py 12345678910import settingsimport importlibdef send_all(content): for path_str in settings.APP02_LIST: module_path ,class_name = path_str.rsplit('.',maxsplit=1) module = importlib.import_module((module_path)) #1 利用字符串导入模块 cls = getattr(module,class_name) # 2 利用反射获取类名 obj =cls() # 3 生成类的对象 obj.send(content) # 4 利用鸭子类型直接调用send方法 settings.py: 123456APP02_LIST = [ 'aapp02.email.Email', 'aapp02.qq.Qq', 'aapp02.wechat.Wechat',] start.py 12import aapp02aapp02.send_all('下课了') 当我们添加或者删除一个功能的时候，只需要在seetings里面添加或注释掉就可以了.","tags":[]},{"title":"bbs","date":"2020-07-05T12:43:05.741Z","path":"2020/07/05/bbs/","text":"[TOC] js只要用到内置对象，直接用new生成就可以了 1. 用户注册上传头像123456789101112131415161718192021222324&lt;div class=\"form-group\"&gt; &lt;label for=\"myfile\"&gt;头像 &#123;% load static %&#125; &lt;img id=\"myimg\" src=\"&#123;% static 'img/default.png' %&#125;\" alt=\"\" width=\"80\" style=\"margin-left: 20px\"&gt;&lt;/label&gt; &lt;input type=\"file\" id=\"myfile\" name=\"avater\" style=\"display: none\"&gt;&lt;/div&gt;&lt;script&gt; //文本域变化事件 $('#myfile').change(function () &#123; //文件阅读器对象 //1.先生成一个文件阅读器对象 let myFileReadObj = new FileReader(); // 文件阅读器 //2. 获取用户上传的头像文件 let fileObj = $(this)[0].files[0]; //获取文件 // 3.将文件对象交给文件阅读器读取 myFileReadObj.readAsDataURL(fileObj) //异步操作，io操作，这行代码文件还没有读完，就已经开始执行下一句代码，在前端不显示 //4.利用文件阅读器将文件展示到页面去 修改src属性 //等待文件阅读器加载完之后，在执行 myFileReadObj.onload = function()&#123; $('#myimg').attr('src',myFileReadObj.result)&#125; &#125;) 这里我们要用到文本与变化事件，利用文件阅读器对象，我们要先生成一个文件阅读器对象， 获取用户上传的头像文件读取出来 将文件对象交给文件阅读器读取出来文件 利用文件阅读器将文件展示到页面上去，就要修改src属性，myFileReadObj.readAsDataURL(fileObj)和$(&#39;#myimg&#39;).attr(&#39;src&#39;,myFileReadObj.result)这两部是一个异步操作，如果你在执上一代码的同时文件还没有读取出来，同时他还在执行下一句代码，这样会造成你上传之后在前端是不显示你上传的头像，空白区，我们要等文件加载完毕在执行下一局，myFileReadObj.onload 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 $('#id_commit').click(function () &#123; // 发送ajax请求 我们发送的数据中即包含普通的键值也包含文件 let formDataObj = new FormData(); // 1.添加普通的键值对 &#123;#console.log($('#myform').serializeArray()) // [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;] 只包含普通键值对#&#125; $.each($('#myform').serializeArray(),function (index,obj) &#123; &#123;#console.log(index,obj)#&#125; // obj = &#123;&#125; formDataObj.append(obj.name,obj.value) &#125;); // 2.添加文件数据 formDataObj.append('avatar',$('#myfile')[0].files[0]); // 3.发送ajax请求 $.ajax(&#123; url:\"\", type:'post', data:formDataObj, // 需要指定两个关键性的参数 contentType:false, processData:false, success:function (args) &#123; if (args.code==1000)&#123; // 跳转到登陆页面 window.location.href = args.url &#125;els // 如何将对应的错误提示展示到对应的input框下面 // forms组件渲染的标签的id值都是 id_字段名 $.each(args.msg,function (index,obj) &#123; &#123;#console.log(index,obj) // username [\"用户名不能为空\"]#&#125; let targetId = '#id_' + index; $(targetId).next().text(obj[0]).parent().addClass('has-error') &#125;) &#125; &#125; &#125;) &#125;)def register(request): # 产生一个空对象 register_form = myforms.MyRegForm() if request.method == 'POST': back_dic = &#123;'code':'', 'msg': ''&#125; # 校验数据是否合法 register_form = myforms.MyRegForm(request.POST) # 判断数据是否合法 if register_form.is_valid(): clean_data = register_form.cleaned_data # 将校验通过的数据字典赋值给一个变量 # 将字典里面吗的confirm_password键值对删除 clean_data.pop('confirm_password') # 用户头像 file_obj = request.FILES.get('avatar') \"\"\" 针对用户头像一定要判断是否传之，不能直接添加到字典里面去 \"\"\" if file_obj: clean_data['avatar'] = file_obj # 直接操作数据库保存到字典里面 models.UserInfo.objects.create_user(**clean_data) # 将键值对**打散传到数据库 # 判断正确跳转到登录页面 back_dic['url'] = '/login/' else: back_dic['code'] = 2000 back_dic['msg'] = register_form.errors return JsonResponse(back_dic) return render(request, 'register.html', locals()) 前端： 头像的功能完成之后，剩下的就是将利用ajax将文件发送到后端，前端要先利用内置对象获取数据，添加不同键值对，我们可以利用serializeArray()拿到他所有的键值对，利用each循环拿到每一个对象的键值对 利用append添加文件数据，发送ajax请求，这里面我们要指定两个关键参数contentType: false,processData: false, 如果后端保存数据成功，就跳转到后端写好传过来的指定页面，如果校验数据失败就在input框下面展现出对应的错误 当我们看见错误的信息之后，如果把鼠标放上去，指定的错误就会消失，给所有的input框绑定获取焦点事件，将input下面的span标签和input外面的div标签修改内容和属性 后端 校验数据输入的是否合法，将合法的数据赋值给一个变量，赋值给一个变量方便我们删除确认密码的键值对，因为我们在写models的时候没有这个字段，针对用户头像一定要判断是否传之，不能直接添加到字典里面去，在models里面我们给他默认了一个头像 操作数据库保存数据，定义字典将信息返回给ajax，ajax都到在页面展示对应的页面信息 存取问题： 1234class RegisterForm(forms.Form): data = register_form.cleaned_data models.UserInfo.objects.create_user(**data) 这里我们在前端像后端存的时候出现了问题，原因是models里面的username和password必须和form表单里面的字段名一致，因为我们去表单里面验证的时候用的是form表单里面的字段名去数据库里面存，**data的时候字段名这个和数据库里面的字段名不一样 2. 生成登录验证码如何生成一个验证码，然后点击它就可以刷新呢。 利用pip3 install pillow ，这个是图片相关的模块。 导入模块：from PIL import Image, ImageDraw, ImageFont Image 生成图片 ImageDraw 能够在图片上添加东西 ImageFont 控制字体的样式 推导1： 直接获取后端生成的图片二进制数据发送给前端 123with open(r'static/img/111.jpg','rb') as f: data = f.read()return HttpResponse(data) 推导2 利用pillow模块动态产生图片 12345678910img_obj = Image.new('RGB',(430,35),'green')img_obj = Image.new('RGB',(430,35),get_random())# 将图片对象 保存起来with open('xxx.png','wb') as f: img_obj.save(f,'png')# 再将文件对象读取出来with open('xxx.png','rb') as f: data = f.read()return HttpResponse(data) 推导3我们可以看到利用文件存储繁琐而且IO操作效率低，我们可以借助内存管理模块 12345from io import BytesIO,StringIOimg_obj = Image.new('RGB', (430, 35), get_random())io_obj = BytesIO()img_obj.save(io_obj,'png') # 生成一个内存管理器对象return HttpResponse(io_obj.getvalue()) # 从内存管理器中读取二进制的图片数据返回给前端 推导4 写成图片验证码 123img_obj = Image.new('RGB', (430, 35), get_random())img_draw = ImageDraw.Draw(img_obj) # 产生一个画笔对象img_font = ImageFont.truetype('static/font/222.ttf',30) # 字体样式 大小 最终成型 1234567891011121314151617181920import randomdef get_random(): return random.randint(0,255),random.randint(0,255),random.randint(0,255)def get_code(request): img_obj = Image.new('RGB', (430, 35), get_random()) # 注意：这里的430，35要和前端的一致 img_draw = ImageDraw.Draw(img_obj) img_font = ImageFont.truetype('static/font/222.ttf',30) code = '' for i in range(5): random_upper = chr(random.randint(65,90)) random_lower = chr(random.randint(97,122)) random_int = str(random.randint(0,9)) tmp = random.choice([random_lower,random_upper,random_int]) img_draw.text((i*60+60,-2),tmp,get_random(),img_font) code += tmp print(code) request.session['code'] = code io_obj = BytesIO() img_obj.save(io_obj,'png') return HttpResponse(io_obj.getvalue()) 实现低级验证码图片刷新验证码，这样设置后每次点击图片相当于超后端发送一次get请求获取一个新的验证码图片 1234&#123;# 点击验证码图片刷新验证码 #&#125;$('#code_img').click(function () &#123; $(this).attr('src', '&#123;% url \"get_code\" %&#125;?') // src='/get_code/?'url后面加?的操作&#125;); 3. admin的使用以前写图书的展示列表，我们给它添加增删改查的功能，特别的麻烦，现在有很多张表的展示，我们不可能慢慢的写这些功能，django给我们提供了admin后台管理，我们可以利用admin实现增删改查，添加数据。 首先要创建超级用户，只有超级用户才能够操作admin的这些功能。 刚开始登录进去的时候只用一张用户表，我们想要添加其他的表，必须添加注册 1234567891011from django.contrib import adminfrom app01 import models# Register your models here.adminadmin.site.register(models.UserInfo)admin.site.register(models.Blog)admin.site.register(models.Article)admin.site.register(models.Atricle2Tag)admin.site.register(models.UpAndDown)admin.site.register(models.Category)admin.site.register(models.Tag)admin.site.register(models.Comment) 这样我们就可以使用这些表，但是他们是英文的，我们可以在model.py里面改变他们的名字 12class Meta: verbose_name_plural='用户表' 我们进去操作添加添加一条数据显示的是对象， 1234class UserInfo(AbstractUser): ...def __str__(self): return self.username 避免造成不便语义不明，打印出来 在model里面的字段添加verbose_name=&#39;创建时间&#39;会在admin后天帮助我们把字段的名称改成中文 4. 制作站点打开博客园，在博客园的url后面输入别人的站点名称就可以进到他们的站点，如https://home.cnblogs.com/the3times在后面输入`the3times`就会进到这个人的博客园的主页，这个是url来配置的，利用url`re`匹配规则就可以实现 1url(r'^(?P&lt;username&gt;\\w+)/$',views.site,name='site'), 5. media的配置网站用户使用的静态文件默认放在static里面，用户上传的静态文件应该单独放在一个文件夹下，可以使用media配置，该配置可以让用户上传的所有的文件 固定存放在指定的文件夹下 settings.py 12# 配置用户上传的文件MEDIA_ROOT = os.path.jion(BASE_DIR,'media') 我们配置后，我们上传文件会自动生成media文件，比如我们注册上传的头像会到这个地方，你存的路径在数据库中也不会改变， 假如你在model.py里面存的路径是avatar/111.pngmedia里面就会多出一个存放头像的avatar/111.png这个就是你存放的头像路径。 12class UserInfo(AbstractUser): avatar = models.FileField(upload_to='avatar/', default='avatar/default.png', verbose_name='用户头像') 在前端点击这个头像能够查看到这个头像，需要我们在后端开设一个指定的文件夹资源 在url.py配置参数 1234from django.views.static import servefrom bbs import settingsurl(r'^media/(?P&lt;path&gt;.*)',serve,&#123;'document_root':settings.MEDIA_ROOT&#125;), 如果你还想暴漏更多资源，在settings修改文件夹名，想暴露源码也可以，问题就大了 最后在html配置,渲染后的路径/media/avatar/default.png/ 1&lt;img class=\"media-object\" src=\"/media/&#123;&#123; article_obj.blog.userinfo.avatar &#125;&#125;\" alt=\"...\" width=\"40\"&gt; 这样就可以看到别人的头像 6. 站点左边栏展示左侧边栏展示如何展示的，要清楚orm的查询 123456 # 1.查询当前用户所有分类及分类下的文章数category_list=models.Category.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list('name','count_num','pk') # 2.查询当前用户所有标签及标签的文章数tag_list=models.Tag.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list('name','count_num','pk') # &lt;QuerySet [('tank的标签一', 1), ('tank的标签二', 1), ('tank的标签三', 2)]&gt;# 3.按照日期归档date_list=models.Article.objects.filter(blog=blog).annotate(month=TruncMonth('create_time')).values('month').annotate(count_num=Count('pk')).values_list('month','count_num') 这里的日期归档我们按照年月归档，但是数据库里面有年月日，我们如何把日去掉官方提供了一个方法 123456from django.db.models.functions import TruncMonth Sales.objects .annotate(month&#x3D;TruncMonth(&#39;timestamp&#39;)) # Truncate to month and add to select list .values(&#39;month&#39;) # Group By month .annotate(c&#x3D;Count(&#39;id&#39;)) # Select the count of the grouping .values(&#39;month&#39;, &#39;c&#39;) # (might be redundant, haven&#39;t tested) select month and count 上面的日期归档就是按照这个模式搬出来的 7. 侧边栏筛选功能 显示分类做好之后，点击文章标签、分类、日期归档统计的链接后，显示该条件下的所有文章列表 博客园url设计案例 123https://www.cnblogs.com/jason/tag/Python/ 标签https://www.cnblogs.com/jason/category/850028.html 分类https://www.cnblogs.com/jason/archive/2016/10.html 日期 规律：前面的还是站点名，后面是每个分类后的url 按照这个模式设计我们的url 个人站点文章是我们筛选后该站点用户所有的文章，这些标签，分类都是在在上面筛选过后加条件在筛选一次 设计url，处理该url视图函数进一步过滤符合条件的文章 为了显示在一个页面，就在站点的视图里面进行筛选，这样就不要开辟页面 按照上面的url设计在每个分类的后面还有参数，点击不同的文章分类后面出现不同的url，利用每个文章分类的主键值为文章列表 123# url(r'^(?P&lt;username&gt;\\w+)/category/(\\d+)/',views.site),# url(r'^(?P&lt;username&gt;\\w+)/tag/(\\d+)/',views.site),# url(r'^(?P&lt;username&gt;\\w+)/archive/(\\w+)/',views.site), 前面是匹配站点的名称，后面跟不同的分类，最后匹配主键值 三句和成一句 1url(r'^(?P&lt;username&gt;\\w+)/(?P&lt;condition&gt;category|tag|archive/)(?P&lt;param&gt;.*)/',views.site), 后端业务逻辑 12345678910111213141516171819202122232425262728293031def site(request,username,**kwargs): # 先校验当前用户名的站点是否存在 user_obj = models.UserInfo.objects.filter(username=username).first() # 不存在404页面 if not user_obj: return render(request,'error.html') # 先到个人站点 blog = user_obj.blog # 查询当前个人站点下所有的文章 article_list = models.Article.objects.filter(blog=blog) if kwargs: # print(kwargs) # &#123;'condition': 'tag', 'param': '1'&#125; condition = kwargs.get('condition') param = kwargs.get('param') # 判断用户到底想按照哪个条件筛选数据 if condition == 'category': article_list = article_list.filter(category_id=param) elif condition == 'tag': article_list = article_list.filter(tags__id=param) else: year, month = param.split('-') article_list = article_list.filter(create_time__year=year, create_time__month=month) # 1.查询当前用户所有分类及分类下的文章数 category_list = models.Category.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list('name','count_num','pk') # 2.查询当前用户所有标签及标签的文章数 tag_list = models.Tag.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list('name','count_num','pk') # 3.按照日期归档 date_list = models.Article.objects.filter(blog=blog).annotate(month=TruncMonth('create_time')).values('month').annotate(count_num=Count('pk')).values_list('month','count_num') return render(request,'site.html',locals()) 解析：**kwargs可能接收额外的参数，先写上去，判断kwargs是否有值，有值再进行操作，``` {‘condition’: ‘tag’, ‘param’: ‘1’}我们点击标签，后面出现我们url设计好的tag，1是标签1的主键值，拿到之后，判断用户像按照哪个条件筛选的，article_list = article_list.filter(tags__id=param)`这个在宅筛选当前站点用户所有的文章之后在进行一次条件筛选 前端 123456789101112131415 &lt;!-- 标签 --&gt;&#123;% for tag in tag_list %&#125; &lt;p&gt;&lt;a href=\"/&#123;&#123; username &#125;&#125;/tag/&#123;&#123; tag.pk &#125;&#125;/\"&gt;&#123;&#123; tag.name &#125;&#125;(&#123;&#123;tag.c&#125;&#125;)&lt;/a&gt;&lt;/p&gt;&#123;% endfor %&#125; &lt;!-- 分类 --&gt;&#123;% for category in category_list %&#125; &lt;p&gt;&lt;a href=\"/&#123;&#123;username&#125;&#125;/category/&#123;&#123; category.pk &#125;&#125;\"&gt;&#123;&#123; category.name &#125;&#125;(&#123;&#123;category.c&#125;&#125;)&lt;/a&gt;&lt;/p&gt;&#123;% endfor %&#125; &lt;!-- 归档 --&gt;&#123;% for archive in archive_list %&#125; &lt;p&gt;&lt;a href=\"/&#123;&#123; username &#125;&#125;/archive/&#123;&#123; archive.month|date:'Y-m' &#125;&#125;/\"&gt;&#123;&#123; archive.month|date:'Y年m月' &#125;&#125;(&#123;&#123; archive.c &#125;&#125;)&lt;/a&gt;&lt;/p&gt;&#123;% endfor %&#125; //category/把这些url补全，这里的主键值，我们在获取文章查询当前用户所有分类及分类的时候写上去，这样我们就可以在前端拿到主键值values_list(&#39;name&#39;,&#39;count_num&#39;,&#39;pk&#39;) 8. inclusion_tag的制作我们制作完站点页面之后制作文章详情页，我们可以在站点详情页上面显示文章，但是在一个页面上显示，显示的代码在后端特别的冗余，我们从新开辟一个文章详情页 我们建立文章详情页之后，左侧的侧边栏就不会显示，因为我们需要站点的一些数据 该侧边栏在许多页面显示。 直接拷贝代码冗余 将侧边栏制作成inclusion_tag 在应用下创建一个名字必须叫templatetags文件夹 在该文件夹内创建一个任意名字的py文件 在该py文件内固定先写两汉代码 12from django import templateregister = template.Library() 后端封装代码 1234567891011121314151617181920212223from django import templatefrom django.db.models import Countfrom django.db.models.functions import TruncMonthfrom app01 import modelsregister = template.Library()# 自定义inclusion_tag@register.inclusion_tag('left_meun.html')def left_meun(username): user_obj = models.UserInfo.objects.filter(username=username).first() # 1.查询当前用户所有分类及分类下的文章数 blog = user_obj.blog category_list = models.Category.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list( 'name', 'count_num', 'pk') # 2.查询当前用户所有标签及标签的文章数 tag_list = models.Tag.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list('name', 'count_num', # 3.按照日期归档 date_list = models.Article.objects.filter(blog=blog).annotate(month=TruncMonth('create_time')).values( 'month').annotate(count_num=Count('pk')).values_list('month', 'count_num') return locals() 前端建立一个letf_meun.html把左侧边栏的代码放在这里 123&lt;div class=\"panel panel-success\"&gt;...&lt;/div&gt;&lt;div class=\"panel panel-primary\"&gt;...&lt;/div&gt;&lt;div class=\"panel panel-danger\"&gt;... &lt;/div&gt; 在需要侧边栏的地方写如在base.py 12&#123;% load mytag %&#125;&#123;% left_meun username %&#125; 这样在每个页面需要左侧边栏的地方都可以显示了。这样就可以避免大量的冗余代码，也可以少些 8 根评论子评论 允许根评论和子评论（评论评论的评论），可以评论自己的文章。 用户未登录不能评论且隐藏评论输入框(request.user.is_authenticated)。 评论内容有两种渲染方式： 刷新页面时，从后端取出评论数据，前端循环展示 评论后DOM操作临时将评论内容渲染到评论列表，使用的是js的模版字符串语法。 根评论朝后端提交的数据：文章主键、评论内容、 子评论朝后端提交的数据：文章主键、评论内容、父评论主键 获取父评论的方式：给回复按钮绑定一个自定义属性，属性值为父评论主键 区分子评论和根评论关键在于是否有父评论，这里面为了统一，提交根评论时也携带父评论（只不过值为null，因为数据库该字段支持为空）。 后端 需要登录后才能评论，所以使用一个登录校验装饰器 后端逻辑比较简单，接收评论内容、文章主键、父评论主键 评论内容为空值，响应提示信息 使用事物同时更新文章表和评论表。 代码主要都在前端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//设置一个全局的parentId字段let parentId =null// 用户发表评论按钮发送ajax请求$('#id_submit').click(function () &#123; //先拿到用户评论的内容 let conTent = $('#id_comment').val(); //因为子评论存的时候不应该有@人名，所以我们要手动去除@username if (parentId)&#123; let indexNum = conTent.indexOf('\\n') + 1;//找到\\n对应的索引。然后切片，但是骨头不顾尾要+1 conTent = conTent.slice(indexNum)//将indexNum之前的所有数据清楚，只保留后面的部分 &#125; $.ajax(&#123; url:'/comment/', type:'post', data: &#123; 'article_id':'&#123;&#123; article_obj.pk &#125;&#125;', 'content':conTent, // 如果parentId没有值，就是null，后面数据库可以为null没任何问题 'parent_id':parentId, 'csrfmiddlewaretoken':'&#123;&#123; csrf_token &#125;&#125;', &#125;, success:function (args) &#123; if (args.code==1000) &#123; $('#error').text(args.msg) //评论框里面的内容清空 $('id_comment').val(''); //临时渲染 let userName='&#123;&#123; request.user.username &#125;&#125;'; let temp = ` &lt;li class=\"list-group-item\"&gt; &lt;span&gt;$&#123;userName&#125;&lt;/span&gt; &lt;span&gt;&lt;a href=\"#\" class=\"pull-right\"&gt;回复&lt;/a&gt;&lt;/span&gt; &lt;div&gt; $&#123;conTent&#125; &lt;/div&gt; &lt;/li&gt; ` //添加到ul里面 $('.list-group').append(temp) //清空全局的parentId parentId = null; &#125; &#125; &#125;)&#125;)// 给回复按钮绑定点击事件$('.reply').click(function () &#123; //需要评论对应的评论人姓名，还需要评论的主键值 //获取用户名和主键值，自定义属性 let commentUsername = $(this).attr('username'); //直接修改全局 parentId =$(this).attr('comment_id'); //拼接信息塞给评论框 $('#id_comment').val('@'+ commentUsername + '\\n').focus()&#125;) 解析步骤： 用户放松ajax请求 拿到用户评论内容 临时渲染评论框，但是只显示一个人的名字 这个时候把临时渲染的评论框加到ul里面，根评论完成 子评论给回复按钮绑定点击事件 这个时候我们要拿到对应的评论人的用户名，还有评论的id主键值 如何获取用户名和主键值，给他们自定义属性 &lt;span&gt;&lt;a class=&quot;pull-right reply&quot; username=&quot;&quot; comment_id=&quot;&quot;&gt;回复&lt;/a&gt;&lt;/span&gt; 拼接信息给评论框 发送信息如何发送呢，设置一个全局的子评论字段，子评论的内容直接修改全局 但是我们发送的时候parentId没有值，就是null，正好数据库的parent_id字段可以为null没有任何问题 评论时存储的有@用户名，所以我们要手动去除@username 找到\\n，因为我们在拼接信息的时候\\n前面就是@username用户名，我们截取到\\n，切片固头不顾尾+1let indexNum = conTent.indexOf(&#39;\\n&#39;) + 1 将indexNum之前的所有数据清除，保留后面的部分 这个时候我们在写根评论的时候还有子评论的主键值，要清除全局的parentId 后端 1234567891011121314151617181920212223# 开启事务操作两种表from django.db import transactiondef comment(request): # 自己也能评论 if request.is_ajax(): if request.method == 'POST': back_dic = &#123;'code': 1000, 'msg': ''&#125; if request.user.is_authenticated: article_id = request.POST.get('article_id') content = request.POST.get('content') parent_id = request.POST.get('parent_id') # 直接操作评论表存数据，两张表 with transaction.atomic(): models.Article. objects.filter(pk=article_id).update(comment_num=F('comment_num') + 1) models.Comment.objects.create(parent_id=parent_id,user=request.user, article_id=article_id, content=content) back_dic['msg'] = '评论成功' else: back_dic['code'] = 10001 back_dic['msg'] = '用户未登录' return JsonResponse(back_dic) 我们需要操作多张表的时候可以开启事务 因为子评论可以为空，直接接收，可以省很多事情 9 beautifulsuop4 编辑别的博客复制在富文本编辑器，会有html页面代码，截取文本内容代码一起截取 xss攻击，如在里面使用script代码写内容，保存不显示 筛选标签去除html代码 12345678910111213141516content = request.POST.get('content')soup = BeautifulSoup(content, 'html.parser') // 把要筛选的内容放进去tags = soup.find_all() // 找到所有标签for tag in tags: if tag.name == 'script': // 找到script标签 tag.decompose() // 删除标签desc = soup.text[0:150] // 截取文章描述article_obj = models.Article.objects.create( title=title, content=str(soup), desc=desc, category_id=category_id, blog=request.user.blog) 10 富文本编辑器遗留问题 在上传图片会出现下载问题 403：forbidden 自定义富文本编辑器 前端 123添加参数：uploadJson:'/路径/'自定义参数：extraFileUploadParams : &#123;&#125;添加： csrfmiddlewaretoken:'&#123;&#123; csrf_token &#125;&#125;' 后端： 获取上传的图片文件的键 拼接上传路径 返回media开放的资源路径 1234567891011121314151617import osfrom bbs import settingsdef upload_img(request): back_dic = &#123;'error':0,'url':''&#125; if request.method == 'POST': file_obj = request.FILES.get('imgFile')//这里不知道键是多少，用request.FILES打印看一下 # 手动拼接 file_path = os.path.join(settings.BASE_DIR,'media','article_img') if not os.path.isdir(file_path): os.mkdir(file_path) file_img = os.path.join(file_path,file_obj.name) with open(file_img,'wb') as f: for i in file_obj: f.write(i) back_dic['url'] = '/media/article_img/%s'%file_obj.name return JsonResponse(back_dic) 获取键，手动拼接路径，判断是否存在文件夹，不存在创建 用with open保存文件 开放资源路径 11 修改头像问题修改头像出现了csrf-403-forbidden问题 1234567891011121314151617181920212223$('#id_set_avatar').click(function () &#123; let formDataObj = new FormData(); // 将普通数据和文件添加到该对象中 formDataObj.append('avatar', $('#myfile')[0].files[0]); formDataObJ.append('csrfmiddelwaretoken':'&#123;&#123;csrf_token&#125;&#125;') $.ajax(&#123; url: '&#123;% url 'set_avatar' %&#125;', type: 'post', data:formDataObj, contentType: false, // 必须的 processData: false, // 必须的 success: function (args) &#123; if (args.code===1000)&#123; window.location.href = args.url &#125; &#125;, &#125;)&#125;) 这个是正确的书写,我在加中间件的csrf的时候 12345678910111213141516171819$('#id_set_avatar').click(function () &#123; let formDataObj = new FormData(); // 将普通数据和文件添加到该对象中 $.ajax(&#123; url: '&#123;% url 'set_avatar' %&#125;', type: 'post', data:&#123;'avatar', $('#myfile')[0].files[0], 'csrfmiddelwaretoken':'&#123;&#123;csrf_token&#125;&#125;'&#125;// 因为他的数据本身就是一个对象，这样写对象套对象访问不到这个数据 contentType: false, // 必须的 processData: false, // 必须的 success: function (args) &#123; if (args.code===1000)&#123; window.location.href = args.url &#125; &#125;, &#125;)&#125;)","tags":[]},{"title":"中间件笔记","date":"2020-07-05T12:37:55.673Z","path":"2020/07/05/中间件笔记/","text":"中间件中间件是django 的门户，所有的请求和响应都要通过中间件 django中自带的有7个中间件， django中间件的介绍在django settings里面的MIDDLEWARE_CLASSES 123456789MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 我们简单的看一下里面几个的源码 123456789101112131415161718192021222324class SessionMiddleware(MiddlewareMixin): def process_request(self, request): session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME) request.session = self.SessionStore(session_key) def process_response(self, request, response): return responseclass CsrfViewMiddleware(MiddlewareMixin): def process_request(self, request): csrf_token = self._get_token(request) if csrf_token is not None: # Use same token next time. request.META['CSRF_COOKIE'] = csrf_token def process_view(self, request, callback, callback_args, callback_kwargs): return self._accept(request) def process_response(self, request, response): return response 我们从这两个中间件的源码可以看出，他们都有process_request和process_response两个方法，所以这个是我们需要掌握的方法，另外的三个是需要了解的process_view,process_template_response,process_exception 自定义中间件在一个项目或者应用名下常见一个任意的文件夹，在文件夹内常见任意名称的py文件，在该py文件内需要书写类（类要结成MiddlewareMixin）在这个里面书写自定义的五个方法，然后将类的路径已字符串的形式注册到配置文件中才能生效 首先我们在项目app01里面创建一个mymiddel文件夹，在里面创建py文件，然后自定义我们的中间件，最后注册到settings里面 12345678910111213141516171819202122232425262728293031323334353637383940414243from django.utils.deprecation import MiddlewareMixinclass MyMiddelware1(MiddlewareMixin): def process_request(self, request): print('这是我的第1个中间间里面的process_reuqest') def process_response(self, request, response): print('这是我的第1个中间件里面的process_response方法') return response def process_view(self,request,*args,**kwargs): print(args,kwargs) print('这是我的第1个中间件里面的process_view方法') def prcoess_template_response(self,request,response): print('这是我的第1个中间件里面的prcoess_template_response方法') return response def process_exception(self,request,exception): print('这是我的第1个中间件里面的process_exception方法') print(exception)class MyMiddelware2(MiddlewareMixin): def process_request(self, request): print('这是我的第2个中间间里面的process_request') def process_response(self, request, response): print('这是我的第2个中间件里面的process_response方法') return response def process_view(self, request, *args, **kwargs): print(args, kwargs) print('这是我的第2个中间件里面的process_view方法') def prcoess_template_response(self, request, response): print('这是我的第2个中间件里面的prcoess_template_response方法') return response def process_exception(self, request, exception): print('这是我的第2个中间件里面的process_exception方法') print(exception) view视图 123def index(request): print('index视图函数') return HttpResponse('这是index的内容') 答案： 123456789这是我的第1个中间间里面的process_reuqest这是我的第2个中间间里面的process_request(&lt;function index at 0x000001571ED49AE8&gt;, (), &#123;&#125;) &#123;&#125;这是我的第1个中间件里面的process_view方法(&lt;function index at 0x000001571ED49AE8&gt;, (), &#123;&#125;) &#123;&#125;这是我的第2个中间件里面的process_view方法index视图函数这是我的第2个中间件里面的process_response方法这是我的第1个中间件里面的process_response方法 process_request 从这里我们可以看出我们在输入url 请求的时候，都需要经过每一个中间件里面的process_request方法，他们的执行顺序是按照注册中间件的自上而下执行 没有中间件里面定义该方法，直接跳过执行下一个 如果在该方法中返回一个HttpResponse对象，请求将不再继续执行，原路返回，证明校验失败，不允许访问（截胡） process_request方法是用来做全局相关功能的 process_response 响应走的时候需要每一个中间件里面的方法process_response ，里面的参数·response 就是django后端返回给浏览器的内容，默认返回的是形参response，也可以返回自己的 没有中间件里面定义该方法，直接跳过执行下一个 而且它返回的方式像FIFO的形式，先进先出 process_view(了解) (&lt;function index at 0x000001571ED49AE8&gt;, (), {}) {} 路由匹配成功之后执行视图函数之前，会自动执行中间件里面的该放法 顺序是按照配置文件中注册的中间件从上往下的顺序依次执行 prcoess_template_response(了解) 返回的HttpResponse对象有render属性的时候才会触发 顺序是按照配置文件中注册了的中间件从下往上依次经过 process_exception 当视图函数中出现异常的情况下触发 顺序是按照配置文件中注册了的中间件从下往上依次经过","tags":[]},{"title":"魔法方法","date":"2019-08-06T16:00:00.000Z","path":"2019/08/07/## 魔法方法/","text":"魔法方法1.__init__类在实例化的时候会触发它的执行 2.__str__打印对象的时候会触发 123456789101112class A: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return self.namea = A('张三', 24)print(a) 其实打印a 这个对象的时候，调用的就是a.__str__这个方法，先找自己类里面有没有__str__这个方法，没有就到object去找，object里面的__str__一旦被调用，返回的就是这个方法的内存地址 3.__repr__ 123456789101112131415class A: def __init__(self, name, age): self.name = name self.age = age # def __str__(self): # return self.name def __repr__(self): return self.namea = A('张三', 24)print(a)print(str(a))print(repr(a)) __repr__ 是__str__的备胎，当你注释掉__str__，他就会启用__repr__,但是当你注释掉__repr__ print(repr(a))打印的是object里面repr 的内存地址 4.__call__ 12345678910class A: def __init__(self,name): self.name =name def __call__(self): for k in self.__dict__: print(k,self.__dict__[k])a = A('aax')a()a = A('aax')() a()对象加一个括号就是调用__call__ 5.item系列 123456789101112131415161718192021222324class Foo: def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex def __getitem__(self, item): if hasattr(self,item): return self.__dict__[item] def __setitem__(self, key, value): self.__dict__[key] = value def __delitem__(self, key): del self.__dict__[key]f = Foo('zz', '38', '男')print(f['name'])f['hobby'] = 'base'print(f.hobby,f['hobby'])print(f.__dict__)del f['hobby'] # 自己实现的def f.name # object 原生支持的 __delattr__print(f.__dict__) 以前我们查找属性 只能f.name并不能像字典那样f[‘name’],我们可以用item自定义我们自己的 6 __new__构造方法，创建一个对象 123456789101112131415161718class A: def __init__(self): self.x &#x3D; 1 print(&#39;in init function&#39;) def __new__(cls, *args, **kwargs): print(&#39;in new function&#39;) return object.__new__(A, *args, **kwargs)a &#x3D; A()print(a.x)in new functionin init function1 new创建self，在我们执行new的时候还没有self，所以new只能默认传类，这个时候__new__也没有self，借助object.new(A, args, *kwargs)创建一个新的对象，return给init self。 (new就是一个新的裸体的人，init就是穿了衣服的人) 7 __eq__ 123456789101112131415class A: def __init__(self,x,y): self.x=x self.y = y def __eq__(self, other): if self.x + self.y == other.x + other.y: return True else: return Falsea = A(1,2)b = A(99,33)print(a == b)False 正常的情况是比较内存地址，我们重新定制这个eq方法会用我们定制的 8.__getattr__和__setattr__ 1234567891011121314151617class A: def __init__(self, name): self.name = name def __setattr__(self, key, value): if type(value) is str: self.__dict__[key] = value else: print('必须是字符串') def __getattr__(self, item): return self[item]a = A('123')a.name = 121print(a.name) __getattr__和__setattr__是 .拦截方法,不能用a[‘name’] ,对象.属性会调用setattr，当我们赋值的时候如果不是字符串它返回的是信息是必须是字符串，当我们用a.name修改属性值的时候如果不是字符串，返回的也是必须是字符串，当我们打印的时候就是123 9 上下文管理 123456789101112131415class A: def __enter__(self): print('我在管理的时候会触发') return 'xx' def __exit__(self, exc_type, exc_val, exc_tb): print('我用完了') print('1',exc_type) print('2',exc_val) print('3',exc_tb)with A() as f:# 触发类__enter__ print(f)# 当管理完了，会触发__exit__","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]}]