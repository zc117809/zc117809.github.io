[{"title":"django-csrf 跨站请求伪造","date":"2020-07-09T14:00:21.116Z","path":"2020/07/09/django-csrf 跨站请求伪造/","text":"csrf 跨站请求伪造简介CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性 可以这样来理解： 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户 csrf 攻击原理crsf应用form表单里应用 1234567&lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;p&gt;username:&lt;input type=\"text\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;target_user:&lt;input type=\"text\" name=\"target_user\"&gt;&lt;/p&gt; &lt;p&gt;money:&lt;input type=\"text\" name=\"money\"&gt;&lt;/p&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 在ajax应用 1234567# ajax如何符合校验// 第一种 利用标签查找获取页面上的随机字符串&#123;#data:&#123;\"username\":'jason','csrfmiddlewaretoken':$('[name=csrfmiddlewaretoken]').val()&#125;,#&#125;// 第二种 利用模版语法提供的快捷书写&#123;#data:&#123;\"username\":'jason','csrfmiddlewaretoken':'&#123;&#123; csrf_token &#125;&#125;'&#125;,#&#125;// 第三种 通用方式直接拷贝js代码并应用到自己的html页面上即可data:&#123;\"username\":'jason'&#125; 第三种方式的js代码 123456789101112131415161718192021222324252627282930function getCookie(name) &#123; var cookieValue = null; if (document.cookie &amp;&amp; document.cookie !== '') &#123; var cookies = document.cookie.split(';'); for (var i = 0; i &lt; cookies.length; i++) &#123; var cookie = jQuery.trim(cookies[i]); // Does this cookie string begin with the name we want? if (cookie.substring(0, name.length + 1) === (name + '=')) &#123; cookieValue = decodeURIComponent(cookie.substring(name.length + 1)); break; &#125; &#125; &#125; return cookieValue;&#125;var csrftoken = getCookie('csrftoken');function csrfSafeMethod(method) &#123; // these HTTP methods do not require CSRF protection return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));&#125;$.ajaxSetup(&#123; beforeSend: function (xhr, settings) &#123; if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) &#123; xhr.setRequestHeader(\"X-CSRFToken\", csrftoken); &#125; &#125;&#125;); csrf 相关装饰器全站禁用：注释掉中间件 ‘django.middleware.csrf.CsrfViewMiddleware’, FBV使用 123456789101112from django.views.decorators.csrf import csrf_exempt,csrf_protect# 不注释csrf，让整体通过csrf，（忽视校验）# @csrf_exempt# 注释掉csrf，整体不校验，这个函数需要校验（需要校验）# @csrf_protectdef index(request): if request.method == 'POST': username = request.POST.get('username') target_user = request.POST.get('target_user') money = request.POST.get('money') print(f'&#123;username&#125; 向&#123;target_user&#125; 转了&#123;money&#125;元') return render(request,'index.html') CBV使用 12345678910111213from django.views.decorators.csrf import csrf_protect,csrf_exemptfrom django.utils.decorators import method_decorator# 注释掉csrf# @method_decorator(csrf_protect,name='post') # 针对csrf_protect第二种 可以需要校验class MyCsrf(View): @method_decorator(csrf_protect)# 针对csrf_protect第三种 可以需要校验 def dispatch(self, request, *args, **kwargs): return super(MyCsrf,self).dispatch(request,*args,**kwargs) def get(self,request): return HttpResponse('get') # @method_decorator(csrf_protect) # 针对csrf_protect第一种 可以需要校验 def post(self,request): return HttpResponse('post') 1234567891011121314# 不注释csrf#@method_decorator(csrf_exempt,name='post')# 第二种针对csrf_exempt,想忽略全局校验 还是需要校验class MyCsrf(View): # @method_decorator(csrf_exempt) # 第三种针对csrf_exempt,想忽略全局校验 可以不需要 def dispatch(self, request, *args, **kwargs): return super(MyCsrf,self).dispatch(request,*args,**kwargs) def get(self,request): return HttpResponse('get') # @method_decorator(csrf_exempt) # 第一种针对csrf_exempt,想忽略全局校验 还是需要校验 def post(self,request): return HttpResponse('post') 针对不注释掉csrf的，第三种可以忽略校验，但是一和二不行，还是需要校验","tags":[]},{"title":"前端之CSS","date":"2020-07-09T14:00:04.208Z","path":"2020/07/09/前端之CSS/","text":"前端之CSSCSS是层叠样式表，就是给html标签添加样式，让其更美观 CSS的注释 123456789/*单行注释*//*多行注释1多行注释2多行注释3*/# 通常我们在写css样式的时候也会用注释来划定样式区域(因为HTML代码多所以对呀的css代码也会很多) CSS语法结构 123456选择器 &#123; 属性1:值1; 属性2:值2; 属性3:值3; 属性4:值4;&#125; CSS的三种引入方式 style标签直接书写css代码 12345&lt;style&gt; h1&#123; color: burlywood; &#125;&lt;/style&gt; link标签引入外部css文件，正规 1&lt;link rel=\"stylesheet\" href=\"mycss.css\"&gt; 行内式，直接html标签内书写样式，一般不推荐 1&lt;h1 style=\"color: green\"&gt;老板好 要上课吗?&lt;/h1&gt; CSS选择器所谓选择器，就是确定标签位置的方法 基本选择器123456789&lt;body&gt; &lt;div id=\"d1\" class=\"c1 c2\"&gt;div &lt;p&gt;div里面的p&lt;/p&gt; &lt;span&gt;div里面的span&lt;/span&gt; &lt;/div&gt; &lt;p id=\"d2\" class=\"c1 c2\"&gt;ppp&lt;/p&gt; &lt;span id=\"d3\" class=\"c2\"&gt;span111&lt;/span&gt; &lt;span id=\"d4\" class=\"c3\"&gt;span222&lt;/span&gt;&lt;/body&gt; id选择器，根据id值确定一个标签 123#id_name&#123; /*找到id是d1的标签 将文本颜色变成红色*/ color:red;&#125; class选择器，根据class值确定一类标签 123.class_name&#123; /* 找到class值里面包含c1的标签*/ color:red;&#125; 元素/标签选择器，根据标签名确定一堆span标签 123span&#123;/*找到所有的span标签*/ color:red;&#125; 通用选择器，选择所有标签 123*&#123;/*将html页面上所有的标签全部找到*/ color:red;&#125; 组合选择器12345678910111213141516&lt;body&gt; &lt;span&gt;span1&lt;/span&gt; &lt;span&gt;span2&lt;/span&gt; &lt;div&gt;div &lt;p&gt;div p&lt;/p&gt; &lt;p&gt;div p &lt;span&gt;div p span&lt;/span&gt; &lt;/p&gt; &lt;span&gt;span&lt;/span&gt; &lt;span&gt;span&lt;/span&gt; &lt;/div&gt; &lt;span&gt;span&lt;/span&gt; &lt;span&gt;span&lt;/span&gt; &lt;p&gt;ppp&lt;/p&gt; &lt;span&gt;span&lt;/span&gt;&lt;/body&gt; 12345678910111213141516\"\"\"在前端 我们将标签的嵌套用亲戚关系来表述层级 &lt;div&gt;div &lt;p&gt;div p&lt;/p&gt; &lt;p&gt;div p &lt;span&gt;div p span&lt;/span&gt; &lt;/p&gt; &lt;span&gt;span&lt;/span&gt; &lt;span&gt;span&lt;/span&gt; &lt;/div&gt; div里面的p span都是div的后代 p是div的儿子 p里面的span是p的儿子 是div的孙子 div是p的父亲 ...\"\"\" 后代选择器，空格隔开，选择div 里面的所有span 123div span&#123; color:red;&#125; 儿子选择器，&gt;连接，选择内部第一层的所有span 123div&gt;span&#123; color:red;&#125; 毗邻选择器，+连接，选择div同级别的紧挨着的下面一个span，隔着一个都不行 123div+span&#123; /*同级别紧挨着的下面的第一个*/ color:red;&#125; 弟弟选择器，~连接，选择同级别下面所有的span 123div~span&#123;/*同级别下面所有的span*/ color:red;&#125; 属性选择器属性选择器，以[]作为标志。 12345678&lt;body&gt; &lt;input type=\"text\" username&gt; &lt;input type=\"text\" username=\"jason\"&gt; &lt;input type=\"text\" username=\"kevin\"&gt; &lt;p username=\"tank\"&gt;水箱老师&lt;/p&gt; &lt;div username=\"egon\"&gt;矮子老师&lt;/div&gt; &lt;span username=\"jason\"&gt;jason老师 &lt;/span&gt;&lt;/body&gt; 含有某个属性的标签 123[username]&#123; /*将所有含有属性名是username的标签背景色改为红色*/ color:red;&#125; 含有某个属性且有某个值的标签，选择属性名为 123[username='jason']&#123; /*找到所有属性名是username并且属性值是jason的标签*/ color:red;&#125; 含有某个属性且有某个值的某个标签 123input[username='jason']&#123;/*找到所有属性名是username并且属性值是jason的input标签*/ color:red;&#125;","tags":[]},{"title":"django-cookie 和session","date":"2020-07-09T13:57:51.174Z","path":"2020/07/09/django-cookie 和session/","text":"cookie 和sessionHTTP协议是无状态的，这意味这所有的客户端或者浏览器朝服务端发请求，服务端是不会记住客户端是谁，没办法保存用户的登录信息。 随之WEB的发展，出现了网上商城之类购物网站，这类网站的一个需求是记住当前用户是谁，并且需要记住用户的登录状态（避免每次请求页面都重新登录）。 为了解决这个需求，出现了很多总解决办法。其中最有效的一个办法是：当用户第一次登录成功后，将用户的登录信息（用户名和密码）返回给用户的浏览器，让浏览器将登录信息保存在本地浏览器(cookie)；之后用户再次访问该网站时，浏览器会携带之前保存的该网站的登录信息，这样服务端获取登录信息之后自动登录验证。 但是这种方式存在很大的安全隐患：容易泄露用户的登录信息；后来又出现了优化的解决办法。 新的解决办法是：当用户初次登录成功后，服务端会产生一个随机字符串，该字符串保存在服务端(session)，保存成键值对的形式。同时将该字符串交由客户端浏览器保存。之后再访问服务端的时候，浏览器都会带着这个随机字符串，服务端去数据库中匹配是否又这个随机字符串对应的用户信息；匹配成功则自动登录。 其实，如果截获到该随机字符串，那么就可以冒充当前用户，其实还是有安全隐患的。所以应了那句话：在web领域没有绝对的安全也没有绝对的不安全。 这就是cookie和session的出现历程。 cookie：服务端保存在客户端浏览器上的信息，它的表现形式一般都是k:v键值对(可以有多个)。cookie就是保存在客户端浏览器上的信息 session：数据是保存在服务端的并且它的表现形式一般也是k:v键值对(可以有多个)。session就是保存在服务端上的信息 session是基于cookie工作的(其实大部分的保存用户状态的操作都需要使用到cookie)。 12345678 tokensession虽然数据是保存在服务端的 但是禁不住数据量大 服务端不再保存数据 登陆成功之后 将一段用户信息进行加密处理(加密算法之后你公司开发知道) 将加密之后的结果拼接在信息后面 整体返回给浏览器保存 浏览器下次访问的时候带着该信息 服务端自动切去前面一段信息再次使用自己的加密算法 跟浏览器尾部的密文进行比对 cookiecookie基本操作虽然cookie是服务端告诉客户端浏览器需要保存内容，但是客户端浏览器可以选择拒绝保存；如果将浏览器设置为禁止保存服务端的cookie，那么只要是需要记录用户状态的网站登陆功能都无法使用了。 视图函数的返回有三种形式，HttpResponse ，render , redirect 三种形式 其实本质上内部返回的都是HttpResponse 对象，我们可以直接返回也是先将对象用一个变量保存下来在返回 123456789101112131415方式一return HttpResponse()return render()return direct()方式2obj1 = HttpResponse()return obj1 obj2 = render()return obj2 obj3 = redirect()return obj3 我们感觉用这样的方式就是多此一举，但是这种方式可以使用在cookie上面，利用返回对象的方式来设置cookie 设置cookie 1obj.set_cookie(key,value) 获取cookie 12request.COOKIES[key]request.COOKIES.get(key) 设置cookie超时时间 12345obj.set_cookie(key,value,max_age=3)obj.set_cookie(key,value,expires=3)\"\"\"这两个都是设置超时时间的，都是秒为单位，expires是针对IE浏览器的\"\"\" 删除cookie 1obj.delete_cookie(key) # 删除用户浏览器上之前设置的usercookie值 cookie版本的登录思路：# 我们完成一个真正的登陆功能，校验用户是否登陆的装饰器，用户如果在没有登陆的情下想访问一个需要登陆的页面，那么先跳转到登陆页面 当用户输入正确的用户名和密码之后 登录认证装饰器 12345678910def login_auth(func): def inner(request,*args,**kwargs): # print(request.path_info) # print(request.get_full_path()) # 能够获取到用户上一次想要访问的url target_url &#x3D; request.get_full_path() if request.COOKIES.get(&#39;username&#39;): return func(request,*args,**kwargs) else: return redirect(&#39;&#x2F;login&#x2F;?next&#x3D;%s&#39;%target_url) return inner view视图 123456789101112131415161718192021222324252627282930313233def login(request): if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') if username == 'jason' and password == '123': # 获取用户上一次想要访问的url target_url = request.GET.get('next') # 这个结果可能是None if target_url: obj = redirect(target_url) else: # 保存用户登陆状态 obj = redirect('/home/') # 让浏览器记录cookie数据 obj.set_cookie('username', 'jason666') \"\"\" 浏览器不单单会帮你存 而且后面每次访问你的时候还会带着它过来 \"\"\" # 跳转到一个需要用户登陆之后才能看的页面 return obj return render(request,'login.html')@login_authdef home(request): # 获取cookie信息 判断你有没有 # if request.COOKIES.get('username') == 'jason666': # return HttpResponse(\"我是home页面，只有登陆的用户才能进来哟~\") # # 没有登陆应该跳转到登陆页面 # return redirect('/login/') return HttpResponse(\"我是home页面，只有登陆的用户才能进来哟~\") cookie 其他操作1234567891011121314151617181920 # 获取cookierequest.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)参数： default: 默认值 salt: 加密盐 max_age: 后台控制过期时间 # 设置cookierep.set_signed_cookie(key, value, salt='加密盐', max_age=None, ...)参数： key, 键 value='', 值 max_age=None, 过期时间 expires=None, 过期时间(IE requires expires, so set it if hasn't been already.) path='/', Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问 domain=None, Cookie生效的域名 secure=False, 是否https传输 httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） sessionCookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取。因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是Session。 问题来了，基于HTTP协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的Cookie就起到桥接的作用。 我们可以给每个客户端的Cookie分配一个唯一的id，这样用户在访问时，通过Cookie，服务器就知道来的人是“谁”。然后我们再根据不同的Cookie的id，在服务器上保存一段时间的私密资料，如“账号密码”等等。 总结而言：Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在Session里保存私密的信息以及超过4096字节的文本。 另外，上述所说的Cookie和Session其实是共通性的东西，不限于语言和框架。 session 的基本操作django种的session是通过request对象下的session完成的，它类似与一个字典，操作方式和字典也是差不多的 session数据是保存在服务端的(存？)，给客户端返回的是一个随机字符串sessionid:随机字符串 在默认情况下操作session的时候需要django默认的一张django_session表 django默认session的过期时间是14天，可以认为修改它。 session是保存在服务端的，但是session的保存位置可以有多种选择：数据库、文件等等 django_session表中的数据条数是取决于浏览器的，同一个计算机上(IP地址)同一个浏览器只会有一条数据生效。主要是为了节省服务端数据库资源。 设置session 1request.session['key']=value 获取session 1request.session.get('key') 设置过期时间 123456request.session.set_expiry() 括号内可以放四种类型的参数 1.整数 多少秒 2.日期对象 到指定日期就失效 3.0 一旦当前浏览器窗口关闭立刻失效 4.不写 失效时间就取决于django内部全局session默认的失效时间 *清除session * 12345request.session.delete() # 只删服务端的 客户端的不删request.session.flush() # 浏览器和服务端都清空(推荐使用) 这用于确保前面的会话数据不可以再次被用户的浏览器访问 session内部的那些事设置session request.session[‘is_login’] = ‘yes’ 12341. django内部会自动帮你生成一个随机字符串2. django内部自动将随机字符串和对应的数据存储到django_session表中, 先在内存中产生操作数据的缓存,在响应结果django中间件的时候才真正的操作数据库3. 将产生的随机字符串返回给客户端浏览器保存 request.session.get(‘is_login’) 12341.自动从浏览器请求中获取sessionid对应的随机字符串2.拿着该随机字符串去django_session表中查找对应的数据 3. 如果比对上了 则将对应的数据取出并以字典的形式封装到request.session中 如果比对不上 则request.session.get()返回的是None session实现登录认证登录装饰器 1234567891011121314from functools import wrapsfrom django.shortcuts import redirect def login_auth(func): @wraps(func) def inner(request, *args, **kwargs): target_url = request.get_full_path() # 获取用户想要访问的url if request.session.get('login_auth_key') res = func(request, *args, **kwargs) return res else: return redirect(f'/login/?next=&#123;target_url&#125;') # 设置登录后跳转的页面url return inner 视图函数：views.py 1234567891011121314151617from utils.login_auth import login_auth def login(request): if request.method == 'POST': if login_success:# 伪代码 target_url = request.GET.get('next') or 'index' # 登录前要访问的页面或者直接到index request.session['login_auth_key'] = 'is_login' return redirect(target_url) return render(request, 'login.html', locals()) @login_authdef logout(request): request.session.flush() return redirect('login') django中的session设置12345678910111213141516171819202122232425262728 1. 数据库SessionSESSION_ENGINE = 'django.contrib.sessions.backends.db' # 引擎（默认） 2. 缓存SessionSESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 引擎SESSION_CACHE_ALIAS = 'default' # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置 3. 文件SessionSESSION_ENGINE = 'django.contrib.sessions.backends.file' # 引擎SESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() 4. 缓存+数据库SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db' # 引擎 5. 加密Cookie SessionSESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies' # 引擎 其他公用设置项：SESSION_COOKIE_NAME ＝ \"sessionid\" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）SESSION_COOKIE_PATH ＝ \"/\" # Session的cookie保存的路径（默认）SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认）SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认）SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认）SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）（默认）SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认）SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认） CBV如何添加装饰器12345678910111213141516171819from django.views import Viewfrom django.utils.decorators import method_decorator\"\"\"CBV中django不建议你直接给类的方法加装饰器无论该装饰器能都正常给你 都不建议直接加\"\"\"# @method_decorator(login_auth,name='get') # 方式2(可以添加多个针对不同的方法加不同的装饰器)# @method_decorator(login_auth,name='post')class MyLogin(View): @method_decorator(login_auth) # 方式3:它会直接作用于当前类里面的所有的方法 def dispatch(self, request, *args, **kwargs): return super().dispatch(request,*args,**kwargs) # @method_decorator(login_auth) # 方式1:指名道姓 def get(self,request): return HttpResponse(\"get请求\") def post(self,request): return HttpResponse('post请求')","tags":[]},{"title":"mysql-存储引擎","date":"2020-07-09T13:56:43.073Z","path":"2020/07/09/mysql-存储引擎/","text":"存储引擎针对不同的文件格式会有不同的存储方式和处理机制，针对不同的数据应该有对应不同的处理机制来存储 mysql主要的存储引擎 innodb 这个是mysql5.5版本之后默认的存储引擎，存储数据更加的安全 myisam 这个是mysql5.5版本之前默认的存储引擎，速度比innodb更快，但是数据不安全 memory 内存引擎，数据全部放在内存中，断电数据丢失 blackhole 无论存什么，都会立刻消失 12345678910111213# 查看所有引擎show engines;# 不同的存储引擎在存储表的时候的异同点create table t1(id int) engine=innodb;create table t2(id int) engine=myisam;create table t3(id int) engine=memory;create table t4(id int) engine=blackhole;# 存数据insert into t1 values(1);insert into t2 values(1);insert into t3 values(1);insert into t4 values(1);查看表发现t1 and t2有东西，但是只要mysql重新启动，t3就是空，t4会即刻释放 创建表的完整语法 1234567# 语法create table 表名( 字段名1 类型(宽度) 约束条件 字段名2 类型(宽度) 约束条件 字段名3 类型(宽度) 约束条件 字段名4 类型(宽度) 约束条件) 强调 在同一张表中字段名字不能重复 宽度和约束条件是可选的，约束条件支持多个 类型(宽度) 约束条件1 约束条件2；```1234567891011 &#96;&#96;&#96; create table t5(id); &#96;&#96;&#96;报错* 最后一行不能有逗号 &#96;&#96;&#96; python create table t6( id int, name char ) 补充说明 宽度：一般情况下指对存储数据的限制 123create table t7(name char); 默认宽度是1insert into t7 values('json');insert into t7 values(null);null是关键字 针对不同的版本是出现不同的效果 5.6版本默认没有开启严格模式，规定只能存放一个字符，多出的字符自动截取 5.7版本以上是开启了严格模式，规定存放的个数，多出自动报错 严格模式： mysql5.7之后的版本是默认开启的严格模式，使用数据库的标准就是：能尽量少的让数据库敢活就尽量少，不给数据库增加额外的压力。 约束条件：null not null不能插入rull table t8(id int,name char not null)```1234567891011121314151617181920212223242526272829303132333435363738394041* **宽度和约束条件的关系**：宽度是限制数据的存储，约束条件是在宽度的基础上增加额外的约束## 基本数据类型### 整型* **分类**： TINYINT SMALLINT MEDUIMINT INT BIGINT* **作用**： 存一些年龄，等级 id，号码等等例子：**TINYINT** 是否有符号，默认的是带符号的，超出限制存最大可接受值&#96;&#96;&#96; pythoncreate table t9(id tinyint);insert into t9 values(-129),(256);# 约束条件unsigned 无符号create table t10(id tinyint unsigned);create table t11(id int);# int 默认也是带符号的，整型默认情况下的欧式带有符号的# 针对整型 括号内的宽度有限create table t12(id int(8));insert into t12 values(123456789)&quot;&quot;&quot;特例:只有整型括号里面的数字不是表示限制位数id int(8) 如果数字没有超出8位 那么默认用空格填充至8位 如果数字超出了8位 那么有几位就存几位(但是还是要遵守最大范围)&quot;&quot;&quot;create table t13(id int(8) unsigned zerofill);# 针对整型字段括号内无需指定宽度，默认的宽度足够显示所有数据 严格模式 123456789101112131415# 如何查看严格模式show variables like \"%mode\";模糊匹配/查询 关键字 like %:匹配任意多个字符 _:匹配任意单个字符# 修改严格模式 set session 只在当前窗口有效 set global 全局有效 set global sql_mode = 'STRICT_TRANS_TABLES'; 修改完之后 重新进入服务端即可 浮点型 char(4) 数据超过4个字符直接报错，不厚的字符空格补全 varchar(4) 数据超过4个字符直接报错，不够截取 12345678910create table t18(name char(4));create table t19(name varchar(4));insert into t18 values('a');insert into t19 values('a');# 统计char_length字段长度select char_length(name) from t18;# char硬盘里存放的是真正的数据，带有空格的，但是在mysql显示会自动将多余的空格剔除# 再次修改sql_mode 让MySQL不要做自动剔除操作set global sql_mode='STRICT_TRABLES,PAD_CHAR_TO_FULL_LENGTH' char和varchar对比： 12345678char 缺点：浪费空间 优点：直接按照固定的字符存取数据 json egon alex wusir tank 存按照五个字符存，取也是五个字符取 varchar 优点：节省空间 缺点：存取比较麻烦 存的时候需要制作报头，取也需要报头，最后才能取到真实的数据， 时间类型 分类：data： 年月日2015-2-03 ​ datatime：年月日时分秒 ​ time：时分秒 ​ Year:2020 123456789create table student( id int, name varchar(6), born_year year, birth data, study_time time, reg_time datatime);insert into student values(1,'zc','1990','1999-11-11','11:11:11','2020-11-11 11:11:11'); 枚举与集合 分类：枚举（多选一） ​ 集合（多选多） 具体用法 1234567891011121314151617181920create table user( id int, name char(16), gender enum('male','female'));insert into user values(1,'zc','male')# 枚举后期存数据的时候只能从里面悬着一个存储create table teacher( id int, name char(6), gender enum('male','female'), hobby set('read','play','running'))；insert into teacher values(1,'zc','male','read');insert into teacher values(2,'zcc','female','read,running');insert into teacher values(2,'zcz','male','eat');# 集合可以写一个或选择多个，但是不能写里面没有的","tags":[]},{"title":"django-批量插入","date":"2020-07-09T13:56:30.866Z","path":"2020/07/09/django-批量插入/","text":"批量插入12345678910111213141516171819def ab_pl(request): # 先给Book插入一万条数据 # for i in range(10000): # models.Book.objects.create(title='第%s本书'%i) # # 再将所有的数据查询并展示到前端页面 book_queryset = models.Book.objects.all() # 批量插入 # book_list = [] # for i in range(100000): # book_obj = models.Book(title='第%s本书'%i) # book_list.append(book_obj) models.Book.objects.bulk_create(book_list) \"\"\" 当你想要批量插入数据的时候 使用orm给你提供的bulk_create能够大大的减少操作时间 :param request: :return: \"\"\" return render(request,'ab_pl.html',locals())","tags":[]},{"title":"由django中间件引发的编程思想","date":"2020-07-09T13:56:26.963Z","path":"2020/07/09/由django中间件引发的编程思想/","text":"由django中间件引发的编程思想创建一个文件夹，把一个个功能写成一个个py文件,假如我们写一个消息通知，让qq， 微信，邮箱都能接收到，qq， 微信，邮箱就是一个个功能 aapp02文件夹下的qq.py 12345class Qq(object): def __init__(self): pass def send(self,content): print(f'QQ通知：&#123;content&#125;') aapp02文件夹下的wechat.py 12345class Wechat(object): def __init__(self): pass def send(self,content): print(f'微信通知：&#123;content&#125;') aapp02文件夹下的email.py 12345class Email(object): def __init__(self): pass def send(self,content): print(f'邮件通知：&#123;content&#125;') aapp02文件夹下的__init__.py 12345678910import settingsimport importlibdef send_all(content): for path_str in settings.APP02_LIST: module_path ,class_name = path_str.rsplit('.',maxsplit=1) module = importlib.import_module((module_path)) #1 利用字符串导入模块 cls = getattr(module,class_name) # 2 利用反射获取类名 obj =cls() # 3 生成类的对象 obj.send(content) # 4 利用鸭子类型直接调用send方法 settings.py: 123456APP02_LIST = [ 'aapp02.email.Email', 'aapp02.qq.Qq', 'aapp02.wechat.Wechat',] start.py 12import aapp02aapp02.send_all('下课了') 当我们添加或者删除一个功能的时候，只需要在seetings里面添加或注释掉就可以了.","tags":[]},{"title":"bbs","date":"2020-07-05T12:43:05.741Z","path":"2020/07/05/bbs/","text":"js只要用到内置对象，直接用new生成就可以了 1. 用户注册上传头像123456789101112131415161718192021222324&lt;div class=\"form-group\"&gt; &lt;label for=\"myfile\"&gt;头像 &#123;% load static %&#125; &lt;img id=\"myimg\" src=\"&#123;% static 'img/default.png' %&#125;\" alt=\"\" width=\"80\" style=\"margin-left: 20px\"&gt;&lt;/label&gt; &lt;input type=\"file\" id=\"myfile\" name=\"avater\" style=\"display: none\"&gt;&lt;/div&gt;&lt;script&gt; //文本域变化事件 $('#myfile').change(function () &#123; //文件阅读器对象 //1.先生成一个文件阅读器对象 let myFileReadObj = new FileReader(); // 文件阅读器 //2. 获取用户上传的头像文件 let fileObj = $(this)[0].files[0]; //获取文件 // 3.将文件对象交给文件阅读器读取 myFileReadObj.readAsDataURL(fileObj) //异步操作，io操作，这行代码文件还没有读完，就已经开始执行下一句代码，在前端不显示 //4.利用文件阅读器将文件展示到页面去 修改src属性 //等待文件阅读器加载完之后，在执行 myFileReadObj.onload = function()&#123; $('#myimg').attr('src',myFileReadObj.result)&#125; &#125;) 这里我们要用到文本与变化事件，利用文件阅读器对象，我们要先生成一个文件阅读器对象， 获取用户上传的头像文件读取出来 将文件对象交给文件阅读器读取出来文件 利用文件阅读器将文件展示到页面上去，就要修改src属性，myFileReadObj.readAsDataURL(fileObj)和$(&#39;#myimg&#39;).attr(&#39;src&#39;,myFileReadObj.result)这两部是一个异步操作，如果你在执上一代码的同时文件还没有读取出来，同时他还在执行下一句代码，这样会造成你上传之后在前端是不显示你上传的头像，空白区，我们要等文件加载完毕在执行下一局，myFileReadObj.onload 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 $('#id_commit').click(function () &#123; // 发送ajax请求 我们发送的数据中即包含普通的键值也包含文件 let formDataObj = new FormData(); // 1.添加普通的键值对 &#123;#console.log($('#myform').serializeArray()) // [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;] 只包含普通键值对#&#125; $.each($('#myform').serializeArray(),function (index,obj) &#123; &#123;#console.log(index,obj)#&#125; // obj = &#123;&#125; formDataObj.append(obj.name,obj.value) &#125;); // 2.添加文件数据 formDataObj.append('avatar',$('#myfile')[0].files[0]); // 3.发送ajax请求 $.ajax(&#123; url:\"\", type:'post', data:formDataObj, // 需要指定两个关键性的参数 contentType:false, processData:false, success:function (args) &#123; if (args.code==1000)&#123; // 跳转到登陆页面 window.location.href = args.url &#125;els // 如何将对应的错误提示展示到对应的input框下面 // forms组件渲染的标签的id值都是 id_字段名 $.each(args.msg,function (index,obj) &#123; &#123;#console.log(index,obj) // username [\"用户名不能为空\"]#&#125; let targetId = '#id_' + index; $(targetId).next().text(obj[0]).parent().addClass('has-error') &#125;) &#125; &#125; &#125;) &#125;)def register(request): # 产生一个空对象 register_form = myforms.MyRegForm() if request.method == 'POST': back_dic = &#123;'code':'', 'msg': ''&#125; # 校验数据是否合法 register_form = myforms.MyRegForm(request.POST) # 判断数据是否合法 if register_form.is_valid(): clean_data = register_form.cleaned_data # 将校验通过的数据字典赋值给一个变量 # 将字典里面吗的confirm_password键值对删除 clean_data.pop('confirm_password') # 用户头像 file_obj = request.FILES.get('avatar') \"\"\" 针对用户头像一定要判断是否传之，不能直接添加到字典里面去 \"\"\" if file_obj: clean_data['avatar'] = file_obj # 直接操作数据库保存到字典里面 models.UserInfo.objects.create_user(**clean_data) # 将键值对**打散传到数据库 # 判断正确跳转到登录页面 back_dic['url'] = '/login/' else: back_dic['code'] = 2000 back_dic['msg'] = register_form.errors return JsonResponse(back_dic) return render(request, 'register.html', locals()) 前端： 头像的功能完成之后，剩下的就是将利用ajax将文件发送到后端，前端要先利用内置对象获取数据，添加不同键值对，我们可以利用serializeArray()拿到他所有的键值对，利用each循环拿到每一个对象的键值对 利用append添加文件数据，发送ajax请求，这里面我们要指定两个关键参数contentType: false,processData: false, 如果后端保存数据成功，就跳转到后端写好传过来的指定页面，如果校验数据失败就在input框下面展现出对应的错误 当我们看见错误的信息之后，如果把鼠标放上去，指定的错误就会消失，给所有的input框绑定获取焦点事件，将input下面的span标签和input外面的div标签修改内容和属性 后端 校验数据输入的是否合法，将合法的数据赋值给一个变量，赋值给一个变量方便我们删除确认密码的键值对，因为我们在写models的时候没有这个字段，针对用户头像一定要判断是否传之，不能直接添加到字典里面去，在models里面我们给他默认了一个头像 操作数据库保存数据，定义字典将信息返回给ajax，ajax都到在页面展示对应的页面信息 存取问题： 1234class RegisterForm(forms.Form): data = register_form.cleaned_data models.UserInfo.objects.create_user(**data) 这里我们在前端像后端存的时候出现了问题，原因是models里面的username和password必须和form表单里面的字段名一致，因为我们去表单里面验证的时候用的是form表单里面的字段名去数据库里面存，**data的时候字段名这个和数据库里面的字段名不一样 2. 生成登录验证码如何生成一个验证码，然后点击它就可以刷新呢。 利用pip3 install pillow ，这个是图片相关的模块。 导入模块：from PIL import Image, ImageDraw, ImageFont Image 生成图片 ImageDraw 能够在图片上添加东西 ImageFont 控制字体的样式 推导1： 直接获取后端生成的图片二进制数据发送给前端 123with open(r'static/img/111.jpg','rb') as f: data = f.read()return HttpResponse(data) 推导2 利用pillow模块动态产生图片 12345678910img_obj = Image.new('RGB',(430,35),'green')img_obj = Image.new('RGB',(430,35),get_random())# 将图片对象 保存起来with open('xxx.png','wb') as f: img_obj.save(f,'png')# 再将文件对象读取出来with open('xxx.png','rb') as f: data = f.read()return HttpResponse(data) 推导3我们可以看到利用文件存储繁琐而且IO操作效率低，我们可以借助内存管理模块 12345from io import BytesIO,StringIOimg_obj = Image.new('RGB', (430, 35), get_random())io_obj = BytesIO()img_obj.save(io_obj,'png') # 生成一个内存管理器对象return HttpResponse(io_obj.getvalue()) # 从内存管理器中读取二进制的图片数据返回给前端 推导4 写成图片验证码 123img_obj = Image.new('RGB', (430, 35), get_random())img_draw = ImageDraw.Draw(img_obj) # 产生一个画笔对象img_font = ImageFont.truetype('static/font/222.ttf',30) # 字体样式 大小 最终成型 1234567891011121314151617181920import randomdef get_random(): return random.randint(0,255),random.randint(0,255),random.randint(0,255)def get_code(request): img_obj = Image.new('RGB', (430, 35), get_random()) # 注意：这里的430，35要和前端的一致 img_draw = ImageDraw.Draw(img_obj) img_font = ImageFont.truetype('static/font/222.ttf',30) code = '' for i in range(5): random_upper = chr(random.randint(65,90)) random_lower = chr(random.randint(97,122)) random_int = str(random.randint(0,9)) tmp = random.choice([random_lower,random_upper,random_int]) img_draw.text((i*60+60,-2),tmp,get_random(),img_font) code += tmp print(code) request.session['code'] = code io_obj = BytesIO() img_obj.save(io_obj,'png') return HttpResponse(io_obj.getvalue()) 实现低级验证码图片刷新验证码，这样设置后每次点击图片相当于超后端发送一次get请求获取一个新的验证码图片 1234&#123;# 点击验证码图片刷新验证码 #&#125;$('#code_img').click(function () &#123; $(this).attr('src', '&#123;% url \"get_code\" %&#125;?') // src='/get_code/?'url后面加?的操作&#125;); 3. admin的使用以前写图书的展示列表，我们给它添加增删改查的功能，特别的麻烦，现在有很多张表的展示，我们不可能慢慢的写这些功能，django给我们提供了admin后台管理，我们可以利用admin实现增删改查，添加数据。 首先要创建超级用户，只有超级用户才能够操作admin的这些功能。 刚开始登录进去的时候只用一张用户表，我们想要添加其他的表，必须添加注册 1234567891011from django.contrib import adminfrom app01 import models# Register your models here.adminadmin.site.register(models.UserInfo)admin.site.register(models.Blog)admin.site.register(models.Article)admin.site.register(models.Atricle2Tag)admin.site.register(models.UpAndDown)admin.site.register(models.Category)admin.site.register(models.Tag)admin.site.register(models.Comment) 这样我们就可以使用这些表，但是他们是英文的，我们可以在model.py里面改变他们的名字 12class Meta: verbose_name_plural='用户表' 我们进去操作添加添加一条数据显示的是对象， 1234class UserInfo(AbstractUser): ...def __str__(self): return self.username 避免造成不便语义不明，打印出来 在model里面的字段添加verbose_name=&#39;创建时间&#39;会在admin后天帮助我们把字段的名称改成中文 4. 制作站点打开博客园，在博客园的url后面输入别人的站点名称就可以进到他们的站点，如https://home.cnblogs.com/the3times在后面输入`the3times`就会进到这个人的博客园的主页，这个是url来配置的，利用url`re`匹配规则就可以实现 1url(r'^(?P&lt;username&gt;\\w+)/$',views.site,name='site'), 5. media的配置网站用户使用的静态文件默认放在static里面，用户上传的静态文件应该单独放在一个文件夹下，可以使用media配置，该配置可以让用户上传的所有的文件 固定存放在指定的文件夹下 settings.py 12# 配置用户上传的文件MEDIA_ROOT = os.path.jion(BASE_DIR,'media') 我们配置后，我们上传文件会自动生成media文件，比如我们注册上传的头像会到这个地方，你存的路径在数据库中也不会改变， 假如你在model.py里面存的路径是avatar/111.pngmedia里面就会多出一个存放头像的avatar/111.png这个就是你存放的头像路径。 12class UserInfo(AbstractUser): avatar = models.FileField(upload_to='avatar/', default='avatar/default.png', verbose_name='用户头像') 在前端点击这个头像能够查看到这个头像，需要我们在后端开设一个指定的文件夹资源 在url.py配置参数 1234from django.views.static import servefrom bbs import settingsurl(r'^media/(?P&lt;path&gt;.*)',serve,&#123;'document_root':settings.MEDIA_ROOT&#125;), 如果你还想暴漏更多资源，在settings修改文件夹名，想暴露源码也可以，问题就大了 最后在html配置,渲染后的路径/media/avatar/default.png/ 1&lt;img class=\"media-object\" src=\"/media/&#123;&#123; article_obj.blog.userinfo.avatar &#125;&#125;\" alt=\"...\" width=\"40\"&gt; 这样就可以看到别人的头像 6. 站点左边栏展示左侧边栏展示如何展示的，要清楚orm的查询 123456 # 1.查询当前用户所有分类及分类下的文章数category_list=models.Category.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list('name','count_num','pk') # 2.查询当前用户所有标签及标签的文章数tag_list=models.Tag.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list('name','count_num','pk') # &lt;QuerySet [('tank的标签一', 1), ('tank的标签二', 1), ('tank的标签三', 2)]&gt;# 3.按照日期归档date_list=models.Article.objects.filter(blog=blog).annotate(month=TruncMonth('create_time')).values('month').annotate(count_num=Count('pk')).values_list('month','count_num') 这里的日期归档我们按照年月归档，但是数据库里面有年月日，我们如何把日去掉官方提供了一个方法 123456from django.db.models.functions import TruncMonth Sales.objects .annotate(month&#x3D;TruncMonth(&#39;timestamp&#39;)) # Truncate to month and add to select list .values(&#39;month&#39;) # Group By month .annotate(c&#x3D;Count(&#39;id&#39;)) # Select the count of the grouping .values(&#39;month&#39;, &#39;c&#39;) # (might be redundant, haven&#39;t tested) select month and count 上面的日期归档就是按照这个模式搬出来的 7. 侧边栏筛选功能 显示分类做好之后，点击文章标签、分类、日期归档统计的链接后，显示该条件下的所有文章列表 博客园url设计案例 123https://www.cnblogs.com/jason/tag/Python/ 标签https://www.cnblogs.com/jason/category/850028.html 分类https://www.cnblogs.com/jason/archive/2016/10.html 日期 规律：前面的还是站点名，后面是每个分类后的url 按照这个模式设计我们的url 个人站点文章是我们筛选后该站点用户所有的文章，这些标签，分类都是在在上面筛选过后加条件在筛选一次 设计url，处理该url视图函数进一步过滤符合条件的文章 为了显示在一个页面，就在站点的视图里面进行筛选，这样就不要开辟页面 按照上面的url设计在每个分类的后面还有参数，点击不同的文章分类后面出现不同的url，利用每个文章分类的主键值为文章列表 123# url(r'^(?P&lt;username&gt;\\w+)/category/(\\d+)/',views.site),# url(r'^(?P&lt;username&gt;\\w+)/tag/(\\d+)/',views.site),# url(r'^(?P&lt;username&gt;\\w+)/archive/(\\w+)/',views.site), 前面是匹配站点的名称，后面跟不同的分类，最后匹配主键值 三句和成一句 1url(r'^(?P&lt;username&gt;\\w+)/(?P&lt;condition&gt;category|tag|archive/)(?P&lt;param&gt;.*)/',views.site), 后端业务逻辑 12345678910111213141516171819202122232425262728293031def site(request,username,**kwargs): # 先校验当前用户名的站点是否存在 user_obj = models.UserInfo.objects.filter(username=username).first() # 不存在404页面 if not user_obj: return render(request,'error.html') # 先到个人站点 blog = user_obj.blog # 查询当前个人站点下所有的文章 article_list = models.Article.objects.filter(blog=blog) if kwargs: # print(kwargs) # &#123;'condition': 'tag', 'param': '1'&#125; condition = kwargs.get('condition') param = kwargs.get('param') # 判断用户到底想按照哪个条件筛选数据 if condition == 'category': article_list = article_list.filter(category_id=param) elif condition == 'tag': article_list = article_list.filter(tags__id=param) else: year, month = param.split('-') article_list = article_list.filter(create_time__year=year, create_time__month=month) # 1.查询当前用户所有分类及分类下的文章数 category_list = models.Category.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list('name','count_num','pk') # 2.查询当前用户所有标签及标签的文章数 tag_list = models.Tag.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list('name','count_num','pk') # 3.按照日期归档 date_list = models.Article.objects.filter(blog=blog).annotate(month=TruncMonth('create_time')).values('month').annotate(count_num=Count('pk')).values_list('month','count_num') return render(request,'site.html',locals()) 解析：**kwargs可能接收额外的参数，先写上去，判断kwargs是否有值，有值再进行操作，``` {‘condition’: ‘tag’, ‘param’: ‘1’}我们点击标签，后面出现我们url设计好的tag，1是标签1的主键值，拿到之后，判断用户像按照哪个条件筛选的，article_list = article_list.filter(tags__id=param)`这个在宅筛选当前站点用户所有的文章之后在进行一次条件筛选 前端 123456789101112131415 &lt;!-- 标签 --&gt;&#123;% for tag in tag_list %&#125; &lt;p&gt;&lt;a href=\"/&#123;&#123; username &#125;&#125;/tag/&#123;&#123; tag.pk &#125;&#125;/\"&gt;&#123;&#123; tag.name &#125;&#125;(&#123;&#123;tag.c&#125;&#125;)&lt;/a&gt;&lt;/p&gt;&#123;% endfor %&#125; &lt;!-- 分类 --&gt;&#123;% for category in category_list %&#125; &lt;p&gt;&lt;a href=\"/&#123;&#123;username&#125;&#125;/category/&#123;&#123; category.pk &#125;&#125;\"&gt;&#123;&#123; category.name &#125;&#125;(&#123;&#123;category.c&#125;&#125;)&lt;/a&gt;&lt;/p&gt;&#123;% endfor %&#125; &lt;!-- 归档 --&gt;&#123;% for archive in archive_list %&#125; &lt;p&gt;&lt;a href=\"/&#123;&#123; username &#125;&#125;/archive/&#123;&#123; archive.month|date:'Y-m' &#125;&#125;/\"&gt;&#123;&#123; archive.month|date:'Y年m月' &#125;&#125;(&#123;&#123; archive.c &#125;&#125;)&lt;/a&gt;&lt;/p&gt;&#123;% endfor %&#125; //category/把这些url补全，这里的主键值，我们在获取文章查询当前用户所有分类及分类的时候写上去，这样我们就可以在前端拿到主键值values_list(&#39;name&#39;,&#39;count_num&#39;,&#39;pk&#39;) 8. inclusion_tag的制作我们制作完站点页面之后制作文章详情页，我们可以在站点详情页上面显示文章，但是在一个页面上显示，显示的代码在后端特别的冗余，我们从新开辟一个文章详情页 我们建立文章详情页之后，左侧的侧边栏就不会显示，因为我们需要站点的一些数据 该侧边栏在许多页面显示。 直接拷贝代码冗余 将侧边栏制作成inclusion_tag 在应用下创建一个名字必须叫templatetags文件夹 在该文件夹内创建一个任意名字的py文件 在该py文件内固定先写两汉代码 12from django import templateregister = template.Library() 后端封装代码 1234567891011121314151617181920212223from django import templatefrom django.db.models import Countfrom django.db.models.functions import TruncMonthfrom app01 import modelsregister = template.Library()# 自定义inclusion_tag@register.inclusion_tag('left_meun.html')def left_meun(username): user_obj = models.UserInfo.objects.filter(username=username).first() # 1.查询当前用户所有分类及分类下的文章数 blog = user_obj.blog category_list = models.Category.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list( 'name', 'count_num', 'pk') # 2.查询当前用户所有标签及标签的文章数 tag_list = models.Tag.objects.filter(blog=blog).annotate(count_num=Count('article__pk')).values_list('name', 'count_num', # 3.按照日期归档 date_list = models.Article.objects.filter(blog=blog).annotate(month=TruncMonth('create_time')).values( 'month').annotate(count_num=Count('pk')).values_list('month', 'count_num') return locals() 前端建立一个letf_meun.html把左侧边栏的代码放在这里 123&lt;div class=\"panel panel-success\"&gt;...&lt;/div&gt;&lt;div class=\"panel panel-primary\"&gt;...&lt;/div&gt;&lt;div class=\"panel panel-danger\"&gt;... &lt;/div&gt; 在需要侧边栏的地方写如在base.py 12&#123;% load mytag %&#125;&#123;% left_meun username %&#125; 这样在每个页面需要左侧边栏的地方都可以显示了。这样就可以避免大量的冗余代码，也可以少些 8 根评论子评论 允许根评论和子评论（评论评论的评论），可以评论自己的文章。 用户未登录不能评论且隐藏评论输入框(request.user.is_authenticated)。 评论内容有两种渲染方式： 刷新页面时，从后端取出评论数据，前端循环展示 评论后DOM操作临时将评论内容渲染到评论列表，使用的是js的模版字符串语法。 根评论朝后端提交的数据：文章主键、评论内容、 子评论朝后端提交的数据：文章主键、评论内容、父评论主键 获取父评论的方式：给回复按钮绑定一个自定义属性，属性值为父评论主键 区分子评论和根评论关键在于是否有父评论，这里面为了统一，提交根评论时也携带父评论（只不过值为null，因为数据库该字段支持为空）。 后端 需要登录后才能评论，所以使用一个登录校验装饰器 后端逻辑比较简单，接收评论内容、文章主键、父评论主键 评论内容为空值，响应提示信息 使用事物同时更新文章表和评论表。 代码主要都在前端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//设置一个全局的parentId字段let parentId =null// 用户发表评论按钮发送ajax请求$('#id_submit').click(function () &#123; //先拿到用户评论的内容 let conTent = $('#id_comment').val(); //因为子评论存的时候不应该有@人名，所以我们要手动去除@username if (parentId)&#123; let indexNum = conTent.indexOf('\\n') + 1;//找到\\n对应的索引。然后切片，但是骨头不顾尾要+1 conTent = conTent.slice(indexNum)//将indexNum之前的所有数据清楚，只保留后面的部分 &#125; $.ajax(&#123; url:'/comment/', type:'post', data: &#123; 'article_id':'&#123;&#123; article_obj.pk &#125;&#125;', 'content':conTent, // 如果parentId没有值，就是null，后面数据库可以为null没任何问题 'parent_id':parentId, 'csrfmiddlewaretoken':'&#123;&#123; csrf_token &#125;&#125;', &#125;, success:function (args) &#123; if (args.code==1000) &#123; $('#error').text(args.msg) //评论框里面的内容清空 $('id_comment').val(''); //临时渲染 let userName='&#123;&#123; request.user.username &#125;&#125;'; let temp = ` &lt;li class=\"list-group-item\"&gt; &lt;span&gt;$&#123;userName&#125;&lt;/span&gt; &lt;span&gt;&lt;a href=\"#\" class=\"pull-right\"&gt;回复&lt;/a&gt;&lt;/span&gt; &lt;div&gt; $&#123;conTent&#125; &lt;/div&gt; &lt;/li&gt; ` //添加到ul里面 $('.list-group').append(temp) //清空全局的parentId parentId = null; &#125; &#125; &#125;)&#125;)// 给回复按钮绑定点击事件$('.reply').click(function () &#123; //需要评论对应的评论人姓名，还需要评论的主键值 //获取用户名和主键值，自定义属性 let commentUsername = $(this).attr('username'); //直接修改全局 parentId =$(this).attr('comment_id'); //拼接信息塞给评论框 $('#id_comment').val('@'+ commentUsername + '\\n').focus()&#125;) 解析步骤： 用户放松ajax请求 拿到用户评论内容 临时渲染评论框，但是只显示一个人的名字 这个时候把临时渲染的评论框加到ul里面，根评论完成 子评论给回复按钮绑定点击事件 这个时候我们要拿到对应的评论人的用户名，还有评论的id主键值 如何获取用户名和主键值，给他们自定义属性 &lt;span&gt;&lt;a class=&quot;pull-right reply&quot; username=&quot;&quot; comment_id=&quot;&quot;&gt;回复&lt;/a&gt;&lt;/span&gt; 拼接信息给评论框 发送信息如何发送呢，设置一个全局的子评论字段，子评论的内容直接修改全局 但是我们发送的时候parentId没有值，就是null，正好数据库的parent_id字段可以为null没有任何问题 评论时存储的有@用户名，所以我们要手动去除@username 找到\\n，因为我们在拼接信息的时候\\n前面就是@username用户名，我们截取到\\n，切片固头不顾尾+1let indexNum = conTent.indexOf(&#39;\\n&#39;) + 1 将indexNum之前的所有数据清除，保留后面的部分 这个时候我们在写根评论的时候还有子评论的主键值，要清除全局的parentId 后端 1234567891011121314151617181920212223# 开启事务操作两种表from django.db import transactiondef comment(request): # 自己也能评论 if request.is_ajax(): if request.method == 'POST': back_dic = &#123;'code': 1000, 'msg': ''&#125; if request.user.is_authenticated: article_id = request.POST.get('article_id') content = request.POST.get('content') parent_id = request.POST.get('parent_id') # 直接操作评论表存数据，两张表 with transaction.atomic(): models.Article. objects.filter(pk=article_id).update(comment_num=F('comment_num') + 1) models.Comment.objects.create(parent_id=parent_id,user=request.user, article_id=article_id, content=content) back_dic['msg'] = '评论成功' else: back_dic['code'] = 10001 back_dic['msg'] = '用户未登录' return JsonResponse(back_dic) 我们需要操作多张表的时候可以开启事务 因为子评论可以为空，直接接收，可以省很多事情 9 beautifulsuop4 编辑别的博客复制在富文本编辑器，会有html页面代码，截取文本内容代码一起截取 xss攻击，如在里面使用script代码写内容，保存不显示 筛选标签去除html代码 12345678910111213141516content = request.POST.get('content')soup = BeautifulSoup(content, 'html.parser') // 把要筛选的内容放进去tags = soup.find_all() // 找到所有标签for tag in tags: if tag.name == 'script': // 找到script标签 tag.decompose() // 删除标签desc = soup.text[0:150] // 截取文章描述article_obj = models.Article.objects.create( title=title, content=str(soup), desc=desc, category_id=category_id, blog=request.user.blog) 10 富文本编辑器遗留问题 在上传图片会出现下载问题 403：forbidden 自定义富文本编辑器 前端 123添加参数：uploadJson:'/路径/'自定义参数：extraFileUploadParams : &#123;&#125;添加： csrfmiddlewaretoken:'&#123;&#123; csrf_token &#125;&#125;' 后端： 获取上传的图片文件的键 拼接上传路径 返回media开放的资源路径 1234567891011121314151617import osfrom bbs import settingsdef upload_img(request): back_dic = &#123;'error':0,'url':''&#125; if request.method == 'POST': file_obj = request.FILES.get('imgFile')//这里不知道键是多少，用request.FILES打印看一下 # 手动拼接 file_path = os.path.join(settings.BASE_DIR,'media','article_img') if not os.path.isdir(file_path): os.mkdir(file_path) file_img = os.path.join(file_path,file_obj.name) with open(file_img,'wb') as f: for i in file_obj: f.write(i) back_dic['url'] = '/media/article_img/%s'%file_obj.name return JsonResponse(back_dic) 获取键，手动拼接路径，判断是否存在文件夹，不存在创建 用with open保存文件 开放资源路径 11 修改头像问题修改头像出现了csrf-403-forbidden问题 1234567891011121314151617181920212223$('#id_set_avatar').click(function () &#123; let formDataObj = new FormData(); // 将普通数据和文件添加到该对象中 formDataObj.append('avatar', $('#myfile')[0].files[0]); formDataObJ.append('csrfmiddelwaretoken':'&#123;&#123;csrf_token&#125;&#125;') $.ajax(&#123; url: '&#123;% url 'set_avatar' %&#125;', type: 'post', data:formDataObj, contentType: false, // 必须的 processData: false, // 必须的 success: function (args) &#123; if (args.code===1000)&#123; window.location.href = args.url &#125; &#125;, &#125;)&#125;) 这个是正确的书写,我在加中间件的csrf的时候 12345678910111213141516171819$('#id_set_avatar').click(function () &#123; let formDataObj = new FormData(); // 将普通数据和文件添加到该对象中 $.ajax(&#123; url: '&#123;% url 'set_avatar' %&#125;', type: 'post', data:&#123;'avatar', $('#myfile')[0].files[0], 'csrfmiddelwaretoken':'&#123;&#123;csrf_token&#125;&#125;'&#125;// 因为他的数据本身就是一个对象，这样写对象套对象访问不到这个数据 contentType: false, // 必须的 processData: false, // 必须的 success: function (args) &#123; if (args.code===1000)&#123; window.location.href = args.url &#125; &#125;, &#125;)&#125;)","tags":[]},{"title":"django-中间件笔记","date":"2020-07-05T12:37:55.673Z","path":"2020/07/05/django-中间件笔记/","text":"中间件中间件是django 的门户，所有的请求和响应都要通过中间件 django中自带的有7个中间件， django中间件的介绍在django settings里面的MIDDLEWARE_CLASSES 123456789MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 我们简单的看一下里面几个的源码 123456789101112131415161718192021222324class SessionMiddleware(MiddlewareMixin): def process_request(self, request): session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME) request.session = self.SessionStore(session_key) def process_response(self, request, response): return responseclass CsrfViewMiddleware(MiddlewareMixin): def process_request(self, request): csrf_token = self._get_token(request) if csrf_token is not None: # Use same token next time. request.META['CSRF_COOKIE'] = csrf_token def process_view(self, request, callback, callback_args, callback_kwargs): return self._accept(request) def process_response(self, request, response): return response 我们从这两个中间件的源码可以看出，他们都有process_request和process_response两个方法，所以这个是我们需要掌握的方法，另外的三个是需要了解的process_view,process_template_response,process_exception 自定义中间件在一个项目或者应用名下常见一个任意的文件夹，在文件夹内常见任意名称的py文件，在该py文件内需要书写类（类要结成MiddlewareMixin）在这个里面书写自定义的五个方法，然后将类的路径已字符串的形式注册到配置文件中才能生效 首先我们在项目app01里面创建一个mymiddel文件夹，在里面创建py文件，然后自定义我们的中间件，最后注册到settings里面 12345678910111213141516171819202122232425262728293031323334353637383940414243from django.utils.deprecation import MiddlewareMixinclass MyMiddelware1(MiddlewareMixin): def process_request(self, request): print('这是我的第1个中间间里面的process_reuqest') def process_response(self, request, response): print('这是我的第1个中间件里面的process_response方法') return response def process_view(self,request,*args,**kwargs): print(args,kwargs) print('这是我的第1个中间件里面的process_view方法') def prcoess_template_response(self,request,response): print('这是我的第1个中间件里面的prcoess_template_response方法') return response def process_exception(self,request,exception): print('这是我的第1个中间件里面的process_exception方法') print(exception)class MyMiddelware2(MiddlewareMixin): def process_request(self, request): print('这是我的第2个中间间里面的process_request') def process_response(self, request, response): print('这是我的第2个中间件里面的process_response方法') return response def process_view(self, request, *args, **kwargs): print(args, kwargs) print('这是我的第2个中间件里面的process_view方法') def prcoess_template_response(self, request, response): print('这是我的第2个中间件里面的prcoess_template_response方法') return response def process_exception(self, request, exception): print('这是我的第2个中间件里面的process_exception方法') print(exception) view视图 123def index(request): print('index视图函数') return HttpResponse('这是index的内容') 答案： 123456789这是我的第1个中间间里面的process_reuqest这是我的第2个中间间里面的process_request(&lt;function index at 0x000001571ED49AE8&gt;, (), &#123;&#125;) &#123;&#125;这是我的第1个中间件里面的process_view方法(&lt;function index at 0x000001571ED49AE8&gt;, (), &#123;&#125;) &#123;&#125;这是我的第2个中间件里面的process_view方法index视图函数这是我的第2个中间件里面的process_response方法这是我的第1个中间件里面的process_response方法 process_request 从这里我们可以看出我们在输入url 请求的时候，都需要经过每一个中间件里面的process_request方法，他们的执行顺序是按照注册中间件的自上而下执行 没有中间件里面定义该方法，直接跳过执行下一个 如果在该方法中返回一个HttpResponse对象，请求将不再继续执行，原路返回，证明校验失败，不允许访问（截胡） process_request方法是用来做全局相关功能的 process_response 响应走的时候需要每一个中间件里面的方法process_response ，里面的参数·response 就是django后端返回给浏览器的内容，默认返回的是形参response，也可以返回自己的 没有中间件里面定义该方法，直接跳过执行下一个 而且它返回的方式像FIFO的形式，先进先出 process_view(了解) (&lt;function index at 0x000001571ED49AE8&gt;, (), {}) {} 路由匹配成功之后执行视图函数之前，会自动执行中间件里面的该放法 顺序是按照配置文件中注册的中间件从上往下的顺序依次执行 prcoess_template_response(了解) 返回的HttpResponse对象有render属性的时候才会触发 顺序是按照配置文件中注册了的中间件从下往上依次经过 process_exception 当视图函数中出现异常的情况下触发 顺序是按照配置文件中注册了的中间件从下往上依次经过","tags":[]},{"title":"基于python面向对象多人聊天室流程","date":"2019-09-08T16:00:00.000Z","path":"2019/09/09/基于python面向对象多人聊天室/","text":"项目环境 项目环境 项目名称：多人聊天室 项目模式：C/S 开发环境：win10+python3.6+pycharm 所需知识：python GUI编程，多线程编程，网络编程，数据库编程 程序设计了解一下服务器扮演的角色，下面是服务器的业务流程。大致是怎样工作的 首先服务器在指定的端口进行监听，等待客户的链接 客户端链接到服务器之后，服务器开启单线程来处理该用户的请求 处理线程等待客户端发送的请求 服务器根据客户端请求类型的不同，调用不同处理的函数 处理完客户端请求之后，再次回到第三步继续等待处理客户端新的请求 客户端退出登录，服务器也会关闭对客户端的处理线程，释放资源 响应协议设计我们都知道三次握手和四次挥手，这里呢我们约定了客户端发送什么样格式的数据给服务器，服务器又需要返回什么样格式的数据给客户端，客户端会有不同的请求，所以我们针对不同的请求个响应定义了需求个相应号，来区分不同的请求和响应 网络上一般使用json和xml格式来传输数据，但是用他们来传输，对于我们的项目有点复杂，我们的项目没有这么复杂的数据，我们采用|进行分割 ，然后拿到数据进行split一下就可以了。 登录响应格式: 1001|ret|nickname|username,其中ret 代表服务器端验证的结果，如果是0,表示服务端验证失败，后面的nickname username 会为空字符串，若是1 ，表示服务端验证成功，nickname 为服务端返回的该用户的昵称，username 是该用户的用户名。 聊天的响应格式：1002|nickname|message, nicakname 是为聊天信息发送者的昵称，message 是发送的聊天信息 下面我们定义了服务端需要的一些常量，以及为了实现客户端和服务端通信定义的一些协议编号，协议编号如下 1234567891011config.py# ----服务器相关配置----SERVER_IP = '127.0.0.1' # 服务器IP地址SERVER_PORT = 8090 # 服务器端口号# ----数据协议相关配置----REQUEST_LOGIN = '0001' # 登录请求REQUEST_CHAT = '0002' # 聊天请求RESPONSE_LOGIN_RESULT = '1001' # 登录结果响应RESPONSE_CHAT = '1002' # 聊天响应DELIMITER = '|' # 自定义协议数据分隔符 面向对象的思想","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"魔法方法","date":"2019-08-06T16:00:00.000Z","path":"2019/08/07/魔法方法/","text":"魔法方法1.__init__类在实例化的时候会触发它的执行 2.__str__打印对象的时候会触发 123456789101112class A: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return self.namea = A('张三', 24)print(a) 其实打印a 这个对象的时候，调用的就是a.__str__这个方法，先找自己类里面有没有__str__这个方法，没有就到object去找，object里面的__str__一旦被调用，返回的就是这个方法的内存地址 3.__repr__ 123456789101112131415class A: def __init__(self, name, age): self.name = name self.age = age # def __str__(self): # return self.name def __repr__(self): return self.namea = A('张三', 24)print(a)print(str(a))print(repr(a)) __repr__ 是__str__的备胎，当你注释掉__str__，他就会启用__repr__,但是当你注释掉__repr__ print(repr(a))打印的是object里面repr 的内存地址 4.__call__ 12345678910class A: def __init__(self,name): self.name =name def __call__(self): for k in self.__dict__: print(k,self.__dict__[k])a = A('aax')a()a = A('aax')() a()对象加一个括号就是调用__call__ 5.item系列 123456789101112131415161718192021222324class Foo: def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex def __getitem__(self, item): if hasattr(self,item): return self.__dict__[item] def __setitem__(self, key, value): self.__dict__[key] = value def __delitem__(self, key): del self.__dict__[key]f = Foo('zz', '38', '男')print(f['name'])f['hobby'] = 'base'print(f.hobby,f['hobby'])print(f.__dict__)del f['hobby'] # 自己实现的def f.name # object 原生支持的 __delattr__print(f.__dict__) 以前我们查找属性 只能f.name并不能像字典那样f[‘name’],我们可以用item自定义我们自己的 6 __new__构造方法，创建一个对象 123456789101112131415161718class A: def __init__(self): self.x &#x3D; 1 print(&#39;in init function&#39;) def __new__(cls, *args, **kwargs): print(&#39;in new function&#39;) return object.__new__(A, *args, **kwargs)a &#x3D; A()print(a.x)in new functionin init function1 new创建self，在我们执行new的时候还没有self，所以new只能默认传类，这个时候__new__也没有self，借助object.new(A, args, *kwargs)创建一个新的对象，return给init self。 (new就是一个新的裸体的人，init就是穿了衣服的人) 7 __eq__ 123456789101112131415class A: def __init__(self,x,y): self.x=x self.y = y def __eq__(self, other): if self.x + self.y == other.x + other.y: return True else: return Falsea = A(1,2)b = A(99,33)print(a == b)False 正常的情况是比较内存地址，我们重新定制这个eq方法会用我们定制的 8.__getattr__和__setattr__ 1234567891011121314151617class A: def __init__(self, name): self.name = name def __setattr__(self, key, value): if type(value) is str: self.__dict__[key] = value else: print('必须是字符串') def __getattr__(self, item): return self[item]a = A('123')a.name = 121print(a.name) __getattr__和__setattr__是 .拦截方法,不能用a[‘name’] ,对象.属性会调用setattr，当我们赋值的时候如果不是字符串它返回的是信息是必须是字符串，当我们用a.name修改属性值的时候如果不是字符串，返回的也是必须是字符串，当我们打印的时候就是123 9 上下文管理 123456789101112131415class A: def __enter__(self): print('我在管理的时候会触发') return 'xx' def __exit__(self, exc_type, exc_val, exc_tb): print('我用完了') print('1',exc_type) print('2',exc_val) print('3',exc_tb)with A() as f:# 触发类__enter__ print(f)# 当管理完了，会触发__exit__","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"git的使用","date":"2019-08-06T16:00:00.000Z","path":"2019/08/07/git的使用/","text":"git的使用git和github 的区别 Git 是一种方法。而 GitHub 只是使用这种方法的一个代码仓库，就是git是操作的，GitHub是个网址 初始化git仓储新建一个项目project，点进目录右击选择git bash 1git init # 初始化仓库，这个git对我们项目的代码进行备份 配置用户名和邮箱 123git config --global user.name \"xiaoming\" # 用户名git config --global user.email \"xx@sina.com\" # 邮箱 把代码存储到 git 仓储中 分两步走： 把代码放到.git隐藏目录的大门(暂存区) 1git add ./readme.md # ./readme.md 文件路径要说明 把门口的代码放入房间里面 1git commit -m \"这是对这次添加东西的说明\" 区域划分： 工作区：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 暂存区：Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master。 查询当前所处的工作状态：git status 12345678910111213141516On branch masternothing to commit, working tree clean# 我们提交完了，当前的工作区是干净的(use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: readme.txt# 把文件放在了暂存区(use \"git add &lt;file&gt;...\" to update what will be committed)(use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: readme.txt# 我们的文件修改了，但是没有放到暂存区(大门口) 如果我们修改了两个文件是不是要add两次命令呢，不需要 1git add ./ # 当前目录只要是修改过的文件都放到暂存区 一次性把我们修改的代码放到房子里面去 1git commit --all -m \"一些说明\" 查看日志 12git log # 查看历史提交的日志git log --oneline # 简洁版的日志 git 版本回退 先用日志功能查看我们修改过的功能，在选择回退的版本 修改过后的版本日志 123456$ git log --oneline489310a (HEAD -&gt; master) 添加了js和一个功能01ebf78 我们完成四个功能20e8c3c 我们完成三个功能bc9c3b5 这次加了一个功能6dad8ac 这是我的开始 12git reset --hard Head~1 # 1 表示退回到上上次代码提交的状态 # 0 表示上一次 退回后的版本 123401ebf78 (HEAD -&gt; master) 我们完成四个功能20e8c3c 我们完成三个功能bc9c3b5 这次加了一个功能6dad8ac 这是我的开始 通过版本号回退查看日志 123456$ git log --oneline489310a (HEAD -&gt; master) 添加了js和一个功能01ebf78 我们完成四个功能 # 01ebf78版本号20e8c3c 我们完成三个功能 # 20e8c3c版本号bc9c3b5 这次加了一个功能6dad8ac 这是我的开始 1git -reset --hard 01ebf78 # 精确的回退到某一次的提交状态 123401ebf78 (HEAD -&gt; master) 我们完成四个功能20e8c3c 我们完成三个功能bc9c3b5 这次加了一个功能6dad8ac 这是我的开始 假如说我们退回之后又后悔之前的操作咋办呢？ 1git -reset --hard 01ebf78 # 精确的回退到某一次的提交状态 但是如果我们把窗口关掉了，记不住版本号，又想回到以前的状态咋办呢 1git reflog # 可以看到每一次切换的版本的记录，可以看到所有提交的版本号 12345601ebf78 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to Head~1489310a HEAD@&#123;1&#125;: commit: 添加了js和一个功能01ebf78 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: 我们完成四个功能20e8c3c HEAD@&#123;3&#125;: commit: 我们完成三个功能bc9c3b5 HEAD@&#123;4&#125;: commit: 这次加了一个功能6dad8ac HEAD@&#123;5&#125;: commit (initial): 这是我的开始 分支管理主分支：默认的是master 创建分支： 1git branch dev # 创建了一个dev分支 创建dev分支里面的东西和master分支的东西是一样的 切换分支： 1git checkout dev # 切换到指定分支 查看分支： 12345678git branch\"\"\"$ git branch dec dev* master # 当前所在分支\"\"\" 合并分支： 1git merge dev # 指定分支的名称 比如我们我们创建分支，在分支里面已经完成了我们的功能五，但是当我们去切换到master的时候我们忘记在分支里面添加了功能五，又在master里完成了功能五，当我们去合并的时候会出现 1234$ git merge devAuto-merging readme.mdCONFLICT (content): Merge conflict in readme.mdAutomatic merge failed; fix conflicts and then commit the result. 合并的时候如果有冲突，需要手动去处理，如何去处理呢，那就是要到你完成的功能里面去选择，处理完后还需要再提交一次。 远程仓库提交代码到GitHub（当作git的服务器） 1git push [地址] master # 拿到远程的代码 首先要建立一个新的仓储 1git push https://github.com/zc117809/test112.git master 克隆 要先建立一个文件，在文件里打开git bash输入 1git clone https://github.com/zc117809/test112.git 多次执行会覆盖本地的内容 ssh 方式上传代码有公钥和私钥，这两个是有关联的 生成公钥和私钥 1ssh -kegen -t rsa -c \"邮箱\" 多人协作小明和小红现在同时写作开发，小红在服务器上pull到小明的数据，pull完之后，小红在html文件上做了一个功能，备份到本地，这个时候小明又更新了版本，小红又去pull这个时候会出现冲突，小红新添加的功能会和小明更新的版本上出现错乱。 总结： 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 解决完之后还要上传到服务器push 当我们push时，加上-u参数，在下一次push时我们只需要写上git push 就能上传我们的代码(加上-u之后，git拉取当前我们分支与远程指定的分支进行关联，git push origin master)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"JWT","date":"2018-01-12T16:00:00.000Z","path":"2018/01/13/9.JWT/","text":"JWT 传统token和jwt认证的区别 基于传统的token认证方式 12用户登录， 服务端给返回token,并将token保存在服务端以后在访问的时候，需要携带token，服务端获取token后，再去数据库获取token校验 JWT 123用户登录，服务端给用户返回一个token（服务端不保存）以后访问的时候，需要携带token，在服务端获取token，在做token的校验优势：相较于传统的token相比，在无需保存在服务端token Jwt实现的过程 jwt的生成token格式如下，即：由 . 连接的三段字符串组成。 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 生成规则 第一段：HEADER部分，固定包含算法和token类型，对此json进行base64url加密，这就是token的第一段。 1234&#123; \"alg\": \"HS256\", \"typ\": \"JWT\"&#125; 第二段: PAYLOAD部分，包含一些数据，对此json进行base64url加密，这就是token的第二段。 123456&#123; \"sub\": \"1234567890\", \"name\": \"John Doe\", \"iat\": 1516239022 ...&#125; 第三段： SIGNATURE部分，把前两段的base密文通过.拼接起来，然后对其进行HS256加密，再然后对hs256密文进行base64url加密，最终得到token的第三段。 123456base64url( HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), your-256-bit-secret (秘钥加盐) )) 最后将三段字符串通过 .拼接起来就生成了jwt的token 注意：base64url加密是先做base64加密，然后再将 - 替代 + 及 _ 替代 / 。 代码实现我们可以先用pyjwt，后面用rest_framework_jwt实现 实现 123456789101112131415161718192021import jwtimport datetimefrom jwt import exceptionsSALT = 'iv%x6xo7l7_u9bf_u!9#g#m*)*=ej@bek5)(@u3kh*72+unjv='def create_token(): # 构造header headers = &#123; 'typ': 'jwt', 'alg': 'HS256' &#125; # 构造payload payload = &#123; 'user_id': 1, # 自定义用户ID 'username': 'wupeiqi', # 自定义用户名 'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=5) # 超时时间 &#125; result = jwt.encode(payload=payload, key=SALT, algorithm=\"HS256\", headers=headers).decode('utf-8') return resultif __name__ == '__main__': token = create_token() print(token) jwt校验token一般在认证成功后，把jwt生成的token返回给用户，以后用户再次访问时候需要携带token，此时jwt需要对token进行超时及合法性校验。 获取token之后，会按照以下步骤进行校验： 将token分割成 header_segment、payload_segment、crypto_segment 三部分 123jwt_token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"signing_input, crypto_segment = jwt_token.rsplit(b'.', 1)header_segment, payload_segment = signing_input.split(b'.', 1) 对第一部分header_segment进行base64url解密，得到header 对第二部分payload_segment进行base64url解密，得到payload 对第三部分crypto_segment进行base64url解密，得到signature 对第三部分signature部分数据进行合法性校验 拼接前两段密文，即：signing_input 从第一段明文中获取加密算法，默认：HS256 使用 算法+盐 对signing_input 进行加密，将得到的结果和signature密文进行比较。 12345678910111213141516171819202122232425import jwtimport datetimefrom jwt import exceptionsdef get_payload(token): \"\"\" 根据token获取payload :param token: :return: \"\"\" try: # 从token中获取payload【不校验合法性】 # unverified_payload = jwt.decode(token, None, False) # print(unverified_payload) # 从token中获取payload【校验合法性】 verified_payload = jwt.decode(token, SALT, True) return verified_payload except exceptions.ExpiredSignatureError: print('token已失效') except jwt.DecodeError: print('token认证失败') except jwt.InvalidTokenError: print('非法的token')if __name__ == '__main__': token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NzM1NTU1NzksInVzZXJuYW1lIjoid3VwZWlxaSIsInVzZXJfaWQiOjF9.xj-7qSts6Yg5Ui55-aUOHJS4KSaeLq5weXMui2IIEJU\" payload = get_payload(token) jwt认证算法：签发和校验 签发 ：根据登录请求提交来的账号，密码，设备信息签发token 123451）用基本信息存储json字典，采用base64算法加密得到 头字符串2）用关键信息存储json字典，采用base64算法加密得到 体字符串3）用头、体加密字符串再加安全码信息存储json字典，采用hash md5算法加密得到 签名字符串账号密码就能根据User表得到user对象，形成的三段字符串用 . 拼接成token返回给前台 校验：根据客户端带来的token的请求，反解出user对象 1231）将token按 . 拆分为三段字符串，第一段 头加密字符串 一般不需要做任何处理2）第二段 体加密字符串，要反解出用户主键，通过主键从User表中就能得到登录用户，过期时间和设备信息都是安全信息，确保token没过期，且时同一设备来的3）再用 第一段 + 第二段 + 服务器安全码 不可逆md5加密，与第三段 签名字符串 进行碰撞校验，通过后才能代表第二段校验得到的user对象就是合法的登录用户 认证的流程开发123451）用账号密码访问登录接口，登录接口逻辑中调用 签发token 算法，得到token，返回给客户端，客户端自己存到cookies中2）校验token的算法应该写在认证类中(在认证类中调用)，全局配置给认证组件，所有视图类请求，都会进行认证校验，所以请求带了token，就会反解出user对象，在视图类中用request.user就能访问登录的用户注：登录接口需要做 认证 + 权限 两个局部禁用 drf jwt安装和使用1234567891011121314pip install djangorestframework-jwt# 1 创建超级用户python3 manage.py createsuperuser# 2 配置路由urls.pyfrom django.urls import pathfrom rest_framework_jwt.views import obtain_jwt_tokenurlpatterns = [ path('login/', obtain_jwt_token),]# 3 postman测试向后端接口发送post请求，携带用户名密码，即可看到生成的token# 4 setting.py中配置认证使用jwt提供的jsonwebtoken# 5 postman发送访问请求（必须带jwt空格） 使用全套的djangorestframework-jwt(内置权限类)12345678910111213141516# urls.pyfrom rest_framework_jwt.views import obtain_jwt_tokenurlpatterns = [ path('login/',obtain_jwt_token), path('order/',views.OrderView.as_view())]# views.pyclass OrderView(GenericAPIView): authentication_classes = [JSONWebTokenAuthentication] permission_classes = [IsAuthenticated] # 加上游客不能访问，不加游客能访问 def get(self, request, *args, **kwargs): return Response('订单信息') 这里的登录视图rest_framework_jwt帮我们在内部做了视图，我们只需要在配置一个登录的路由去调用它就可以了 关于视图里面的函数做认证，我们需要配置一个内置用户访问权限限制，JSONWebTokenAuthentication和IsAuthenticated才是一套的控制登录用户访问， JSONWebTokenAuthentication加这个游客是可以访问的，校验规则：这里里面必须填authenticate，jwt空格传，才解析，如果不传不解析，到request里面没有东西， 控制登录接口返回的数据格式1234561. 自己写登录接口2. 用内置，控制返回的数据格式-jwt的配置信息中有这个属性'JWT_RESPONSE_PAYLOAD_HANDLER':'rest_framework_jwt.utils.jwt_response_payload_handler',-重写jwt_response_payload_handler，配置成咱们自己的 用内置，控制返回的数据格式 1234567891011121314151617181920212223第一步：class OrderView(GenericAPIView): authentication_classes = [JSONWebTokenAuthentication] permission_classes = [IsAuthenticated] def get(self, request, *args, **kwargs): return Response('订单信息')第二步：def jwt_response_payload_handler(token, user=None, request=None): # 返回什么样式，前端就是上面样式 return &#123; 'token': token, 'msg': '登录成功', 'status': 100, 'username': user.username &#125;第三步：在自己的settings配置JWT_AUTH = &#123; 'JWT_RESPONSE_PAYLOAD_HANDLER':'api.utils.ahth.jwt_response_payload_handler'&#125; 自定义权限类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from api.utils.ahth import MyJwtAuthenticationclass OrderView2(GenericAPIView): authentication_classes = [MyJwtAuthentication] # permission_classes = [IsAuthenticated] def get(self, request, *args, **kwargs): print(request.user) print(1111) return Response('商品信息') # 第一种 from rest_framework.authentication import BaseAuthenticationfrom rest_framework_jwt.authentication import BaseJSONWebTokenAuthenticationfrom rest_framework.exceptions import AuthenticationFailedfrom rest_framework_jwt.authentication import jwt_decode_handlerfrom rest_framework_jwt.utils import jwt_decode_handler # 跟上面死一样的 from api.models import Userclass MyJwtAuthentication(BaseAuthentication): def authenticate(self, request): jwt_value=request.META.get('HTTP_AUTHORIZATION') if jwt_value: try: #jwt提供了通过三段token，取出payload的方法，并且有校验功能 payload=jwt_decode_handler(jwt_value) except jwt.ExpiredSignature: raise AuthenticationFailed('签名过期') except jwt.InvalidTokenError: raise AuthenticationFailed('用户非法') except Exception as e: # 所有异常都会走到这 raise AuthenticationFailed(str(e)) # 因为payload就是用户信息的字典 print(payload) # return payload, jwt_value # 需要得到user对象， # 第一种，去数据库查 user=models.User.objects.get(pk=payload.get('user_id')) # 第二种不查库 #user=User(id=payload.get('user_id'),username=payload.get('username'))# 生成对象里面 return user,jwt_value # 没有值，直接抛异常 raise AuthenticationFailed('您没有携带认证信息') # 第2种 class DrfJwtTokenAuth(JSONWebTokenAuthentication): def authenticate(self, request): jwt_value = request.META.get('HTTP_AUTHORIZATION') # 从请求头中取出token值 try: payload = jwt_decode_handler(jwt_value) # 从token值中取出payload（字典） except exceptions.ExpiredSignatureError: # 捕获异常 raise AuthenticationFailed('token已失效') except jwt.DecodeError: raise AuthenticationFailed('token认证失败') except jwt.InvalidTokenError: raise AuthenticationFailed('非法的token') return self.authenticate_credentials(payload), jwt_value # 从payload中取出user对象，内部是查询数据库实现的 # authenticate_credentials是JSONWebTokenAuthentication提供的方法 \"\"\"当认证通过后，需要返回一个包含user对象的二元组，获取这个user对象的方式有两种；第一种是通过payload中的user_id或者username查数据哭获取user对象；第二种是通过用户类实例化一个该user对象【仅仅是一个对象，不是user用户对象】\"\"\" 手动签发token，多方式登录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162vews.pyfrom rest_framework.viewsets import ViewSetfrom api.ser import UserModelSerializerclass LoginView(ViewSet): def login(self,request,*args,**kwargs): login_ser = UserModelSerializer(data=request.data,context=&#123;'request':request&#125;) login_ser.is_valid(raise_exception=True) token = login_ser.context.get('token') username = login_ser.context.get('username') return Response(&#123;'status':100,'msg':\"成功\",'token':token,'username':username&#125;) ser.pyfrom rest_framework import serializersfrom api import modelsfrom rest_framework_jwt.utils import jwt_encode_handlerfrom rest_framework_jwt.utils import jwt_payload_handler # 签发tokenfrom rest_framework.exceptions import ValidationErrorclass UserModelSerializer(serializers.ModelSerializer): username = serializers.CharField() # 这里要去覆盖username。因为他是唯一字段 class Meta: model = models.User fields = ['username', 'password'] def validate(self, attrs): print(self.context) username = attrs.get('username') password = attrs.get('password') # 判断，username 数据不同，查询字段不一样 # 正则匹配手机 import re if re.match('^1[3-9][0-9]&#123;9&#125;$',username): user = models.User.objects.filter(mobile=username).first() elif re.match('^.+@.+$', username): user = models.User.objects.filter(email=username).first() else: user = models.User.objects.filter(username=username).first() if user: # 校验密码 if user.check_password(password): # 签发token payload = jwt_payload_handler(user) token = jwt_encode_handler(payload) self.context['token'] = token self.context['username'] = user.username return attrs else: raise ValidationError('密码错误') else: raise ValidationError('用户不存在')\"\"\"from rest_framework_jwt.utils import jwt_encode_handlerfrom rest_framework_jwt.utils import jwt_payload_handler # 签发token payload = jwt_payload_handler(user) # 把user传入，得到payload token = jwt_encode_handler(payload) 把payload 传进去得到token\"\"\" payload = jwt_payload_handler(user) # 把user传入，得到payload, token = jwt_encode_handler(payload) 把payload 传进去得到token 因为username在user是一个字段，因为我们走的是post，它默认是查数据库保存，我们创建一个useraname字段覆盖，重新覆盖username字段，数据中它是unique，post，认为你保存数据，自己有校验没过 jwt的参数配置123456# jwt的配置import datetimeJWT_AUTH=&#123; 'JWT_RESPONSE_PAYLOAD_HANDLER':'app02.utils.my_jwt_response_payload_handler', 'JWT_EXPIRATION_DELTA': datetime.timedelta(days=7), # 过期时间，手动配置&#125; pyjwt的应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374视图from app01.utils.jwt_token import create_tokenclass ProLoginView(APIView): \"\"\"jwt登录认证\"\"\" def post(self,request,*args,**kwargs): user = request.data.get('username') pwd = request.data.get('password') user_obj = models.UserInfo.objects.filter(username=user,password=pwd).first() if not user_obj: return Response(&#123;'code':1000,'error':'用户名或密码错误'&#125;) token = create_token(&#123;'id':user_obj.id,'name':user_obj.username&#125;) return Response(&#123;'code': 10001, 'data': token&#125;)from app01.exensions.auth import JwtQueryParamsAuthenticationclass ProOrderView(APIView): authentication_classes = [JwtQueryParamsAuthentication] def get(self, request, *args, **kwargs): print(request.user) return Response('订单列表')生成tokenimport jwtimport datetimefrom django.conf import settingsdef create_token(payload,timeout=1): salt = settings.SECRET_KEY headers = &#123; 'typ': 'jwt', 'alg': 'HS256' &#125; # 构造payload payload['exp'] = datetime.datetime.utcnow() + datetime.timedelta(minutes=timeout) # 超时时间 token = jwt.encode(payload=payload, key=salt, algorithm=\"HS256\", headers=headers).decode('utf-8') return token认证tokenfrom rest_framework.authentication import BaseAuthenticationfrom django.conf import settingsfrom jwt import exceptionsfrom rest_framework.response import Responseimport jwtfrom rest_framework.exceptions import AuthenticationFailedclass JwtQueryParamsAuthentication(BaseAuthentication): def authenticate(self, request): token = request.query_params.get('token') salt = settings.SECRET_KEY try: payload = jwt.decode(token, salt, True) except exceptions.ExpiredSignatureError: msg = 'token已失效' raise AuthenticationFailed(&#123;'code':1003,\"msg\":msg&#125;) except jwt.DecodeError: msg = 'token认证失败' raise AuthenticationFailed(&#123;'code': 1003, \"msg\": msg&#125;) except jwt.InvalidTokenError: msg = '非法的token' raise AuthenticationFailed(&#123;'code': 1003, \"msg\": msg&#125;) return (payload, token) # payload就是user, #可以有三种返回值 # 抛出异常，后面的函数就不会执行 # return一个元组（1，2）认证通过，在视图中调用request.user,就是元组的一个值，request.auth时第二个值 # return None 在验证","tags":[{"name":"drf","slug":"drf","permalink":"http://yoursite.com/tags/drf/"}]},{"title":"自动生成文档","date":"2018-01-11T16:00:00.000Z","path":"2018/01/12/8.drf-自动生成接口文档/","text":"REST framework可以自动帮助我们生成接口文档。 接口文档以网页的方式呈现。 自动接口文档能生成的是继承自APIView及其子类的视图。 1.1. 安装依赖REST framewrok生成接口文档需要coreapi库的支持。 1pip install coreapi 1.2. 设置接口文档访问路径在总路由中添加接口文档路径。 文档路由对应的视图配置为rest_framework.documentation.include_docs_urls， 参数title为接口文档网站的标题。 123456from rest_framework.documentation import include_docs_urlsurlpatterns = [ ... path('docs/', include_docs_urls(title='站点页面标题'))] 1.3. 文档描述说明的定义位置1） 单一方法的视图，可直接使用类视图的文档字符串，如 1234class BookListView(generics.ListAPIView): \"\"\" 返回所有图书信息. \"\"\" 2）包含多个方法的视图，在类视图的文档字符串中，分开方法定义，如 12345678class BookListCreateView(generics.ListCreateAPIView): \"\"\" get: 返回所有图书信息. post: 新建图书. \"\"\" 3）对于视图集ViewSet，仍在类视图的文档字符串中封开定义，但是应使用action名称区分，如 1234567891011121314class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet): \"\"\" list: 返回图书列表数据 retrieve: 返回图书详情数据 latest: 返回最新的图书数据 read: 修改图书的阅读量 \"\"\" 1.4. 访问接口文档网页浏览器访问 127.0.0.1:8000/docs/，即可看到自动生成的接口文档。 两点说明：1） 视图集ViewSet中的retrieve名称，在接口文档网站中叫做read 2）参数的Description需要在模型类或序列化器类的字段中以help_text选项定义，如： 1234class Student(models.Model): ... age = models.IntegerField(default=0, verbose_name='年龄', help_text='年龄') ... 或 12345678910class StudentSerializer(serializers.ModelSerializer): class Meta: model = Student fields = \"__all__\" extra_kwargs = &#123; 'age': &#123; 'required': True, 'help_text': '年龄' &#125; &#125;","tags":[{"name":"drf","slug":"drf","permalink":"http://yoursite.com/tags/drf/"}]},{"title":"分页器和自定义限制ip访问频率","date":"2018-01-10T16:00:00.000Z","path":"2018/01/11/7.分页器和自定义限制ip访问频率/","text":"分页器和自定义限制ip访问频率分页器第一种PageNumberPagination 1234567891011121314151617#views.py# 查所有，才需要分页from rest_framework.generics import ListAPIViewfrom rest_framework.pagination import PageNumberPagination,'''PageNumberPagination page_size:每页显示的条数'''class MyPageNumberPagination(PageNumberPagination): page_size=3 #每页条数 page_query_param='aaa' #查询第几页的key page_size_query_param='size' # 每一页显示的条数 max_page_size=5 # 每页最大显示条数 url：#http://127.0.0.1:8000/api/books2/?aaa=1&amp;size=6 第二种LimitOffsetPagination 123456from rest_framework.pagination import LimitOffsetPaginationclass MyLimitOffsetPagination(LimitOffsetPagination): default_limit = 3 # 每页条数 limit_query_param = 'limit' # 往后拿几条 offset_query_param = 'offset' # 标杆 max_limit = 5 # 每页最大几条 第三种CursorPagination 12345from rest_framework.pagination import CursorPaginationclass MyCursorPagination(CursorPagination): cursor_query_param = 'cursor' # 每一页查询的key page_size = 2 #每页显示的条数 ordering = '-id' #排序字段 view视图 1234567class BookView(ListAPIView): # queryset = models.Book.objects.all().filter(is_delete=False) queryset = models.Book.objects.all() serializer_class = BookModelSerializer #配置分页 pagination_class = MyCursorPagination 因为分页器是GenericAPIView的方法，APIView里面没有 APIView使用分页器 123456789101112131415161718192021class MyPageNumberPagination(PageNumberPagination): page_size=3 #每页条数 page_query_param='aaa' #查询第几页的key page_size_query_param='size' # 每一页显示的条数 max_page_size=5 # 每页最大显示条数class BookView(APIView): def get(self,request,*args,**kwargs): book_list=models.Book.objects.all() # 实例化得到一个分页器对象 page_cursor=MyPageNumberPagination() book_list=page_cursor.paginate_queryset(book_list,request,view=self) next_url =page_cursor.get_next_link() pr_url=page_cursor.get_previous_link() book_ser=BookModelSerializer(book_list,many=True) return Response(data=book_ser.data) 自定义ip频率访问12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 自定制频率类，需要写两个方法 -# 判断是否限次：没有限次可以请求True，限次了不可以请求False def allow_request(self, request, view): -# 限次后调用，显示还需等待多长时间才能再访问，返回等待的时间seconds def wait(self): # 代码import timeclass IPThrottle(): #定义成类属性,所有对象用的都是这个 VISIT_DIC = &#123;&#125; def __init__(self): self.history_list=[] def allow_request(self, request, view): ''' #（1）取出访问者ip #（2）判断当前ip不在访问字典里，添加进去，并且直接返回True,表示第一次访问，在字典里，继续往下走 #（3）循环判断当前ip的列表，有值，并且当前时间减去列表的最后一个时间大于60s，把这种数据pop掉，这样列表中只有60s以内的访问时间， #（4）判断，当列表小于3，说明一分钟以内访问不足三次，把当前时间插入到列表第一个位置，返回True，顺利通过 #（5）当大于等于3，说明一分钟内访问超过三次，返回False验证失败 ''' ip=request.META.get('REMOTE_ADDR') ctime=time.time() if ip not in self.VISIT_DIC: self.VISIT_DIC[ip]=[ctime,] return True self.history_list=self.VISIT_DIC[ip] #当前访问者时间列表拿出来 while True: if ctime-self.history_list[-1]&gt;60: self.history_list.pop() # 把最后一个移除 else: break if len(self.history_list)&lt;3: self.history_list.insert(0,ctime) return True else: return False def wait(self): # 当前时间，减去列表中最后一个时间 ctime=time.time() return 60-(ctime-self.history_list[-1])#全局使用，局部使用 源码分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# SimpleRateThrottle源码分析 def get_rate(self): \"\"\" Determine the string representation of the allowed request rate. \"\"\" if not getattr(self, 'scope', None): msg = (\"You must set either `.scope` or `.rate` for '%s' throttle\" % self.__class__.__name__) raise ImproperlyConfigured(msg) try: return self.THROTTLE_RATES[self.scope] # scope：'user' =&gt; '3/min' except KeyError: msg = \"No default throttle rate set for '%s' scope\" % self.scope raise ImproperlyConfigured(msg) def parse_rate(self, rate): \"\"\" Given the request rate string, return a two tuple of: &lt;allowed number of requests&gt;, &lt;period of time in seconds&gt; \"\"\" if rate is None: return (None, None) #3 mmmmm num, period = rate.split('/') # rate：'3/min' num_requests = int(num) duration = &#123;'s': 1, 'm': 60, 'h': 3600, 'd': 86400&#125;[period[0]] return (num_requests, duration) def allow_request(self, request, view): if self.rate is None: return True #当前登录用户的ip地址 self.key = self.get_cache_key(request, view) # key：'throttle_user_1' if self.key is None: return True # 初次访问缓存为空，self.history为[]，是存放时间的列表 self.history = self.cache.get(self.key, []) # 获取一下当前时间，存放到 self.now self.now = self.timer() # Drop any requests from the history which have now passed the # throttle duration # 当前访问与第一次访问时间间隔如果大于60s，第一次记录清除，不再算作一次计数 # 10 20 30 40 # self.history:[10:23,10:55] # now:10:56 while self.history and self.now - self.history[-1] &gt;= self.duration: self.history.pop() # history的长度与限制次数3进行比较 # history 长度第一次访问0，第二次访问1，第三次访问2，第四次访问3失败 if len(self.history) &gt;= self.num_requests: # 直接返回False，代表频率限制了 return self.throttle_failure() # history的长度未达到限制次数3，代表可以访问 # 将当前时间插入到history列表的开头，将history列表作为数据存到缓存中，key是throttle_user_1，过期时间60s return self.throttle_success()","tags":[{"name":"drf","slug":"drf","permalink":"http://yoursite.com/tags/drf/"}]},{"title":"十大接口","date":"2018-01-09T16:00:00.000Z","path":"2018/01/10/6.drf 十大接口/","text":"序列化外键字段的覆盖在序列化类中自定字段，名字与model类中属性名一致，就称为覆盖操作（覆盖的是属性的所有规则：extra kwargs中指定的简易规则、model字段提供的默认规则、数据库唯一约束等那些规则） 外键覆盖字段用PriaryKeyRekatedField来实现，可以做到只读只写、可读可写三种形式 只读：read_only=True 只写：querset=关键表达 queryset，write_only=True 可读可写：queryset=关联表的queryset 当外界关联的数据是多个时，需标识many=True条件 123456789101112class BookModelSerializer(serializers.ModelSerializer): # 如何覆盖外键字段 # publish = serializers.PrimaryKeyRelatedField(read_only=True) # 只读 # publish = serializers.PrimaryKeyRelatedField(queryset=models.Publish.objects.all(), write_only=True) # 只写 # publish = serializers.PrimaryKeyRelatedField(queryset=models.Publish.objects.all()) # 可读可写 publish = serializers.PrimaryKeyRelatedField(queryset=models.Publish.objects.all()) authors = serializers.PrimaryKeyRelatedField(queryset=models.Author.objects.all(), many=True) class Meta: model = models.Book fields = ('name', 'price', 'image', 'publish', 'authors') 十大接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# models.pyfrom django.db import models# Create your models here.# 基类：抽象概念，这个是不会完成数据迁移的，目的是提供共有的字段class BaseModel(models.Model): is_delete = models.BooleanField(default=False) # auto_now_add 自动生成时间,不要手动加时间 create_time = models.DateTimeField(auto_now_add=True, ) last_update_time = models.DateTimeField(auto_now=True) # import datetime # create_time = models.DateTimeField(default=datetime.datetime.now) class Meta: # 单个字段，有索引，联合唯一 # 联合唯一，有联合索引，联合唯一 abstract = True # 不在数据库中建表class Book(BaseModel): id = models.AutoField(primary_key=True) name = models.CharField(max_length=32,verbose_name='图书') price = models.DecimalField(max_digits=5, decimal_places=2,verbose_name='价格') # db_constraint=False,逻辑上的关联，增删改没问图 publish = models.ForeignKey('Publish', on_delete=models.DO_NOTHING, db_constraint=False,verbose_name='关联出版社') authors = models.ManyToManyField('Authors', db_constraint=False,verbose_name='关联作者') class Meta: verbose_name_plural= '图书表' def __str__(self): return self.name @property def publish_name(self): return self.publish.name def author_list(self): return [&#123;\"name\": author.name, \"sex\": author.get_sex_display()&#125; for author in self.authors.all()]class Publish(BaseModel): name = models.CharField(max_length=32,verbose_name='出版社') addr = models.CharField(max_length=32,verbose_name='地址') class Meta: verbose_name_plural='出版社' def __str__(self): return self.nameclass Authors(BaseModel): name = models.CharField(max_length=32,verbose_name='姓名') sex = models.IntegerField(choices=((1, '男'), (2, '女')),verbose_name='性别') authordetail = models.OneToOneField('AuthorsDetail', db_constraint=False, on_delete=models.CASCADE,verbose_name='关联作者详情') class Meta: verbose_name_plural = '作者' def __str__(self): return self.nameclass AuthorsDetail(BaseModel): mobile = models.CharField(verbose_name='手机号',max_length=11) # authors = models.OneToOneField('Authors', on_delete=models.CASCADE,verbose_name='关联作者') class Meta: verbose_name_plural = '作者详情' def __str__(self): return self.mobile 对于共有的字段我们可以创建一个基类，然后每一个表继承基类，这个基类是抽象的，目的是提供共有的字段，我们展示前端上面的删除，只是逻辑上的删除，后台并不会删除，这个事不会完成数据迁移的，abstract = True 不在数据库中建表,这样可以 12345678910二、表断关联1、表之间没有外键关联，但是有外键逻辑关联(有充当外键的字段)2、断关联后不会影响数据库查询效率，但是会极大提高数据库增删改效率（不影响增删改查操作）3、断关联一定要通过逻辑保证表之间数据的安全，不要出现脏数据，代码控制4、断关联5、级联关系 作者没了，详情也没：on_delete=models.CASCADE 出版社没了，书还是那个出版社出版：on_delete=models.DO_NOTHING 部门没了，员工没有部门(空不能)：null=True, on_delete=models.SET_NULL 部门没了，员工进入默认部门(默认值)：default=0, on_delete=models.SET_DEFAULT 单查和群查12345678910111213141516class BookGenericAPIView(GenericAPIView): queryset = Book.objects.all().filter(is_delete=False) serializer_class = BookModelSerializer def get(self, request, *args, **kwargs): pk = kwargs.get('pk') if pk: obj = Book.objects.filter(is_delete=False, pk=pk).first() serializer =self.get_serializer(instance=obj) return APIResponse(result=serializer.data) else: book_list = self.get_queryset() book_list = self.get_serializer(book_list, many=True) return APIResponse('100', '成功', data=book_list.data) 单增和群增12345678910111213def post(self, request, *args, **kwargs): if isinstance(request.data,dict): book_ser = self.get_serializer(data=request.data) # 现在这个book_ser 是ListSerializer对象 book_ser.is_valid(raise_exception=True) book_ser.save() return APIResponse('100','成功',book_ser.data) else: book_ser = self.get_serializer(data=request.data,many=True) book_ser.is_valid(raise_exception=True) book_ser.save() return APIResponse('100', '成功', book_ser.data) 这里我们区别单增和群增：request.data是{}，群增是[] 在校验的时候我们捕获异常，失败就抛出异常，返回给前端 单改和群改123456789101112131415161718192021def put(self, request, *args, **kwargs): if kwargs.get(&#39;pk&#39;,None): book &#x3D; Book.objects.filter(pk&#x3D;kwargs.get(&#39;pk&#39;)).first() book_ser &#x3D; BookModelSerializer(instance&#x3D;book, data&#x3D;request.data, partial&#x3D;True) # 增多条 book_ser.is_valid(raise_exception&#x3D;True) book_ser.save() return Response(book_ser.data) else: # print(request.data) book_obj &#x3D; [] # 存放当前书的对象 book_list &#x3D; [] for item in request.data: book &#x3D; Book.objects.filter(pk&#x3D;item.pop(&#39;id&#39;),is_delete&#x3D;False).first() book_obj.append(book) book_list.append(item) book_ser &#x3D; self.get_serializer(instance&#x3D;book_obj,data&#x3D;book_list,many&#x3D;True) book_ser.is_valid(raise_exception&#x3D;True) book_ser.save() return APIResponse(&#39;100&#39;, &#39;成功&#39;, book_ser.data) 单整体该改分析整体该改分析 123456789101112单整体改：接口：api/books/pk 数据：dict1 分析request.data数据[&#123;'pk':1,'name':'',publish:1,'authors':[1,2]&#125;]2 我们还可以从request.data中分离出数据，放在一个列表里面pks3 pks中存放的pks在数据库中没有对应的数据，或者对应的数据已经删除，这些不合理的pk要剔除4 pks最终转化得到的列表长度和request.data列表长度一致，否则就是数据有误5 我们新增的数据使用的是ListSerializer--》create方法 def create(self, validated_data): self.child是BookModelSerializer对象 print(type(self.child)) return [ self.child.create(attrs) for attrs in validated_data ] 单部修改和群修改123456789101112131415161718192021def put(self, request, *args, **kwargs): if kwargs.get('pk',None): book = Book.objects.filter(pk=kwargs.get('pk')).first() book_ser = BookModelSerializer(instance=book, data=request.data, partial=True) # 增多条 book_ser.is_valid(raise_exception=True) book_ser.save() return Response(book_ser.data) else: # print(request.data) book_obj = [] # 存放当前书的对象 book_list = [] for item in request.data: book = Book.objects.filter(pk=item.pop('id'),is_delete=False).first() book_obj.append(book) book_list.append(item) book_ser = self.get_serializer(instance=book_obj,data=book_list,many=True) book_ser.is_valid(raise_exception=True) book_ser.save() return APIResponse('100', '成功', book_ser.data) 分析 12345 单整体改：接口：/books/(pk)/ 数据：dict 群整体改：接口：/books/ 数据：[&#123;pk1, ...&#125;, ..., &#123;pkn, ...&#125;] | &#123;pks: [pk1, ..., pkn], data: [&#123;&#125;, ..., &#123;&#125;]&#125;这里的群改我们重新写update方法，因为我们最后用的序列化器是ListSerializer，这个没有写update方法 单删和群删12345678910111213def delete(self,request,*args,**kwargs): pk = kwargs.get('pk') pks = [] if pk: pks.append(pk) else: pks = request.data.get('pks') res = Book.objects.filter(is_delete=False,pk__in=pks).update(is_delete=True) #把is_delete设置成true if res: return APIResponse(data=&#123;'msg': '删除成功'&#125;) else: return APIResponse(data=&#123;'msg': '没有要删除的数据'&#125;) 分析 1单删和群删我们共用一个接口，无论是kwargs取过来的值，还是request.data取到的值，把单删的数据pk值放进pks=[]里面我们用一个删除的表 序列化的写法ListSerializer123456789101112131415161718192021222324252627from rest_framework import serializersfrom app01.models import Publish,Book,Authorsclass BookListSerializer(serializers.ListSerializer): def update(self, instance, validated_data): print(validated_data) # print(instance) return [ self.child.update(instance[i],attrs) for i,attrs in enumerate(validated_data) ]class BookModelSerializer(serializers.ModelSerializer): class Meta: model = Book list_serializer_class = BookListSerializer fields = [\"id\", 'name', 'price', 'publish', 'authors', 'publish_name', 'author_list'] extra_kwargs = &#123; 'publish': &#123;'write_only': True&#125;, 'authors': &#123;'write_only': True&#125;, 'publish_name': &#123;'read_only': True&#125;, 'author_list': &#123;'read_only': True&#125;, &#125; 分析重写的update 12341 写一个类，继ListSerializer,重写update2 self.child:是BookModelSerializer对象3 self.child.update(对象，字典) for attrs in validated_data4 和BookModelSerializer建立关联，list_serializer_class = BookListSerializer","tags":[{"name":"drf","slug":"drf","permalink":"http://yoursite.com/tags/drf/"}]},{"title":"权限,频率,过滤,排序","date":"2018-01-08T16:00:00.000Z","path":"2018/01/09/5.权限，频率，过滤，排序/","text":"权限权限源码分析 我们还是从入口点开始 1APIView--&gt; dispatch--&gt; initial--&gt; check_permissions check_permissions源码 1234567def check_permissions(self, request): for permission in self.get_permissions(): if not permission.has_permission(request, self): self.permission_denied( request, message=getattr(permission, 'message', None) ) 遍历权限对象得到一个个对象，进行权限认证 权限类中一定有一个has_permission权限方法，用来做权限认证 参数：权限对象self ,请求对象的request, 视图类对象 返回值：有权限返回True, 无权限返回False 权限的使用在写一个类，继承BasePermission,重写has_permission,如果权限通过，就返回True，不通过就返回False 123456789class UserPermision(BasePermission): def has_permission(self, request, view): # 不是超级用户就不能访问 # 认证通过，request内就有了user对象，当前的登录用户,取出当前用户 user = request.user print(user.get_user_type_display()) if user.user_type == 1: return True return False 测试数据 123456789101112131415161718192021222324# 局部使用超级用户使用class TestView(APIView): permission_classes = [UserPermision] def get(self,request): return Response(\"这是测试数据\")# 全局使用class TestView1(APIView): def get(self,request): return Response(\"这是测试数据\")全局使用要在settings里面配置一下REST_FRAMEWORK = &#123; \"DEFAULT_AUTHENTICATION_CLASSES\": [\"app01.authssssssssssss.MyAuthentication\", ], 'DEFAULT_PERMISSION_CLASSES': [ 'app01.authssssssssssss.UserPermision', ],&#125;# 局部禁用class TestView2(APIView): permission_classes = [] def get(self,request): return Response(\"这是测试数据\") 内置权限123456789from rest_framework.permissions import IsAdminUserfrom rest_framework.authentication import SessionAuthentication# 内置的权限class TestView3(APIView): authentication_classes = [SessionAuthentication] permission_classes = [IsAdminUser] def get(self,request,*args,**kwargs): return Response(\"这是测试数据\") 频率内置的频率限制使用限制未登录 12345678910111213141516171819202122232425262728# 全局使用 限制未登录用户1分钟访问3次REST_FRAMEWORK = &#123; 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.AnonRateThrottle', ), 'DEFAULT_THROTTLE_RATES': &#123; 'anon': '3/m', &#125;&#125;##############views.pyfrom rest_framework.permissions import IsAdminUserfrom rest_framework.authentication import SessionAuthentication,BasicAuthenticationclass TestView4(APIView): authentication_classes=[] permission_classes = [] def get(self,request,*args,**kwargs): return Response('我是未登录用户')# 局部使用from rest_framework.permissions import IsAdminUserfrom rest_framework.authentication import SessionAuthentication,BasicAuthenticationfrom rest_framework.throttling import AnonRateThrottleclass TestView5(APIView): authentication_classes=[] permission_classes = [] throttle_classes = [AnonRateThrottle] def get(self,request,*args,**kwargs): return Response('我是未登录用户，TestView5') 使用限制登录用户 12345678910111213# 需求：未登录用户1分钟访问5次，登录用户一分钟访问10次全局：在setting中 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle' ), 'DEFAULT_THROTTLE_RATES': &#123; 'user': '10/m', 'anon': '5/m', &#125; 局部配置： 在视图类中配一个就行 过滤123456789#1 安装：pip3 install django-filter#2 注册，在app中注册#3 全局配，或者局部配 'DEFAULT_FILTER_BACKENDS': ('django_filters.rest_framework.DjangoFilterBackend',)#4 视图类class BookView(ListAPIView): queryset = Book.objects.all() serializer_class = BookSerializer filter_fields = ('name',) #配置可以按照哪个字段来过滤 排序1234567891011from rest_framework.filters import OrderingFilterclass BooK1View(ListAPIView): queryset = models.Book.objects.all() serializer_class = BookModelSerializer filter_backends = [OrderingFilter] ordering_fields = ('id',\"name\")# 使用：http://127.0.0.1:8000/books2/?ordering=namehttp://127.0.0.1:8000/books2/?ordering=-id 异常处理123456789101112131415161718from rest_framework.views import exception_handlerfrom rest_framework.response import Responsefrom rest_framework import statusdef my_exception_handler(exc, context): response=exception_handler(exc, context) # 两种情况，一个是None，drf没有处理 #response对象，django处理了，但是处理的不符合咱们的要求 # print(type(exc)) print(type(exc))# 这里可以打印出更详细的错误信息 if isinstance(exc,ZeroDivisionError): return Response(data=&#123;'status':777,'msg':\"o的错误\"&#125;,status=status.HTTP_400_BAD_REQUEST) if not response: return Response(data=&#123;'status':999,'msg':str(exc)&#125;,status=status.HTTP_400_BAD_REQUEST) else: return Response(data=&#123;'status': 888, 'msg': response.data.get('detail')&#125;, status=status.HTTP_400_BAD_REQUEST) 封装Response对象123456789101112# 以后都用自己封装的class APIResponse(Response): def __init__(self,code=100,msg='成功',data=None,status=None,headers=None,**kwargs): dic = &#123;'code': code, 'msg': msg&#125; if data: dic = &#123;'code': code, 'msg': msg,'data':data&#125; dic.update(kwargs) super().__init__(data=dic, status=status,headers=headers)# 使用return APIResponse(data=&#123;\"name\":'lqz'&#125;,token='dsafsdfa',aa='dsafdsafasfdee')return APIResponse(data=&#123;\"name\":'lqz'&#125;)return APIResponse(code='101',msg='错误',data=&#123;\"name\":'lqz'&#125;,token='dsafsdfa',aa='dsafdsafasfdee',header=&#123;&#125;)","tags":[{"name":"drf","slug":"drf","permalink":"http://yoursite.com/tags/drf/"}]},{"title":"路由和认证","date":"2018-01-07T16:00:00.000Z","path":"2018/01/08/4.路由和认证/","text":"1 三种路由的配置 在urls.py里面的配置的常规配置 12path('books4/', views.Book4View.as_view()),re_path('books4/(?P&lt;pk&gt;\\d+)', views.Book4DetailView.as_view()) 视图类中继承了ViewSetMixin 12path('books5/', views.Book5View.as_view(actions=&#123;'get':'list','post':'create'&#125;)), #当路径匹配，又是get请求，会执行Book5View的list方法re_path('books5/(?P&lt;pk&gt;\\d+)', views.Book5View.as_view(actions=&#123;'get':'retrieve','put':'update','delete':'destroy'&#125;)), 继承视图类ModelViewSet路由的写法 配置路由导入模块 1from rest_framework import routers 两个类,实例化得到对象 1234567891011121314151617routers.DefaultRouter····^books/$ [name='book-list'] # 根^books\\.(?P&lt;format&gt;[a-z0-9]+)/?$ [name='book-list']# simple的差不多^books/(?P&lt;pk&gt;[^/.]+)/$ [name='book-detail']^books/(?P&lt;pk&gt;[^/.]+)\\.(?P&lt;format&gt;[a-z0-9]+)/?$ [name='book-detail']# 和simple的差不多^$ [name='api-root']# 根路径会显示出所有可以访问的地址^\\.(?P&lt;format&gt;[a-z0-9]+)/?$ [name='api-root']····自动生成的6个路由routers.SimpleRouter\"\"\"[&lt;RegexURLPattern book-list ^books/$&gt;,&lt;RegexURLPattern book-detail ^books/(?P&lt;pk&gt;[^/.]+)/$&gt;]\"\"\"\"自动生成的2个路由 注册 1router.register('books',views.BookViewSet)# 后面可以加别名 自动生成路由，加入到原来的路由中去 1urlpatterns+=router.urls action的使用是为了给继承ModelViewSet视图类定义的函数也添加路由 123456789class BookViewSet(ModelViewSet): queryset = models.Book.objects.all() serializer_class = BookModelSerializer @action(methods=['GET','post'], detail=True) def get_5(self, request,pk): book = self.get_queryset()[:5] # 从0开始截取 ser = self.get_serializer(book, many=True) return Response(ser.data) methods:第一个参数，传一个列表，列表中放请求方式，如get，post等 detail: 1234^books/get_1/$ [name='book-get-1'] 当向这个地址发送get请求，会执行下面的函数detail：布尔类型 如果是True^books/(?P&lt;pk&gt;[^/.]+)/get_1/$ [name='book-get-1']http://127.0.0.1:8000/books/1/get_5/ 认证1 认证的实现1 写一个类，继承BaseAuthentication，重写authenticate，认证的逻辑写在里面，认证通过，返回两个值，一个值最终给了Requet对象的user，认证失败，抛异常：APIException或者AuthenticationFailed 2 全局使用，局部使用2 drf认证的源码分析入口点 12在APIView--&gt; as_view--&gt; dispatch方法--&gt; self.initial(request, *args, **kwargs)这个方法中有认证，权限，频率 dispatch方法源码 12345678910111213141516171819202122232425def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 在try里面 self.initial这个方法点进去，在APIView里面 initital方法 1234567891011121314def initial(self, request, *args, **kwargs): \"\"\" Runs anything that needs to occur prior to calling the method handler. \"\"\" self.format_kwarg = self.get_format_suffix(**kwargs) neg = self.perform_content_negotiation(request) request.accepted_renderer, request.accepted_media_type = neg version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme self.perform_authentication(request) self.check_permissions(request) self.check_throttles(request) self.perform_authentication(request)只读这个认证的功能 ，传个request过来，这个request是包装后的， perform_authentication方法的源码 12def perform_authentication(self, request): request.user 因为这个是包装过后的Request，所以我们要到包装过后的request对象里面的user属性 user属性源码 123456@property def user(self): if not hasattr(self, '_user'): with wrap_attributeerrors(): self._authenticate() return self._user 判断self里面有没有_user这个属性，一开始是没有的，它就会走下面的上下文管理器， self._authenticate() 点_authenticate这个方法，这个方法还在Request对象里面， _authenticate源码 1234567891011121314def _authenticate(self): for authenticator in self.authenticators: try: user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise if user_auth_tuple is not None: self._authenticator = authenticator self.user, self.auth = user_auth_tuple return self._not_authenticated() 这里的for循环的authenticators一定是一个可迭代对象，我们要到Request对象里面去找， 123456789101112class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( 'The `request` argument must be an instance of ' '`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.' .format(request.__class__.__module__, request.__class__.__name__) ) self._request = request self.authenticators = authenticators or () 我们发现是在这个类里面初始化得到的，这个类是dispatch包装request得到的，request = self.initialize_request(request, *args, **kwargs)点击initialize_request这个方法 我们发现了authenticators 12345678return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context) 123def get_authenticators(self): return [auth() for auth in self.authentication_classes] 这个是列表生成式，从自己`authentication_classes去取，取出一个加括号执行，这个self是APIView里面的对象的属性，因为自己视图类里面没有 1authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 列表中是一对对象，是视图类中配置的authentication_classes=[类名]对象， 所以Request对象中的authenticators=self.get_authenticators()是列表[类的对象]，被传到了Request对象定义的这个 self.authenticators = authenticators or ()传给了authenticators里面， _authenticate源码里面的for循环，就是self.authenticators 配置的一堆认证产生类对象组成的list，每次循环拿到一个对象 1234567891011121314def _authenticate(self): for authenticator in self.authenticators: try: user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise if user_auth_tuple is not None: self._authenticator = authenticator self.user, self.auth = user_auth_tuple return self._not_authenticated() authenticator.authenticate这个就是为什么要重写这个方法，执行这个方法，返回的时候是两个值，解压赋值，认证逻辑通过，返回两个值，一个值给了Request对象的user，认证失败，抛出异常APIException，也可以抛出AuthenticationFailed它里面也是继承了APIException 3 认证组件的使用12345678910111213141516from rest_framework.authentication import BaseAuthenticationfrom rest_framework.exceptions import AuthenticationFailedclass MyAuthentication(BaseAuthentication): def authenticate(self, request): # 认证逻辑，通过返回两个值 token = request.GET.get('token') #token = request.META.get('HTTP_TOKEN')这个是放在请求头里面 if token: from app01 import models user_token = models.UserToken.objects.filter(token=token).first() if user_token: return user_token.user,token else: raise AuthenticationFailed('认证失败') else: raise AuthenticationFailed('请求地址中需要携带token') 4 全局使用和局部禁用'12345678全局使用在settings里面配置REST_FRAMEWORK=&#123; \"DEFAULT_AUTHENTICATION_CLASSES\":[\"app01.app_auth.MyAuthentication\",]&#125;局部使用：authentication_classes=[MyAuthentication]局部禁用：在登陆的时候就不需要，因为你还没登录呢，如何做认证authentication_classes=[] 里面什么都不加就可以了","tags":[{"name":"drf","slug":"drf","permalink":"http://yoursite.com/tags/drf/"}]},{"title":"请求和响应和视图","date":"2018-01-06T16:00:00.000Z","path":"2018/01/07/3.请求和响应和视图/","text":"请求request常用属性：request.data,前端三种编码方式传过来都可以取出来 request.query_params和request.GET的属性一样。这个是二次封装后的属性 响应responseREST framework提供了一个响应类Response，使用该类构造响应对象时，响应的具体数据内容会被转换（render渲染）成符合前端需求的类型。 REST framework提供了Renderer 渲染器，用来根据请求头中的Accept（接收数据类型声明）来自动转换响应数据到对应格式。如果前端请求中未进行Accept声明，则会采用默认方式处理响应数据，我们可以通过配置来修改默认响应格式。 可以在rest_framework.settings查找所有的drf默认配置项： 12345678910111213141516171819REST_FRAMEWORK &#x3D; &#123; &#39;DEFAULT_RENDERER_CLASSES&#39;: ( # 默认响应渲染类 &#39;rest_framework.renderers.JSONRenderer&#39;, # json渲染器 &#39;rest_framework.renderers.BrowsableAPIRenderer&#39;, # 浏览API渲染器 )&#125;# 在视图类中局部使用：from rest_framework.renderers import JSONRenderer renderer_classes&#x3D;[JSONRenderer,] -全局使用：全局的视图类，所有请求，都有效 -在setting.py中加入如下 REST_FRAMEWORK &#x3D; &#123; &#39;DEFAULT_RENDERER_CLASSES&#39;: ( # 默认响应渲染类 &#39;rest_framework.renderers.JSONRenderer&#39;, # json渲染器 &#39;rest_framework.renderers.BrowsableAPIRenderer&#39;, # 浏览API渲染器 ) &#125; 常用属性 12345data: 返回的数据，是一个字典status：返回的状态码，默认是200tempalte_name：渲染的模板headers：响应头content_type: 响应的编码格式，application/json/text 视图基于APIView写的接口123456789101112131415161718192021222324252627282930313233343536class BookAPIView(APIView): def get(self,request,pk): book = models.Book.objects.filter(pk=pk).first() book_ser = ser.BookSerializers(book) return Response(book_ser.data) def put(self,request,pk): response_msg = &#123;'status':100,'msg':\"\"&#125; book = models.Book.objects.filter(pk=pk).first() book_ser = ser.BookSerializers(instance=book,data=request.data) if book_ser.is_valid(): book_ser.save() else: response_msg['status'] = 101 response_msg['msg'] = '失败' response_msg['data'] = request.data return Response(request.data) def delete(self,request,pk): response_msg = &#123;'status': 100, 'msg': \"\"&#125; book = models.Book.objects.filter(pk=pk).delete() return Response(response_msg)class BookSAPIView(APIView): def post(self,request): book = ser.BookSerializers(data=request.data) if book.is_valid(): book.save() return Response(book.data) def get(self, request): book = models.Book.objects.all() book_ser = ser.BookSerializers(book,many=True) return Response(book_ser.data) 基于 GenericAPIView1234567891011121314151617181920212223242526272829303132333435363738394041rom rest_framework.generics import GenericAPIViewclass Book2View(GenericAPIView): queryset = models.Book.objects serializer_class = ser.BookSerializers def get(self,request,pk): book = self.get_object() book_ser = self.get_serializer(book) return Response(book_ser.data) def put(self,request,pk): book = models.Book.objects.filter(pk=pk).first() book_ser = ser.BookSerializers(instance=book,data=request.data) if book_ser.is_valid(): book_ser.save() return Response(request.data) def delete(self,request,pk): response_msg = &#123;'status': 100, 'msg': \"\"&#125; models.Book.objects.filter(pk=pk).delete() return Response(response_msg)class Books2View(GenericAPIView): queryset = models.Book.objects serializer_class = ser.BookSerializers def get(self, request): book = self.get_queryset() book_ser = self.get_serializer(book,many=True) return Response(book_ser.data) def post(self,request): book = self.get_serializer(data=request.data) if book.is_valid(): book.save() return Response(book.data)url:url(r'^book2/(?P&lt;pk&gt;\\d+)/', views.Book2View.as_view()),url(r'^books2/', views.Books2View.as_view()), GenericAPIView+5 个视图扩展类1234567891011121314151617181920212223242526from rest_framework.mixins import ListModelMixin,CreateModelMixin,UpdateModelMixin,DestroyModelMixin,RetrieveModelMixinclass Book3View(GenericAPIView,RetrieveModelMixin,DestroyModelMixin,UpdateModelMixin): queryset = models.Book.objects serializer_class = ser.BookSerializers def get(self,request,pk): return self.retrieve(request,pk) def put(self,request,pk): return self.update(request,pk) def delete(self,request,pk): return self.destroy(request,pk)class Books3View(GenericAPIView,ListModelMixin,CreateModelMixin): queryset = models.Book.objects serializer_class = ser.BookSerializers def get(self, request): return self.list(request) def post(self,request): return self.create(request)url:url(r'^book3/(?P&lt;pk&gt;\\d+)/', views.Book3View.as_view()),url(r'^books3/', views.Books3View.as_view()), 使用ModelViewSet编写5个接口12345678from rest_framework.viewsets import ModelViewSetclass Book4View(ModelViewSet): queryset = models.Book.objects serializer_class = ser.BookSerializersurl:url(r'^book4/(?P&lt;pk&gt;\\d+)/', views.Book4View.as_view(actions=&#123;'get':'retrieve','post':'update','delete':'destroy'&#125;)),url(r'^books4/', views.Book4View.as_view(actions=&#123;'get':'list','post':'create'&#125;)) 只要使用了ModelViewSet就要重新配置路由 继承ViewSetMixin的视图类1234567891011# views.pyfrom rest_framework.viewsets import ViewSetMixinclass Book5View(ViewSetMixin,APIView): #一定要放在APIVIew前 def get_all_book(self,request): book_list = Book.objects.all() book_ser = BookSerializer(book_list, many=True) return Response(book_ser.data) # urls.py #继承ViewSetMixin的视图类，路由可以改写成这样 url(r'^books5/, views.Book5View.as_view(actions=&#123;'get': 'get_all_book'&#125;)),","tags":[{"name":"drf","slug":"drf","permalink":"http://yoursite.com/tags/drf/"}]},{"title":"序列化组件","date":"2018-01-05T16:00:00.000Z","path":"2018/01/06/2.序列化组件/","text":"1.简单介绍 序列化：序列器会把模型转成字典，经过response以后变成json字符串 反序列化：把客户端传过来的数据，经过request以后变成字典，序列化器可以把字典转成模型 2.使用 建立orm，创建一个py文件，写一个序列化器，继承Serializer 在类中书写序列化的字段 在视图中导入实例化得到的序列化类的对象，把要序列化的对象传入进去 序列化类的对象.data 这里是一个字典 把字典返回，如果不适应rest_framework提供的Response,l可以使用JsonResponse 123456789101112131415# ser.pyfrom rest_framework import serializersclass BookSerializer(serializers.Serializer): price = serializers.CharField() #创建你要序列化的字段# views.pyclass BookAPIView(APIView): def get(self, request, pk): book = models.Book.objects.filter(id=pk).first() book_ser = BookSerializer(book) # 要序列化谁就把谁传过来， # 调用类的__init__ return Response(book_ser.data) # 序列化对象.data就是序列化后的字典#urlre_path('books/(?P&lt;pk&gt;\\d+)', views.BookAPIView.as_view()), 补充：还有很多的字段类型 1CharField,IntegerField,DateField 3. 单个数据的修改和展示上面是简单的使用，这个是对某一个数据的更新。 在类中写要序列化的字段，像序列化哪个就写哪个，里面还可以添加一些参数 123456max_length 最大长度 min_lenght 最小长度 allow_blank 是否允许为空 trim_whitespace 是否截断空白字符 max_value 最小值 min_value 最大值 在视图中使用，实例化得到序列化的对象，把要修改的对象传入，修改的数据传入 校验数据，通过保存 如果字段的校验规则不够我们可以自己写钩子 12345678910111213141516171819202122232425# ser.pyclass BookSerializer(serializers.Serializer): title = serializers.CharField(max_length=6,min_length=2) price = serializers.CharField() author = serializers.CharField(max_length=6,min_length=2) publish = serializers.CharField(max_length=6,min_length=2) # view.pyclass BookAPIView(APIView): def put(self,request,pk): response_msg = &#123;'state':100,'msg':'成功'&#125; book = models.Book.objects.filter(id=pk).first() # 更新或修改某个字段要传两个参数 book_obj = BookSerializer(instance=book,data=request.data) # 传两个参数对象和数据 # 验证数据 if book_obj.is_valid(): # 这里不能直接用save要重写 book_obj.save() response_msg['data']=book_obj.data else: response_msg['state']=101 response_msg['msg'] = '数据校验失败' response_msg['data']=book_obj.errors return Response(response_msg) 3.1 ser.py中的局部钩子和全局钩子123456789101112131415from rest_framework.exceptions import ValidationError # 局部钩子 def validate_author(self, data): if '啊' in data: raise ValidationError('作者名不能有啊') else: return data def validate(self, validate_data): author = validate_data.get('author') publish = validate_data.get('publish') if author==publish: raise ValidationError('作者名字不能和出版社一样哦') else: return validate_data 3.2 重写update方法 我们在修改数据的时候用save(),不能直接保存，需要我们重新在ser.py中重写update方法 1234567def update(self, instance, validated_data): instance.name = validated_data.get('title') instance.price = validated_data.get('price') instance.author = validated_data.get('author') instance.publish = validated_data.get('publish') instance.save() return instance instance 是book这个对象 validated_data是校验过的数据 instance.save()相当于book.save() 123456789&#123; \"state\": 101, \"msg\": \"数据校验失败\", \"data\": &#123; \"non_field_errors\": [ \"作者名字不能和出版社一样哦\" ] &#125;&#125; drf返回错误信息的标准写法，要有返回的错误信息 3.3 read_only 和write_only read_only 表明该字段只用于序列化输出，默认是False,设置成True，在postman里面可以看到该字段，修改的时候不需要传该字段 123456789101112131415# get方法序列化的时候输出&#123; \"title\": \"西游记\", \"price\": \"22\", \"author\": \"你得到\", \"publish\": \"西方出版社\"&#125;# put方法反序列化的时候输入&#123; \"title\": \"西游记\", \"price\": \"22\", \"publish\": \"北方出版社\"&#125; write_only 表明该字段只用于反序列化输入的时候，默认是False,设置成True，在postman里面看不到该字段，修改需要修改 12345678910111213展示时&#123; \"title\": \"西游记\", \"price\": \"22\", \"publish\": \"西方出版社\"&#125;修改时&#123; \"title\": \"西游记\", \"price\": \"22\", \"publish\": \"西方出版社\", \"author\":\"南门吹雪\"&#125; 4 查询所有和新增数据4.1 查看所有12345678class BooksAPIView(APIView): def get(self, request): response_msg = &#123;'state': 100, 'msg': '成功'&#125; books = models.Book.objects.all() books_ser = BookSerializer(books, many=True)#这里我们要查所有的字段要加参数many response_msg['data'] = books_ser.data return Response(response_msg) 这里为什么要加参数呢 4.2 many的源码123456def __new__(cls, *args, **kwargs): if kwargs.pop('many', False): return cls.many_init(*args, **kwargs) return super().__new__(cls, *args, **kwargs) 这里对象没有生成之前调用__new__方法，生成空对象，触发__init__,__new__控制对象的生成 先去BookSerializer去找_new__方法没有到父类，找到__new__方法 从kwrags取出参数pop，many默认是False，因为我们设置many是True执行下面的return，正常的实例化，many_init 1234@classmethod def many_init(cls, *args, **kwargs): list_serializer_class = getattr(meta, 'list_serializer_class', ListSerializer) return list_serializer_class(*args, **list_kwargs) 我们看到这个他是一个list，每一个都是BookModelSerializer对象 4.3 新增数据123456789def post(self,request): response_msg = &#123;'state': 100, 'msg': '成功'&#125; book_ser = BookSerializer(data=request.data) if book_ser.is_valid(): book_ser.save() def create(self, validated_data): isinstance = models.Book.objects.create(**validated_data) return isinstance 这里也遇到一个问题要重新写create方法才能保存 4.4 create方法的重写123def create(self, validated_data): isinstance = models.Book.objects.create(**validated_data) return isinstance 4.5 删除数据1234def delete(self, request, pk): models.Book.objects.filter(pk=pk).delete() response_msg = &#123;'state': 100, 'msg': '成功'&#125; return Response(response_msg) 5. 模型化类器12345678class BookModelSerializer(serializers.ModelSerializer): class Meta: model = models.Book fields = '__all__' # 序列化所有 exclude = ('title') # 排除title序列化其他字段，不能和fileds连用 extra_kwargs = &#123; # 类似于这种形式name=serializers.CharField(max_length=16,min_length=4) 'price': &#123;'write_only': True&#125;, &#125; 在3.2之后的模型类中write_only_fields弃用了 其他该写上面参数写什么参数，也可以不用重新写create和update方法 6. 自己封装Response7. Serializer高级用法 SerializerMethodField(）的使用的使用 1234567&#123; \"title\": \"西游记\", \"price\": \"12\", \"pub_date\": \"2020-07-28\", \"publish\": \"Publish object\", \"authors\": \"app01.Author.None\"&#125; 当我们跨表查询的时候，发现出版社和作者是一个对象，我们要在后端把他取出来实例化展示 123456789authors = serializers.SerializerMethodField() def get_authors(self,instance): authors = instance.authors.all() authors_list = [] for author in authors: authors_list.append(&#123;'name':author.name,'age':author.age&#125;) return authors_list 先定义一个列表，取出所有的作者，for循环把所有的作者用字典的形式添加到里面 source的使用： 1 可以改字段名字 xxx=serializers.CharField(source=&#39;title&#39;) 2 可以.跨表publish=serializers.CharField(source=&#39;publish.email&#39;) 3 可以执行方法pub_date=serializers.CharField(source=&#39;test&#39;) test是Book表模型中的方法 它里面默认的book.authors等","tags":[{"name":"drf","slug":"drf","permalink":"http://yoursite.com/tags/drf/"}]},{"title":"DRF CBV和APIView源码解读","date":"2018-01-04T16:00:00.000Z","path":"2018/01/05/1. DRF CBV和APIView源码解读/","text":"1. 入口点： 1234视图class Books(View): def get(self, request): return JsonResponse(back_dic) 12from django.views import Viewurl(r'^books/',views.Book.as_view()) # 类调用的方法绑定方法 12@classonlymethoddef as_view(cls, **initkwargs): 这里我们可以看到as_view上面加了一个类方法，去@classonlymethod它继承的classmethod的方法，这个重定义的类方法比classmethod更强大，Book.as_view()，调用的时候可以不用加括号 2. 请求来时 123456789101112131415@classonlymethod def as_view(cls, **initkwargs): def view(request, *args, **kwargs): # 档次请求的request,如request.method,request.POST self = cls(**initkwargs) if hasattr(self, 'get') and not hasattr(self, 'head'): self.head = self.get self.request = request self.args = args self.kwargs = kwargs return self.dispatch(request, *args, **kwargs) view.view_class = cls view.view_initkwargs = initkwargs update_wrapper(view, cls.dispatch, assigned=()) return view ​ 请求来了，路径匹配，执行函数的内存地址(request),会把当前请求的request对象当作第一个参数传过来，执行as_view的内层函数def view(),cls(**initkwargs) 实例化得到一个对象，cls就是Books对象，用反射判断有没有get这个方法，self.request = request把当前请求的request赋值到Books对象里面的request，在视图函数里print(self.request)这个request和参数里面的request是一样的，指向一个内存地址。 ​ return self.dispatch(request, *args, **kwargs),self.dispatch,self是books，所以要到当前类视图函数寻找dispatch方法，没有才去到View去找发现了dispatch方法. 1234567def dispatch(self, request, *args, **kwargs): if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed return handler(request, *args, **kwargs) request就是当次请求的request.lower()转成小写，判断视图函数里面有没有self.http_method_names这个方法，在强调一遍这里的self始终是Book对象，没有就去父类View里面找到这个方法http_method_names = [&#39;get&#39;, &#39;post&#39;, &#39;put&#39;, &#39;patch&#39;, &#39;delete&#39;, &#39;head&#39;, &#39;options&#39;, &#39;trace&#39;],反射的意思：handler=getattr(self,&#39;get&#39;),你写的Book类的get方法的内存地址,执行get(request),原理还是FBV. 提示：如何我们只接受get请求可以在视图函数里面重写http_method_names APIView源码它的原理就是通过中间件之后执行的代码 1. 入口：123456视图class BooksAPIView(APIView) def get(self,request): passurlurl(r'^books/',views.BooksAPIView.as_view()), 这里的和CBV的原理一样，但是这里的as_view,前面加了@classmethod,这里调的是APIView里面的as_view方法 1234567@classmethod def as_view(cls, **initkwargs): view = super().as_view(**initkwargs) view.cls = cls view.initkwargs = initkwargs return csrf_exempt(view) 我们看到super调用了父类(View)的as_view方法，最后还是CBV里面的内层函数，这里的view是父类类面return 返回的view，csrf_exempt：不管你有没有把中间件里面的csrf中间件去掉， 都没有csrf认证了， 2.dispatch​ 我们把目光继续跳到父类view里面，执行到dispatch里面后，先去BooksAPIView去找发现没有这个函数，就绪它继承的父类APIView里面去找，我们可以找到这个dispatch方法，没有去APIView父类（View），如果想看查找顺序用mro， 123456789101112131415161718192021222324def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs # 重新包装一个request对象，以后再用的时候就是新的request对象 request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 这个是APIView的dispatch方法，请求来了在路由匹配上执行到了view里面的内层函数，调用了dispatch，按照查找顺序就到了这里面，request = self.initialize_request(request, *args, **kwargs)这个request是当次请求的request赋值给了self.initialize_request 1234567891011121314def initialize_request(self, request, *args, **kwargs): \"\"\" Returns the initial request object. \"\"\" parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 这个代码先忽略掉，self.initialize_request(request, *args, **kwargs)的request是当次请求的request， request = self.initialize_request，这个request是一个新的request对象，self.request = request把这个新的request赋值给了当前类的 request,视图函数里面的request已经不是django原生的request，是drf中间定义的request对象，我们导入from rest_framework.request import Request查看到， 123class BooksAPIView(APIView) def get(self,request): print(request.data) 验证：原生的request里面没有data这个属性，这个是drf的request的data属性。 3.drf的Request类3.1 原生request的封装上面我们执行到request = self.initialize_request(request, *args, **kwargs)的self调用 initialize_request这个方法，到视图类里面去找没有，再到APIView里面找到了initialize_request这个方法 12345678910111213def initialize_request(self, request, *args, **kwargs): \"\"\" Returns the initial request object. \"\"\" parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 这里return 一个Request对象，里面有一个原生的request对象，原生的request对象被封装到了Request 1234567891011121314151617181920212223242526272829303132333435363738394041class Request: \"\"\" Wrapper allowing to enhance a standard `HttpRequest` instance. Kwargs: - request(HttpRequest). The original request instance. - parsers_classes(list/tuple). The parsers to use for parsing the request content. - authentication_classes(list/tuple). The authentications used to try authenticating the request's user. \"\"\" def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( 'The `request` argument must be an instance of ' '`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.' .format(request.__class__.__module__, request.__class__.__name__) ) self._request = request self.parsers = parsers or () self.authenticators = authenticators or () self.negotiator = negotiator or self._default_negotiator() self.parser_context = parser_context self._data = Empty self._files = Empty self._full_data = Empty self._content_type = Empty self._stream = Empty if self.parser_context is None: self.parser_context = &#123;&#125; self.parser_context['request'] = self self.parser_context['encoding'] = request.encoding or settings.DEFAULT_CHARSET force_user = getattr(request, '_force_auth_user', None) force_token = getattr(request, '_force_auth_token', None) if force_user is not None or force_token is not None: forced_auth = ForcedAuthentication(force_user, force_token) self.authenticators = (forced_auth,) self._request = request在这里是原生的request对象，被包装到class Request可以用from rest_framwork.request import Request 3.2 原生method ，request.data，request.query_params123视图函数print(request.method)return HttpResponse('ok') 当我们打印的时候为什么还能打印出原来request对象的属性呢，这个是点拦截属性， 魔法语法， 点的时候会调用__getattr__ 这个是Request重新写了这个方法 123456def __getattr__(self, attr): try: return getattr(self._request, attr) except AttributeError: return self.__getattribute__(attr) 通过反射如果取method这个方法，到self._request去取出来的，如果有异常通过下面的方式取，以后是由request对象就像使用之前的request对象一样的，其实就是通过魔法方法，让你发现跟原来的一样，没有发觉。 1print(request.data),这个是方法，@property修饰了 源码：request.data 12345@property def data(self): if not _hasattr(self, '_full_data'): self._load_data_and_files() return self._full_data 我们我们一直按照_full_data点下去，其实就是一个字典，不管使用了什么方式，什么编码传过来的数据都在request.data 12345def post(self,request): print(request.data) return HttpResponse('OK') urlencoded:&lt;QueryDict: &#123;'name': ['aaaa'], 'age': ['111']&#125;&gt; json:&#123;'name': 'zzz', 'age': 333&#125; 我们发现返回的是一个QueryDict我们导入模块看一下from django.http import QueryDict 12345class QueryDict(MultiValueDict): def copy(self): \"\"\"Returns a mutable copy of this object.\"\"\" return self.__deepcopy__(&#123;&#125;) 它继承了字典，但是不能改，但是它copy一遍在修改 get请求传过来的数据 12request.GET这个能取出来，在Request又写了一个print(request.query_params)在get请求，地址参数里 123456@property def query_params(self): \"\"\" More semantically correct name for request.GET. \"\"\" return self._request.GET 这样写是为了符合rest_framwork的规范，文件也是一样重写了 好我们收回，把思路跳到我们查询请求的方式APIView里面的dispatch 123456789101112131415161718192021try: # 三大认证模块 self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed # 响应模块 response = handler(request, *args, **kwargs) except Exception as exc: # 异常模块 response = self.handle_exception(exc) # 渲染模块 self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 这里的异常处理无论出现什么错误，返回的都是json格式的错误。","tags":[{"name":"drf","slug":"drf","permalink":"http://yoursite.com/tags/drf/"}]},{"title":"RESTful十大规范","date":"2018-01-03T16:00:00.000Z","path":"2018/01/04/0 RESTful十大规范/","text":"一 什么是RESTful REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移” REST从资源的角度类审视整个网络，它将分布在网络中某个节点的资源通过URL进行标识，客户端应用通过URL来获取资源的表征，获得这些表征致使这些应用转变状态 REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移” 所有的数据，不过是通过网络获取的还是操作（增删改查）的数据，都是资源，将一切数据视为资源是REST区别与其他架构风格的最本质属性 对于REST这种面向资源的架构风格，有人提出一种全新的结构理念，即：面向资源架构（ROA：Resource Oriented Architecture） 二 RESTful API设计 API与用户的通信协议，总是使用[HTTPs协议] 域名 https://api.example.com 尽量将API部署在专用域名（会存在跨域问题） https://example.org/api/ API很简单 版本 URL，如：https://api.example.com/v1/ 请求头 跨域时，引发发送多次请求 路径，视网络上任何东西都是资源，均使用名词表示（可复数） https://api.example.com/v1/zoos https://api.example.com/v1/animals https://api.example.com/v1/employees method GET ：从服务器取出资源（一项或多项） POST ：在服务器新建一个资源 PUT ：在服务器更新资源（客户端提供改变后的完整资源） PATCH ：在服务器更新资源（客户端提供改变的属性） DELETE ：从服务器删除资源 过滤，通过在url上传参的形式传递搜索条件 https://api.example.com/v1/zoos?limit=10：指定返回记录的数量 https://api.example.com/v1/zoos?offset=10：指定返回记录的开始位置 https://api.example.com/v1/zoos?page=2&amp;per_page=100：指定第几页，以及每页的记录数 https://api.example.com/v1/zoos?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序 https://api.example.com/v1/zoos?animal_type_id=1：指定筛选条件 状态码 1234567891011121314200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST&#x2F;PUT&#x2F;PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST&#x2F;PUT&#x2F;PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST&#x2F;PUT&#x2F;PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。更多看这里：http:&#x2F;&#x2F;www.w3.org&#x2F;Protocols&#x2F;rfc2616&#x2F;rfc2616-sec10.html 错误处理，应返回错误信息，error当做key。 ``\"Invalid API key\"&#125;```123456789- 返回结果，针对不同操作，服务器向用户返回的结果应该符合以下规范。 &#96;&#96;&#96; pythonGET &#x2F;collection：返回资源对象的列表（数组）GET &#x2F;collection&#x2F;resource：返回单个资源对象POST &#x2F;collection：返回新生成的资源对象PUT &#x2F;collection&#x2F;resource：返回完整的资源对象PATCH &#x2F;collection&#x2F;resource：返回完整的资源对象DELETE &#x2F;collection&#x2F;resource：返回一个空文档 Hypermedia API，RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 123456&#123;\"link\": &#123; \"rel\": \"collection https://www.example.com/zoos\", \"href\": \"https://api.example.com/zoos\", \"title\": \"List of zoos\", \"type\": \"application/vnd.yourformat+json\"&#125;&#125; 基于django实现路由系统 12345urlpatterns = [ url(r'^users/$', views.Users.as_view()), url(r'^users2/$', views.user2),] 视图函数 123456789101112131415161718import jsondef user2(request): if request.method=='GET': dic = &#123;'status':200,'name': 'lqz2', 'age': 18&#125; return HttpResponse(json.dumps(dic)) elif request.method=='POST': dic = &#123;'status': 200, 'msg': '修改成功'&#125; return JsonResponse(dic)class Users(View): def get(self, request): dic = &#123;'status':200,'name': 'lqz', 'age': 18&#125; return HttpResponse(json.dumps(dic)) def post(self, request): dic = &#123;'status': 200, 'msg': '修改成功'&#125; return JsonResponse(dic)","tags":[{"name":"drf","slug":"drf","permalink":"http://yoursite.com/tags/drf/"}]},{"title":"python常用模块","date":"2017-10-13T16:00:00.000Z","path":"2017/10/14/20 常用模块/","text":"time和datatime模块time 1234567import time#--------------------------我们先以当前时间为准,让大家快速认识三种形式的时间print(time.time()) # 时间戳:1487130156.419527print(time.strftime(\"%Y-%m-%d %X\")) #格式化的时间字符串:'2017-02-15 11:40:53'print(time.localtime()) #本地时区的struct_timeprint(time.gmtime()) #UTC时区的struct_time 12345678format string---&gt;struct_time---&gt;timestampstruct_time=time.strptime('1988-03-03 11:11:11','%Y-%m-%d %H:%M:%S')timestamp=time.mktime(struct_time)+7*86400print(timestamp)format string&lt;---struct_time&lt;---timestampres=time.strftime('%Y-%m-%d %X',time.localtime(timestamp))print(res) datatime 12345print(datetime.datetime.now() )print(datetime.datetime.now() + datetime.timedelta(3)) #当前时间+3天print(datetime.datetime.now() + datetime.timedelta(-3)) #当前时间-3天print(datetime.datetime.now() + datetime.timedelta(hours=3)) #当前时间+3小时print(datetime.datetime.now() + datetime.timedelta(minutes=30)) #当前时间+30分 random123456789101112131415161718import random random.random()#(0,1)----float 大于0且小于1之间的小数 random.randint(1,3) #[1,3] 大于等于1且小于等于3之间的整数 random.randrange(1,3) #[1,3) 大于等于1且小于3之间的整数 random.choice([1,'23',[4,5]])#1或者23或者[4,5] random.sample([1,'23',[4,5]],2)#列表元素任意2个组合 print(random.uniform(1,3))#大于1小于3的小数，如1.927109612082716 item=[1,3,5,7,9]random.shuffle(item) #打乱item的顺序,相当于\"洗牌\"print(item) 案例随机生成验证码 12345678910import randomdef make_code(n): res='' for i in range(n): s1=chr(random.randint(65,90)) s2=str(random.randint(0,9)) res+=random.choice([s1,s2]) return resprint(make_code(9)) os模块os模块是与操作系统交互的一个接口 123456789101112131415161718192021222324252627282930os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径os.chdir(\"dirname\") 改变当前脚本工作目录；相当于shell下cdos.curdir 返回当前目录: ('.')os.pardir 获取当前目录的父目录字符串名：('..')os.makedirs('dirname1/dirname2') 可生成多层递归目录os.removedirs('dirname1') 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推os.mkdir('dirname') 生成单级目录；相当于shell中mkdir dirnameos.rmdir('dirname') 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirnameos.listdir('dirname') 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印os.remove() 删除一个文件os.rename(\"oldname\",\"newname\") 重命名文件/目录os.stat('path/filename') 获取文件/目录信息os.sep 输出操作系统特定的路径分隔符，win下为\"\\\\\",Linux下为\"/\"os.linesep 输出当前平台使用的行终止符，win下为\"\\t\\n\",Linux下为\"\\n\"os.pathsep 输出用于分割文件路径的字符串 win下为;,Linux下为:os.name 输出字符串指示当前使用平台。win-&gt;'nt'; Linux-&gt;'posix'os.system(\"bash command\") 运行shell命令，直接显示os.environ 获取系统环境变量os.path.abspath(path) 返回path规范化的绝对路径os.path.split(path) 将path分割成目录和文件名二元组返回os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素os.path.exists(path) 如果path存在，返回True；如果path不存在，返回Falseos.path.isabs(path) 如果path是绝对路径，返回Trueos.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回Falseos.path.isdir(path) 如果path是一个存在的目录，则返回True。否则返回Falseos.path.join(path1[, path2[, ...]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略os.path.getatime(path) 返回path所指向的文件或者目录的最后存取时间os.path.getmtime(path) 返回path所指向的文件或者目录的最后修改时间os.path.getsize(path) 返回path的大小 我们常用的类型 12345678910111213141516171819202122232425262728293031323334353637383940os.remove() 删除一个文件os.rename(\"oldname\",\"newname\") 重命名文件/目录应用程序----》\"ls /\"os.system(\"ls /\")规定：key与value必须都为字符串os.environ['aaaaaaaaaa']='111'print(os.environ)print(os.path.dirname(r'/a/b/c/d.txt')) # /a/b/cprint(os.path.basename(r'/a/b/c/d.txt')) # d.txtprint(os.path.isfile(r'笔记.txt')) # Falseprint(os.path.isdir(r'aaa'))# Falseprint(os.path.join('a','/','b','c','d'))# 拼接# 获取根目录BASE_DIR=os.path.dirname(os.path.dirname(__file__))print(BASE_DIR)# 在python3.5之后，推出了一个新的模块pathlibfrom pathlib import Pathres = Path(__file__).parent.parentprint(res)res=Path('/a/b/c') / 'd/e.txt'print(res)print(res.resolve()) sys模块12345671 sys.argv 命令行参数List，第一个元素是程序本身路径2 sys.exit(n) 退出程序，正常退出时exit(0)3 sys.version 获取Python解释程序的版本信息4 sys.maxint 最大的Int值5 sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值6 sys.platform 返回操作系统平台名称 1234567891011121314151617181920import timedef progress(percent): if percent &gt; 1: percent = 1 res = int(50 * percent) * '#' print('\\r[%-50s] %d%%' % (res, int(100 * percent)), end='')recv_size=0total_size=1025011 time.sleep(0.01) # 下载了1024个字节的数据 recv_size+=1024 # recv_size=2048 # 打印进度条 # print(recv_size) percent = recv_size / total_size # 1024 / 333333 progress(percent) json和pickle序列化&amp;反序列化内存中的数据类型—-&gt;序列化—-&gt;特定的格式（json格式或者pickle格式）内存中的数据类型&lt;—-反序列化&lt;—-特定的格式（json格式或者pickle格式）为何要序列化 序列化得到结果=&gt;特定的格式的内容有两种用途 1、可用于存储=》用于存档 2、传输给其他平台使用=》跨平台数据交互 python java 列表 特定的格式 数组 强调： 针对用途1的特定一格式：可是一种专用的格式=》pickle只有python可以识别 针对用途2的特定一格式：应该是一种通用、能够被所有语言识别的格式=》json 如何序列化与反序列化 12345678import json序列化json_res=json.dumps([1,'aaa',True,False])print(json_res,type(json_res)) # \"[1, \"aaa\", true, false]\"反序列化l=json.loads(json_res)print(l,type(l)) 12345678910import json将序列化的结果写入文件的简单方法with open('test.json',mode='wt',encoding='utf-8') as f: json.dump([1,'aaa',True,False],f)从文件读取json格式的字符串进行反序列化操作的简单方法with open('test.json',mode='rt',encoding='utf-8') as f: l=json.load(f) print(l,type(l)) json验证: json格式兼容的是所有语言通用的数据类型，不能识别某一语言的所独有的类型json.dumps({1,2,3,4,5}) json强调：一定要搞清楚json格式，不要与python混淆l=json.loads(‘[1, “aaa”, true, false]’)l=json.loads(“[1,1.3,true,’aaa’, true, false]”)print(l[0]) 猴子补丁在入口处打猴子补丁 12345678910import jsonimport ujsondef monkey_patch_json(): json.__name__ = 'ujson' json.dumps = ujson.dumps json.loads = ujson.loadsmonkey_patch_json() # 在入口文件出运行 pickle模块 123456import pickleres=pickle.dumps(&#123;1,2,3,4,5&#125;)print(res,type(res))s=pickle.loads(res)print(s,type(s)) configparser1234567891011121314151617181920212223242526#text.ini[section1]k1 = v1k2:v2user=egonage=18is_admin=truesalary=31[section2]k1 = v1#a.pyimport configparserconfig=configparser.ConfigParser()config.read('text.ini')print(config.options('section1'))print(config.items('section1'))print(config.get('section1','user'))print(config.getint('section1','age'))print(config.getfloat('section1','salary'))#['k1', 'k2', 'user', 'age', 'is_admin', 'salary'][('k1', 'v1'), ('k2', 'v2'), ('user', 'egon'), ('age', '18'), ('is_admin', 'true'), ('salary', '31')]egon1831.0 hashlibhash算法，该算法接受传入的内容，经过运算得到一串hash值hash值的特点：I 只要传入的内容一样，得到的hash值必然一样II 不能由hash值返解成内容III 不管传入的内容有多大，只要使用的hash算法不变，得到的hash值长度是一定 2、hash的用途用途1：特点II用于密码密文传输与验证用途2：特点I、III用于文件完整性校验 123456m=hashlib.md5()m.update('hello'.encode('utf-8'))m.update('world'.encode('utf-8'))res=m.hexdigest() # 'helloworld'print(res)#fc5e038d38a57032085441e7fe7010b0 12345678910# 提升撞库的成本=&gt;密码加盐import hashlibm=hashlib.md5()m.update('天王'.encode('utf-8'))m.update('alex3714'.encode('utf-8'))m.update('盖地虎'.encode('utf-8'))print(m.hexdigest()) subprocess 管道12345678910111213import subprocessobj=subprocess.Popen('echo 123 ; ls / ; ls /root',shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, )print(obj)res=obj.stdout.read()print(res.decode('utf-8'))err_res=obj.stderr.read()print(err_res.decode('utf-8')) logging 模块1.1 logging模块的基本配置 123456789101112131415161718192021222324252627import logginglogging.basicConfig( # 1、日志输出位置：1、终端 2、文件 filename='access.log', # 不指定，默认打印到终端 # 2、日志格式 format='%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s', # 3、时间格式 datefmt='%Y-%m-%d %H:%M:%S %p', # 4、日志级别 # critical =&gt; 50 # error =&gt; 40 # warning =&gt; 30 # info =&gt; 20 # debug =&gt; 10 level=10,)logging.debug('调试debug') # 10logging.info('消息info') # 20logging.warning('警告warn')# 30logging.error('egon提现失败') # 40logging.critical('严重critical') # 50 1.2 日志配置字典1.2.1 定义三种日志输出格式，日志中可能用到的格式化串如下 123456789101112131415%(name)s Logger的名字%(levelno)s 数字形式的日志级别%(levelname)s 文本形式的日志级别%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有%(filename)s 调用日志输出函数的模块的文件名%(module)s 调用日志输出函数的模块名%(funcName)s 调用日志输出函数的函数名%(lineno)d 调用日志输出函数的语句所在的代码行%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒%(thread)d 线程ID。可能没有%(threadName)s 线程名。可能没有%(process)d 进程ID。可能没有%(message)s用户输出的消息 1.2.2 强调：其中的%(name)s为getlogger时指定的名字 123456standard_format = '%(asctime)s - %(threadName)s:%(thread)d - 日志名字:%(name)s - %(filename)s:%(lineno)d -' \\ '%(levelname)s - %(message)s'simple_format = '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s'test_format = '%(asctime)s] %(message)s' 1.2.3 日志配置字典 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071LOGGING_DIC = &#123; 'version': 1, 'disable_existing_loggers': False, 'formatters': &#123; 'standard': &#123; 'format': standard_format &#125;, 'simple': &#123; 'format': simple_format &#125;, 'test': &#123; 'format': test_format &#125;, &#125;, 'filters': &#123;&#125;, # handlers是日志的接收者，不同的handler会将日志输出到不同的位置 'handlers': &#123; #打印到终端的日志 'console': &#123; 'level': 'DEBUG', 'class': 'logging.StreamHandler', # 打印到屏幕 'formatter': 'simple' &#125;, 'default': &#123; 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件 # 'maxBytes': 1024*1024*5, # 日志大小 5M 'maxBytes': 1000, 'backupCount': 5, 'filename': 'a1.log', # os.path.join(os.path.dirname(os.path.dirname(__file__)),'log','a2.log') 'encoding': 'utf-8', 'formatter': 'standard', &#125;, #打印到文件的日志,收集info及以上的日志 'other': &#123; 'level': 'DEBUG', 'class': 'logging.FileHandler', # 保存到文件 'filename': 'a2.log', # os.path.join(os.path.dirname(os.path.dirname(__file__)),'log','a2.log') 'encoding': 'utf-8', 'formatter': 'test', &#125;, &#125;, # loggers是日志的产生者，产生的日志会传递给handler然后控制输出 'loggers': &#123; #logging.getLogger(__name__)拿到的logger配置 'kkk': &#123; 'handlers': ['console','other'], # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕 'level': 'DEBUG', # loggers(第一层日志级别关限制)---&gt;handlers(第二层日志级别关卡限制) 'propagate': False, # 默认为True，向上（更高level的logger）传递，通常设置为False即可，否则会一份日志向上层层传递 &#125;, '终端提示': &#123; 'handlers': ['console',], # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕 'level': 'DEBUG', # loggers(第一层日志级别关限制)---&gt;handlers(第二层日志级别关卡限制) 'propagate': False, # 默认为True，向上（更高level的logger）传递，通常设置为False即可，否则会一份日志向上层层传递 &#125;, '': &#123; 'handlers': ['default', ], # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕 'level': 'DEBUG', # loggers(第一层日志级别关限制)---&gt;handlers(第二层日志级别关卡限制) 'propagate': False, # 默认为True，向上（更高level的logger）传递，通常设置为False即可，否则会一份日志向上层层传递 &#125;, &#125;,&#125; 1.2.3 产生日志文件接下来要做的是：拿到日志的产生者即loggers来产生日志第一个日志的产生者：kkk第二个日志的产生者：bbb 但是需要先导入日志配置字典LOGGING_DIC 1234567891011121314151617import settingsfrom logging import config,getLoggerconfig.dictConfig(settings.LOGGING_DIC)logger1=getLogger('kkk')logger1.info('这是一条info日志')logger2=getLogger('终端提示')logger2.info('logger2产生的info日志')logger3=getLogger('用户交易')logger3.info('logger3产生的info日志')logger4=getLogger('用户常规')logger4.info('logger4产生的info日志') 补充两个重要额知识1)日志名的命名日志名是区别日志业务归属的一种非常重要的标识 2)日志轮转日志记录着程序员运行过程中的关键信息 正则表达式(re模块)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import reprint(re.findall('\\w','aAbc123_*()-='))print(re.findall('\\W','aAbc123_*()-= '))print(re.findall('\\s','aA\\rbc\\t\\n12\\f3_*()-= '))print(re.findall('\\S','aA\\rbc\\t\\n12\\f3_*()-= '))print(re.findall('\\d','aA\\rbc\\t\\n12\\f3_*()-= '))print(re.findall('\\D','aA\\rbc\\t\\n12\\f3_*()-= '))print(re.findall('\\D','aA\\rbc\\t\\n12\\f3_*()-= '))print(re.findall('\\Aalex',' alexis alex sb')) alexprint(re.findall('sb\\Z',' alexis alexsb sb')) sb\\Zprint(re.findall('sb\\Z',\"\"\"alexalexisalexsb\"\"\"))print(re.findall('^alex','alexis alex sb'))print(re.findall('sb$','alexis alex sb'))print(re.findall('sb$',\"\"\"alexalexisalexsb\"\"\"))print(re.findall('^alex$','alexis alex sb'))print(re.findall('^alex$','al ex'))print(re.findall('^alex$','alex'))重复匹配：| . | * | ? | .* | .*? | + | &#123;n,m&#125; |1、.:匹配除了\\n之外任意一个字符，指定re.DOTALL之后才能匹配换行符print(re.findall('a.b','a1b a2b a b abbbb a\\nb a\\tb a*b')) a.b['a1b','a2b','a b','abb','a\\tb','a*b']print(re.findall('a.b','a1b a2b a b abbbb a\\nb a\\tb a*b',re.DOTALL))2、*：左侧字符重复0次或无穷次，性格贪婪print(re.findall('ab*','a ab abb abbbbbbbb bbbbbbbb')) ab*['a','ab','abb','abbbbbbbb']3、+：左侧字符重复1次或无穷次，性格贪婪print(re.findall('ab+','a ab abb abbbbbbbb bbbbbbbb')) ab+4、？：左侧字符重复0次或1次，性格贪婪print(re.findall('ab?','a ab abb abbbbbbbb bbbbbbbb')) ab?['a','ab','ab','ab']5、&#123;n,m&#125;：左侧字符重复n次到m次，性格贪婪&#123;0,&#125; =&gt; *&#123;1,&#125; =&gt; +&#123;0,1&#125; =&gt; ?&#123;n&#125;单独一个n代表只出现n次，多一次不行少一次也不行print(re.findall('ab&#123;2,5&#125;','a ab abb abbb abbbb abbbbbbbb bbbbbbbb')) ab&#123;2,5&#125;['abb','abbb','abbbb','abbbbb]print(re.findall('\\d+\\.?\\d*',\"asdfasdf123as1111111.123dfa12adsf1asdf3\")) \\d+\\.?\\d* \\d+\\.?\\d+[]匹配指定字符一个print(re.findall('a\\db','a1111111b a3b a4b a9b aXb a b a\\nb',re.DOTALL))print(re.findall('a[501234]b','a1111111b a3b a4b a9b aXb a b a\\nb',re.DOTALL))print(re.findall('a[0-5]b','a1111111b a3b a1b a0b a4b a9b aXb a b a\\nb',re.DOTALL))print(re.findall('a[0-9a-zA-Z]b','a1111111b axb a3b a1b a0b a4b a9b aXb a b a\\nb',re.DOTALL))print(re.findall('a[^0-9a-zA-Z]b','a1111111b axb a3b a1b a0b a4b a9b aXb a b a\\nb',re.DOTALL))print(re.findall('a-b','a-b aXb a b a\\nb',re.DOTALL))print(re.findall('a[-0-9\\n]b','a-b a0b a1b a8b aXb a b a\\nb',re.DOTALL))","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python模块","date":"2017-10-12T16:00:00.000Z","path":"2017/10/13/17 模块/","text":"1. 什么是模块？模块就是一系列功能的集合体, 分为三大类 I：内置的模块 II：第三方的模块 III：自定义的模块一个python文件本身就一个模块，文件名m.py，模块名叫m ps：模块有四种形式 *使用python编写的.py文件 *已被编译为共享库或DLL的C或C + +扩展 *把一系列模块组织到一起的文件夹（注：文件夹下有一个init.py文件，该文件夹称之为包） *使用C编写并链接到python解释器的内置模块 2、为何有用模块I: 内置与第三的模块拿来就用，无需定义，这种拿来主义，可以极大地提升自己的开发效率II: 自定义的模块可以将程序的各部分功能提取出来放到一模块中为大家共享使用好处是减少了代码冗余，程序组织结构更加清晰 3、如何用模块123y=333z=444import foo 首次导入模块会发生3件事 执行foo.py 产生foo.py的名称空间，将foo.py运行过程中产生的名字都丢到foo的名称空间中 在当前文件中产生的有一个名字foo，该名字指向2中产生的名称空间 之后的导入，都是直接引用首次导入产生的foo.py名称空间,不会重复执行代码 引用：print(foo.change)强调1：模块名.名字，是指名道姓地问某一个模块要名字对应的值，不会与当前名称空间中的名字发生冲突x=1111111111111print(foo.x) 强调2：无论是查看还是修改操作的都是模块本身，与调用位置无关 12345678910import foox=3333333333foo.get()foo.change()print(x)print(foo.x)foo.get() 可以以逗号为分隔符在一行导入多个模块建议如下所示导入多个模块import timeimport fooimport m 不建议在一行同时导入多个模块import time,foo,m 导入模块的规范I. python内置模块II. 第三方模块III. 程序员自定义模块 import timeimport 第三方1 import 自定义模块1 import 。。。 as 。。。 12345import foo as f # f=foof.get()import a as mm.f1 模块是第一类对象import foo 自定义模块的命名应该采用纯小写+下划线的风格 可以在函数内导入模块def func():import foo 4. 循环导入循环导入就是模块1加载/导入2模块，2模块加载/导入3模块，3模块加载/导入模块，这就是循环导入的问题，由于第一个模块尚未加载完毕，所以引用失败、抛出异常，究其根源就是在python中，同一个模块只会在第一次导入时执行其内部代码，再次导入该模块时，即便是该模块尚未完全加载完毕也不会去重复执行内部代码下面例子： 123456789101112131415161718192021222324# m1.pyfrom mmm.m2 import f2def f1(): print('去你妈的 ') #m2.pyfrom mmm.m3 import f3def f2(): print('去你妈的1') #m3.pyfrom mmm.m1 import f1def f3(): print('去你妈的2') #run.pyimport m1当我们执行run.py的时候就会报错，先执行run.py---&gt;执行import m1，开始导入m1并运行其内部代码---&gt;打印内容\"去你妈的\"---&gt;执行from m2 import f2 开始导入m2并运行其内部代码---&gt;打印内容“去你妈的1”---&gt;执行from m1 import f1,由于m1已经被导入过了，所以不会重新导入，所以直接去m1中拿f1，然而x此时并没有存在于m1中，所以报错 这样的问题我们要如何解决呢，我们可以把导入的模块放到函数里面去，这样的话，就只能在家引用或者把变量放在引用模块的开头 5. 搜索模块的路径与优先级一个python文件有两种用途 被当成程序运行 被当做模块导入 无论是import还是from…import在导入模块时都涉及到查找问题优先级： 内存（内置模块） 硬盘：按照sys.path中存放的文件的顺序依次查找要导入的模块 在导入一个模块时，如果该模块已加载到内存中，则直接引用，否则会优先查找内置模块，然后按照从左到右的顺序依次检索sys.path中定义的路径，直到找模块对应的文件为止，否则抛出异常。sys.path也被称为模块的搜索路径，它是一个列表类型 12345678import syssys.path()## sys.path中的第一个路径通常为空，代表执行文件所在的路径，所以在被导入模块与执行文件在同一目录下时肯定是可以正常导入的，而针对被导入的模块与执行文件在不同路径下的情况，为了确保模块对应的源文件仍可以被找到，需要将源文件foo.py所在的路径添加到sys.path中，假设foo.py所在的路径为/pythoner/projects/import syssys.path.append(r'/pythoner/projects/') #也可以使用sys.path.insert(……)import foo #无论foo.py在何处,我们都可以导入它了 6. 区分py文件的两种用途一个Python文件有两种用途，一种被当主程序/脚本执行，另一种被当模块导入，为了区别同一个文件的不同用途，每个py文件都内置了name变量，该变量在py文件被当做脚本执行时赋值为“main”,在py文件被当做模块导入时赋值为模块名 123456#foo.py...if __name__ == '__main__': foo.py被当做脚本执行时运行的代码else: foo.py被当做模块导入时运行的代码","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python包","date":"2017-10-12T16:00:00.000Z","path":"2017/10/13/18 包/","text":"1 .什么是包包就是相当于一个模块，然后去使用1、包就是一个包含有init.py文件的文件夹，2、为何要有包 包的本质是模块的模块的一种形式，包是用来被当做模块导入 2. 包的使用 当我们使用包的时候，会产生一个名称空间， 运行包下的init.py文件，将运行过程中产生的名字都丢到1的名称空间中 在当前执行文件的名称空间中拿到一个名字mmm，mmm指向1的名称空间123456import mmmprint(mmm.x)print(mmm.y)mmm.say()from mmm import x 3. 绝对导入与相对导入绝对导入：以顶级包为起始1from pool import versions 相对导入：.代表当前文件所在的目录，..代表当前目录的上一级目录，依此类推1from . import versions 针对包内部模块之间的相互导入推荐使用相对导入，需要特别强调： 相对导入只能在包内部使用，用相对导入不同目录下的模块是非法的 无论是import还是from-import，但凡是在导入时带点的，点的左边必须是包,否则语法错误 4. 环境变量是以执行文件为准备的，所有的被导入的模块或者说后续的其他文件引用的sys.path都是参照执行文件的sys.path 1234import syssys.path.append('/aa')print(sys.path)sys.path.append(r'/Users/linhaifeng/PycharmProjects/s14/day21/aa') 但是我们使用的时候是绝对路径是静态的，当我们给别人使用的时候呢，我们要把它设置成动态的，方便别人使用 12345678910111213141516171819202122232425# 绝对导入======&gt;sys.path====&gt;执行文件import syssys.path.append(r'/Users/linhaifeng/PycharmProjects/s14/day21/ATM')from conf import settingsfrom core import srcprint(settings)print(src)from core import srcsrc.run()from core.src import runrun()# 优化方案import osimport sys# print(__file__) # 当前文件的绝对路径BASE_DIR=os.path.dirname(os.path.dirname(__file__))sys.path.append(BASE_DIR)from core import src","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"软件开发目录规范","date":"2017-10-12T16:00:00.000Z","path":"2017/10/13/19 软件开发目录规范/","text":"一 软件开发目录规范 123456789101112131415161718192021- bin - start --&gt; 启动软件入口- conf - settings.py 配置文件 - 比如存放一些固定的路径- core - src 核心业务逻辑代码- db ---&gt; 用于存放数据文件与操作数据的代码文件 - db_file ---&gt; db.txt ... - db_handler.py ---&gt; 操作数据的代码- lib - common: 存放公共的功能 - 比如存放 装饰器- log - log.txt 存放日志的文件 二 一个项目开发前，有一份开发文档 项目: 编写小说阅读程序实现下属功能 一：程序运行开始时显示 0 账号注册 1 账号登录 2 充值功能 3 阅读小说 二： 针对文件db.txt，内容格式为：&quot;用户名:密码:金额&quot;,完成下述功能 2.1、账号注册 2.2、账号登录 2.3、充值功能 三：文件story_class.txt存放类别与小说文件路径，如下,读出来后可用eval反解出字典 { &quot;0&quot;:{ &quot;0&quot;:[&quot;倚天屠狗记.txt&quot;,3], &quot;1&quot;:[&quot;沙雕英雄转.txt&quot;,10] }, &quot;1&quot;:{ &quot;0&quot;:[&quot;令人羞耻的爱.txt&quot;,6], &quot;1&quot;:[&quot;二狗的妻子与大草原的故事.txt&quot;,5] }, } 3.1、用户登录成功后显示如下内容，根据用户选择，显示对应品类的小说编号、小说名字、以及小说的价格 &quot;&quot;&quot; 0 玄幻武侠 1 都市爱情 2 高效养猪36技 &quot;&quot;&quot; 3.2、用户输入具体的小说编号，提示是否付费，用户输入y确定后，扣费并显示小说内容，如果余额不足则提示余额不足 四：为功能2.2、3.1、3.2编写认证功能装饰器，要求必须登录后才能执行操作 五：为功能2.2、3.2编写记录日志的装饰器，日志格式为：&quot;时间 用户名 操作(充值or消费) 金额&quot;1、软件定位，软件的基本功能； 2、运行代码的方法: 安装环境、启动命令等； 3、简要的使用说明； 4、代码目录结构说明，更详细点可以说明软件的基本原理； 5、常见问题说明。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python面向编程和函数式","date":"2017-10-10T16:00:00.000Z","path":"2017/10/11/16 面向编程和函数式/","text":"1.编程思想/范式面向过程的编程思想： 核心是”过程”二字，过程即流程，指的是做事的步骤：先什么、再什么、后干什么 基于该思想编写程序就好比在设计一条流水线 优点：复杂的问题流程化、进而简单化缺点：扩展性非常差 面向过程的编程思想应用场景解析： 不是所有的软件都需要频繁更迭：比如编写脚本 即便是一个软件需要频繁更迭，也不并不代表这个软件所有的组成部分都需要一起更迭 2. 函数式 def用于定义有名函数func=函数的内存地址123def func(x,y): return x+yprint(func) lamdab用于定义匿名函数1print(lambda x,y:x+y) 调用匿名函数12res=(lambda x,y:x+y)(1,2)print(res) 匿名用于临时调用一次的场景：更多的是将匿名与其他函数配合使用salaries={ ‘siry’:3000, ‘tom’:7000, ‘lili’:10000, ‘jack’:2000}需求1：找出薪资最高的那个人=》lili123456789101112131415161718192021res=max([3,200,11,300,399])print(res)res=max(salaries)print(res)salaries=&#123; 'siry':3000, 'tom':7000, 'lili':10000, 'jack':2000&#125;迭代出的内容 比较的值'siry' 3000'tom' 7000'lili' 10000'jack' 2000def func(k): return salaries[k] ==========max的应用==============12345res=max(salaries,key=func) # 返回值=func('siry')print(res)res=max(salaries,key=lambda k:salaries[k])print(res) ==========min的应用==============123res=min(salaries,key=lambda k:salaries[k])print(res) ==========sorted排序==============12345678salaries=&#123; 'siry':3000, 'tom':7000, 'lili':10000, 'jack':2000&#125;res=sorted(salaries,key=lambda k:salaries[k],reverse=True)print(res) ==========map的应用(了解)==============123456l=['alex','lxx','wxx','']new_l=(name+'_dsb' for name in l)print(new_l)res=map(lambda name:name+'_dsb',l)print(res) # 生成器 ==========filter的应用（了解）==============123456l=['alex_sb','lxx_sb','wxx','薛贤妻']res=(name for name in l if name.endswith('sb'))print(res)res=filter(lambda name:name.endswith('sb'),l)print(res) ==========reduce的应用(了解)==============123456from functools import reduceres=reduce(lambda x,y:x+y,[1,2,3],10) # 16print(res)res=reduce(lambda x,y:x+y,['a','b','c']) # 'a','b'print(res)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python函数递归","date":"2017-10-10T16:00:00.000Z","path":"2017/10/11/15 函数递归/","text":"什么是递归函数的递归调用：是函数嵌套调用的一种特殊形式具体是指：在调用一个函数的过程中又直接或者间接地调用到本身直接调用本身 1234def f1(): print('是我是我还是我') f1()f1() 间接调用： 123456789def f1(): print('===&gt;f1') f2()def f2(): print('===&gt;f2') f1()f1() 归的本质就是循环:递归调用不应该无限地调用下去，必须在满足某种条件下结束递归调用 2.递归的应用1234567891011l=[1,2,[3,[4,[5,[6,[7,[8,[9,10,11,[12,[13,]]]]]]]]]]def f1(list1): for x in list1: if type(x) is list: # 如果是列表，应该再循环、再判断,即重新运行本身的代码 f1(x) else: print(x)f1(l) 12345678def age(n): if n == 1: return 18 return age(n-1) + 10res=age(5)print(res)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python迭代器和生成器","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/14 迭代器和生成器/","text":"1.迭代器迭代器指的是迭代取值的工具，迭代是一个重复的过程，每次重复都是基于上一次的结果而继续的，单纯的重复并不是迭代迭代器是用来迭代取值的工具，而涉及到把多个值循环取出来的类型有：列表、字符串、元组、字典、集合、打开文件 123456789l=['egon','liu','alex']i=0while i &lt; len(l): print(l[i]) i+=1 上述迭代取值的方式只适用于有索引的数据类型：列表、字符串、元组为了解决基于索引迭代器取值的局限性python必须提供一种能够不依赖于索引的取值方式，这就是迭代器 1.1迭代器的使用可迭代的对象：但凡内置有iter方法的都称之为可迭代的对象调用可迭代对象下的iter方法会将其转换成迭代器对象 1234567d=&#123;'a':1,'b':2&#125;d_iterator=d.__iter__()# print(d_iterator)# print(d_iterator.__next__())# print(d_iterator.__next__())# print(d_iterator.__next__()) # 抛出异常StopIteration 1.2迭代器深层认识可迭代对象（”可以转换成迭代器的对象”）：内置有iter方法对象 可迭代对象.iter(): 得到迭代器对象 迭代器对象：内置有next方法并且内置有iter方法的对象 迭代器对象.next（）：得到迭代器的下一个值 迭代器对象.iter（）：得到迭代器的本身 1.3for循环的工作原理for循环可以称之为叫迭代器循环 1、d.iter()得到一个迭代器对象2、迭代器对象.next()拿到一个返回值，然后将该返回值赋值给k3、循环往复步骤2，直到抛出StopIteration异常for循环会捕捉异常然后结束循环 1234567d=&#123;'a':1,'b':2,'c':3&#125;for k in d: print(k)with open('a.txt',mode='rt',encoding='utf-8') as f: for line in f: # f.__iter__() print(line)list('hello') #原理同for循环 迭代器优缺点总结缺点： I、为序列和非序列类型提供了一种统一的迭代取值方式。 II、惰性计算：迭代器对象表示的是一个数据流，可以只在需要时才去调用next来计算出一个值，就迭代器本身来说，同一时刻在内存中只有一个值，因而可以存放无限大的数据流，而对于其他容器类型，如列表，需要把所有的元素都存放于内存中，受内存大小的限制，可以存放的值的个数是有限的。 缺点： I、除非取尽，否则无法获取迭代器的长度 II、只能取下一个值，不能回到开始，更像是‘一次性的’，迭代器产生后的唯一目标就是重复执行next方法直到值取尽，否则就会停留在某个位置，等待下一次调用next；若是要再次迭代同个对象，你只能重新调用iter方法去创建一个新的迭代器对象，如果有两个或者多个循环使用同一个迭代器，必然只会有一个循环能取到值。 2.生成器在函数内一旦存在yield关键字，调用函数并不会执行函数体代码会返回一个生成器对象，生成器即自定义的迭代器 123456789101112131415161718def func(): print('第一次') yield 1 print('第二次') yield 2 print('第三次') yield 3 print('第四次')g=func()print(g)生成器就是迭代器g.__iter__()g.__next__()会触发函数体代码的运行，然后遇到yield停下来，将yield后的值当做本次调用的结果返回res1=g.__next__()print(res1) 应用案列 123456789101112131415def my_range(start,stop,step=1): # print('start...') while start &lt; stop: yield start start+=step # print('end....')#g=my_range(1,5,2) # 1 3#print(next(g))#print(next(g))#print(next(g))for n in my_range(1,7,2): print(n) 总结yield： 有了yield关键字，我们就有了一种自定义迭代器的实现方式。yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield可以保存函数的运行状态挂起函数，用来返回多次值 2.1yield表达式123456789101112131415161718def dog(name): food_list=[] print('道哥%s准备吃东西啦...' %name) while True: # x拿到的是yield接收到的值 x = yield food_list # x = '肉包子' print('道哥%s吃了 %s' %(name,x)) food_list.append(x) # ['一根骨头','肉包子']g=dog('alex')res=g.send(None) # next(g)print(res)res=g.send('一根骨头')print(res)res=g.send('肉包子')print(res) 2.2三元表达式 条件成立时要返回的值 if 条件 else 条件不成立时要返回的值 1234567def func(): # if 1 &gt; 3: # x=1 # else: # x=3 x = 1 if 1 &gt; 3 else 3 2.3生成式123456789101112131415161718#列表l = ['alex_dsb', 'lxx_dsb', 'wxx_dsb', \"xxq_dsb\", 'egon']new_l=[name for name in l if name.endswith('dsb')]new_l=[name.upper() for name in l]#字典keys=['name','age','gender']dic=&#123;key:None for key in keys&#125;print(dic)#集合keys=['name','age','gender']set1=&#123;key for key in keys&#125;#生成器with open('db.txt','rb') as f: nums=(len(line) for line in f) total_size=sum(nums) # 依次执行next(nums)，然后累加到一起得到结果=","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python装饰器","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/13 装饰器/","text":"1.什么是装饰器器指的是工具，可以定义成成函数装饰指的是为其他事物添加额外的东西点缀合到一起的解释：装饰器指的定义一个函数，该函数是用来为其他函数添加额外的功能 2.为何要用装饰器开放封闭原则开放：指的是对拓展功能是开放的封闭：指的是对修改源代码是封闭的装饰器就是在不修改被装饰器对象源代码以及调用方式的前提下为被装饰对象添加新功能 3. 装饰器的使用3.1 无参装饰器在使用有参装饰器我们要知道函数和闭包的使用，在此的基础上去使用装饰器，我们直接取一个例子 12345678import timedef index(): time.sleep(3) print('Welcome to the index page’) return 200index() #函数执行 我们要给它添加一个功能，但是呢，我们不能直接在index()函数里面去改动 12345678def timer(func): def wrapper(): # 引用外部作用域的变量func start_time=time.time() res=func() stop_time=time.time() print('run time is %s' %(stop_time-start_time)) return res return wrapper 这样我们就可以改动了再取一个例子： 1234567891011121314import timedef func(): time.sleep(3) print('老板好同事好大家好')def timmer(f): def inner(): start=time.time() f() end=time.time() print(end-start) return innerfunc=timmer(func)func()#这样我们就实现了一个timmer装饰器 1234567891011121314def home(name): time.sleep(2) print('welcome %s to home page' %name)def outter(func): def wrapper(*args,**kwargs): start=time.time() res=func(*args,**kwargs) stop=time.time() print(stop - start) return res return wrapper# 偷梁换柱：home这个名字指向的wrapper函数的内存地址home=outter(home) 语法糖 123456789101112131415161718192021import timedef timmer(func): def wrapper(*args,**kwargs): start=time.time() res=func(*args,**kwargs) stop=time.time() print(stop - start) return res return wrapper# 被装饰对象正上方的单独一行写@装饰器名字# @timmer # index=timmer(index)def index(x,y,z): time.sleep(3) print('index %s %s %s' %(x,y,z))@timmer # home=timmer(ome)def home(name): time.sleep(2) print('welcome %s to home page' %name)index(x=1,y=2,z=3)home('egon') 2.2有参函数前面介绍了无参函数，现在这里我们复习有参函数，什么是有参函数呢？有参函数就是在无参函数的前面再套一层函数，这个函数可以有参数，是可以改动，可以传多个值，就是弥补无参函数的缺点，于语法糖@的限制，outter函数只能有一个参数，并且该才是只用来接收被装饰对象的内存地址。 123456789101112131415161718192021222324252627282930313233343536373839def auth(db_type): def deco(func): def wrapper(*args, **kwargs): name = input('your name&gt;&gt;&gt;: ').strip() pwd = input('your password&gt;&gt;&gt;: ').strip() if db_type == 'file': print('基于文件的验证') if name == 'egon' and pwd == '123': res = func(*args, **kwargs) # index(1,2) return res else: print('user or password error') elif db_type == 'mysql': print('基于mysql的验证') elif db_type == 'ldap': print('基于ldap的验证') else: print('不支持该db_type') return wrapper return deco@auth(db_type='file') # @deco # index=deco(index) # index=wrapperdef index(x, y): print('index-&gt;&gt;%s:%s' % (x, y))@auth(db_type='mysql') # @deco # home=deco(home) # home=wrapperdef home(name): print('home-&gt;&gt;%s' % name)@auth(db_type='ldap') # 账号密码的来源是ldapdef transfer(): print('transfer')index(1, 2)home('egon')transfer() 有参装饰器模板 1234567891011def 有参装饰器(x,y,z): def outter(func): def wrapper(*args, **kwargs): res = func(*args, **kwargs) return res return wrapper return outter@有参装饰器(1,y=2,z=3)def 被装饰对象(): pass 123456789101112131415161718192021222324252627282930313233def deco1(func1): # func1 = wrapper2的内存地址 def wrapper1(*args,**kwargs): print('正在运行===&gt;deco1.wrapper1') res1=func1(*args,**kwargs) return res1 return wrapper1def deco2(func2): # func2 = wrapper3的内存地址 def wrapper2(*args,**kwargs): print('正在运行===&gt;deco2.wrapper2') res2=func2(*args,**kwargs) return res2 return wrapper2def deco3(x): def outter3(func3): # func3=被装饰对象index函数的内存地址 def wrapper3(*args,**kwargs): print('正在运行===&gt;deco3.outter3.wrapper3') res3=func3(*args,**kwargs) return res3 return wrapper3 return outter3# 加载顺序自下而上(了解)@deco1 # index=deco1(wrapper2的内存地址) ===&gt; index=wrapper1的内存地址@deco2 # index=deco2(wrapper3的内存地址) ===&gt; index=wrapper2的内存地址@deco3(111) # ===&gt;@outter3===&gt; index=outter3(index) ===&gt; index=wrapper3的内存地址def index(x,y): print('from index %s:%s' %(x,y))# 执行顺序自上而下的，即wraper1-》wrapper2-》wrapper3index(1,2) # wrapper1(1,2)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python函数对象和闭包","date":"2017-10-08T16:00:00.000Z","path":"2017/10/09/12 函数对象和闭包/","text":"1 . 函数对象函数对象指的是函数可以被当做’数据’来处理，具体可以分为四个方面的使用1.1 函数可以被引用 12345def func(): print('from func')f=funcprint(f,func)f() 1.2 可以当做函数当做参数传给另外一个函数 1234567def func(): print('from func')def foo(x): # x = func的内存地址 # print(x) x()foo(func) # foo(func的内存地址) 1.3 可以当做函数当做另外一个函数的返回值 123456789def func(): print('from func')def foo(x): # x=func的内存地址 return x # return func的内存地址res=foo(func) # foo（func的内存地址）print(res) # res=func的内存地址res() 1.4 可以当做容器类型的一个元素 1234567l=[func,]# print(l)l[0]()dic=&#123;'k1':func&#125;print(dic)dic['k1']() 应用场景： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def login(): print('登录功能')def transfer(): print('转账功能')def check_banlance(): print('查询余额')def withdraw(): print('提现')def register(): print('注册')func_dic = &#123; '0': ['退出', None], '1': ['登录', login], '2': ['转账', transfer], '3': ['查询余额', check_banlance], '4': ['提现', withdraw], '5': ['注册', register]&#125;# func_dic['1']()while True: for k in func_dic: print(k, func_dic[k][0]) choice = input('请输入命令编号：').strip() if not choice.isdigit(): print('必须输入编号，傻叉') continue if choice == '0': break # choice='1' if choice in func_dic: func_dic[choice][1]() else: print('输入的指令不存在') 2.闭包核心：闭包函数=名称空间与作用域+函数嵌套+函数对象核心点：名字的查找关系是以函数定义阶段为准“闭”函数指的该函数是内嵌函数“包”函数指的该函数包含对外层函数作用域名字的引用（不是对全局作用域） 1234567891011121314x=1def f1(): def f2(): print(x) return f2def f3(): x=3 f2=f1() #调用f1()返回函数f2 f2() #需要按照函数定义时的作用关系去执行，与调用位置无关 f3() #结果为1 函数被当做数据处理时，始终以自带的作用域为准。若内嵌函数包含对外部函数作用域（而非全局作用域）中变量的引用，那么该’内嵌函数’就是闭包函数，简称闭包 12345678910方式一：x=1def outer(): x=2 def inner(): print(x) return innerfunc=outer()func() # 结果为2 两种为函数体传参的方式: 123456789101112131415161718def f2(x): print(x)f2(1)f2(2)f2(3)方式二：def f1(x): # x=3 x=3 def f2(): print(x) return f2x=f1(3)print(x)x() 案例： 12345678910111213141516171819202122232425262728import requests传参的方案一：def get(url): response=requests.get(url) print(len(response.text))get('https://www.baidu.com')get('https://www.cnblogs.com/linhaifeng')get('https://zhuanlan.zhihu.com/p/109056932')# 传参的方案二：def outter(url): # url='https://www.baidu.com' def get(): response=requests.get(url) print(len(response.text)) return getbaidu=outter('https://www.baidu.com')baidu()cnblogs=outter('https://www.cnblogs.com/linhaifeng')cnblogs()zhihu=outter('https://zhuanlan.zhihu.com/p/109056932')zhihu()","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"名称空间和作用域","date":"2017-10-07T16:00:00.000Z","path":"2017/10/08/11 名称空间和作用域/","text":"1. 名称空间namespacs：存放名字的地方，是对栈区的划分有了名称空间之后，就可以在栈区中存放相同的名字，详细的，名称空间分为三种内置名称空间存放的名字：存放的python解释器内置的名字存活周期：python解释器启动则产生，python解释器关闭则销毁 全局名称空间存放的名字：只要不是函数内定义、也不是内置的，剩下的都是全局名称空间的名字存活周期：python文件执行则产生，python文件运行完毕后销毁 1234func=函数的内存地址def func(): a=111 b=222 局部名称空间存放的名字：在调用函数时，运行函数体代码过程中产生的函数内的名字存活周期：在调用函数时存活，函数调用完毕后则销毁 1234def func(a,b): passfunc(10,1) 1234567891011121314151617181920212223242526名称空间的加载顺序内置名称空间&gt;全局名称空间&gt;局部名称空间销毁顺序局部名称空间&gt;全局名空间&gt;内置名称空间名字的查找优先级：当前所在的位置向上一层一层查找内置名称空间全局名称空间局部名称空间如果当前在局部名称空间：局部名称空间—&gt;全局名称空间-&gt;内置名称空间input=333def func(): input = 444print(input)func()如果当前在全局名称空间全局名称空间-&gt;内置名称空间input = 333def func(): input = 444func()print(input) 名称空间的“嵌套”关系是以函数定义阶段为准，与调用位置无关 1234567x = 1def func(): print(x)def foo(): x = 222 func()foo() 函数嵌套定义 12345678input = 111def f1(): def f2(): input = 333 print(input) input = 222 f2()f1() 2.作用域全局作用域：内置名称空间、全局名称空间1、全局存活2、全局有效: 被所有函数共享 12345678x &#x3D; 111def foo(): print(x, id(x))def bar(): print(x, id(x))foo()bar()print(x, id(x)) 局部作用域: 局部名称空间的名字1、临时存活2、局部有效: 函数内有效 1234def foo(x): def f1(): def f2():n print(x) globa和nonlocal如果再局部想要修改全局的名字对应的值（不可变类型），需要用global 123456x=111def func(): global x # 声明x这个名字是全局的名字，不要再造新的名字了 x=222func()print(x) nonlocal(了解): 修改函数外层函数包含的名字对应的值（不可变类型） 123456789x=0def f1(): x=11 def f2(): nonlocal x x=22 f2() print('f1内的x：',x)f1()","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python形参和实参","date":"2017-10-06T16:00:00.000Z","path":"2017/10/07/10 形参，实参/","text":"形参与实参形参：在定义函数阶段定义的参数称之为形式参数，简称形参,相当于变量名实参：在调用函数阶段传入的值称之为实际参数，简称实参，相当于变量值形参与实参的关系：1、在调用阶段，实参（变量值）会绑定给形参（变量名）2、这种绑定关系只能在函数体内使用3、实参与形参的绑定关系在函数调用时生效，函数调用结束后解除绑定关系 形参与实参的使用2.1 位置参数：按照从左到右的顺序依次定义的参数称之为位置参数位置形参:在函数定义阶段，按照从左到右的顺序直接定义的”变量名”特点：必须被传值，多一个不行少一个也不行 123def func(x,y): print(x,y)func(1,2) 位置实参:在函数调用阶段， 按照从左到有的顺序依次传入的值特点：按照顺序与形参一一对应 2.2 关键字参数关键字实参：在函数调用阶段，按照key=value的形式传入的值 特点：指名道姓给某个形参传值，可以完全不参照顺序 1234def func(x,y): print(x,y)func(y=2,x=1) 强调：位置实参必须放在关键字实参前，不能能为同一个形参重复传值 2.3 默认参数默认形参： 在定义函数阶段，就已经被赋值的形参，称之为默认参数 特点：在定义阶段就已经被赋值，意味着在调用阶段可以不用为其赋值 1234567def register(name,age,gender='男'): print(name,age,gender)register('一',18)register('二',19)register('三',19)register('四',19,'女') 位置形参与默认形参混用，强调 位置形参必须在默认形参的左边 默认参数的值是在函数定义阶段被赋值的，准确地说被赋予的是值的内存地址 虽然默认值可以被指定为任意数据类型，但是不推荐使用可变类型 函数最理想的状态：函数的调用只跟函数本身有关系，不外界代码的影响 12345678910111213def func(x,y,z,l=None): if l is None: l=[] l.append(x) l.append(y) l.append(z) print(l)func(1,2,3)func(4,5,6)new_l=[111,222]func(1,2,3,new_l) 2.4 可变长度的参数可变长度指的是在调用函数时，传入的值（实参）的个数不固定而实参是用来为形参赋值的，所以对应着，针对溢出的实参必须有对应的形参来接收 2.4.1*形参名：用来接收溢出的位置实参，溢出的位置实参会被保存成元组的格式然后赋值紧跟其后的形参名Ⅰ：后跟的可以是任意名字，但是约定俗成应该是args 123456789def my_sum(*args): res=0 for item in args: res+=item return resres=my_sum(1,2,3,4,)print(res) Ⅱ：可以用在实参中，实参中带，先*后的值打散成位置实参 1234def func(x,y,z): print(x,y,z)func(*[11,22,33]) # func(11，22，33) III: 形参与实参中都带* 1234def func(x,y,*args): # args=(3,4,5,6) print(x,y,args)func(1,2,[3,4,5,6]) 2.4.2 可变长度的关键字参数I：形参名：用来接收溢出的关键字实参，会将溢出的关键字实参保存成字典格式，然后赋值给紧跟其后的形参名**后跟的可以是任意名字，但是约定俗成应该是kwargs 1234def func(x,y,**kwargs): print(x,y,kwargs)func(1,y=2,a=1,b=2,c=3) II: 可以用在实参中(后跟的只能是字典)，实参中带，先后的值打散成关键字实参 12345def func(x,y,z): print(x,y,z)func(*&#123;'x':1,'y':2,'z':3&#125;)func(**&#123;'x':1,'y':2,'z':3&#125;) III: 形参与实参中都带** 12345def func(x,y,**kwargs): print(x,y,kwargs)func(y=222,x=111,a=333,b=444)func(**&#123;'y':222,'x':111,'a':333,'b':4444&#125;) 强调：混用与* 12345678910def index(x,y,z): print('index=&gt;&gt;&gt; ',x,y,z)def wrapper(*args,**kwargs): #args=(1,) kwargs=&#123;'z':3,'y':2&#125; index(*args,**kwargs) # index(*(1,),**&#123;'z':3,'y':2&#125;) # index(1,z=3,y=2)wrapper(1,z=3,y=2) # 为wrapper传递的参数是给index用的 3.命名关键字参数命名关键字参数：在定义函数时，*后定义的参数，如下所示，称之为命名关键字参数特点：命名关键字实参必须按照key=value的形式为其传值 123451、命名关键字实参必须按照key=value的形式为其传值def func(x,y,*,a,b): # 其中，a和b称之为命名关键字参数 print(x,y) print(a,b)func(1,2,b=222,a=111) 组合使用（了解）形参混用的顺序：位置新参，默认形参,args,命名关键字形参，*kwargs。123456def func(x,y=111,*args,z,**kwargs): print(x) print(y) print(args) print(z) print(kwargs)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python函数","date":"2017-10-06T16:00:00.000Z","path":"2017/10/07/9 函数-认识/","text":"1234567891、什么是函数 函数就相当于具备某一功能的工具 函数的使用必须遵循一个原则： 先定义 后调用2、为何要用函数 1、组织结构不清晰，可读性差 2、代码冗余 3、可维护性、扩展性差 1.定义函数：定义的语法 1234def 函数名(参数1,参数2,...): \"\"\"文档描述\"\"\" 函数体 return 值 1.1：无参函数123456789def func(): 定义函数发生的事情 1、申请内存空间保存函数体代码 2、将上述内存地址绑定函数名 3、定义函数不会执行函数体代码，但是会检测函数体语法调用函数发生的事情 1、通过函数名找到函数的内存地址 2、然后加口号就是在触发函数体代码的执行 12print(func)func() 123456def bar(): # bar=函数的内存地址 print('from bar')def foo(): bar() print('from foo')foo() 1.2 有参函数123def func(x,y): # x=1 y=2 print(x,y) func(1,2) 1.3 空函数,函数体代码为pass12def func(x, y): pass 2.调用函数1.语句的形式:只加括号调用函数 12interactive()add(1,2) 2.表达式形式： 1234def add(x,y): return x+yres=add(1,2)*10print(res) 3.函数调用可以当做参数 12res=add(add(1,2),10)print(res) 三、函数返回值return是函数结束的标志，即函数体代码一旦运行到return会立刻终止函数的运行，并且会将return后的值当做本次运行的结果返回： 返回None：函数体内没有return 返回一个值：return 值 返回多个值：用逗号分隔开多个值，会被return返回成元组","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"字符编码","date":"2017-10-04T16:00:00.000Z","path":"2017/10/05/7 字符编码/","text":"1.什么是字符编码是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递 2.为什么有字符编码因为计算机起源于美国，为了方便操控计算机，能够让计算机识别因为字符所以就有了字符编码，ASCII表在此也就诞生了 3.字符编码的发展3.1 现代计算机起源于美国，所以最先考虑仅仅是让计算机识别英文字符，于是诞生了ASCII表，为了让计算机能够识别中文和英文，中国人定制了GBK，每个国家都各自的字符，为让计算机能够识别自己国家的字符外加英文字符，各个国家都制定了自己的字符编码表此时,美国人用的计算机里使用字符编码标准是ASCII、中国人用的计算机里使用字符编码标准是GBK、日本人用的计算机里使用字符编码标准是Shift_JIS,如下图所示。 3.2 为了能够识别所有的字符编码，我们定制了一个万国的字符编码unicode 1234567891011121314151617181920212223英文字符可以被ASCII识别英文字符---&gt;unciode格式的数字---&gt;ASCII格式的数字中文字符、英文字符可以被GBK识别中文字符、英文字符---&gt;unicode格式的数字---&gt;gbk格式的数字日文字符、英文字符可以被shift-JIS识别日文字符、英文字符---&gt;unicode格式的数字---&gt;shift-JIS格式的数字``编码：由字符转换成内存中的unicode，以及由unicode转换成其他编码的过程，都称为编码encode![](https://img2020.cnblogs.com/blog/1897826/202003/1897826-20200312191519454-1188301366.jpg)解码：由内存中的unicode转换成字符，以及由其他编码转换成unicode的过程，都称为解码decode![](https://img2020.cnblogs.com/blog/1897826/202003/1897826-20200312191536805-1650313753.jpg)## 4.utf-8是一种针对Unicode的可变长符编码，也是一种前缀码，又称万国码但是为什么在内存中不用utf-8呢？只有Unicode编码才能运行其他国家硬盘中的代码，而UTF-8的代码无法进行该操作是因为多国字符编码遗留下来的原因## 5 分析python 版本字符编码python2和python3![](https://img2020.cnblogs.com/blog/1897826/202003/1897826-20200312200856498-816015482.jpg)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"基本数据类型及内置方法","date":"2017-10-04T16:00:00.000Z","path":"2017/10/05/6 基本数据类型及内置方法/","text":"1.类型转换字符串可以把任意的其他类型都转成字符串 12res=str(&#123;'a':1&#125;)print(res,type(res)) #把字典转换成字符串类型 2.内置方法2.1 索引按索引取值，只能取，不能改 123msg='hello world!'print(msg[0]) # h 正向取print(msg[-1]) # ! 反向取 2.2 切片就是一个大字符串拷贝出一个子字符串 1234567msg='hello world!'res=msg[0:5] # 顾头不顾尾，索引是0到4red=msg[0:8:2] # hlow'''[start:end:step] 0是开始 ，到8结束，2是索引加2，每隔两个取msg[5:0:-1]反向取 # olle''' 2.3 len()len就是计算字符串的长度 12msg='hello world!'print(len(msg)) # 12 2.4 成员运算成员运算in和not in判断一个子字符串是否存在于一个大字符串中 123print(\"alex\" in \"alex is sb\")print(\"alex\" not in \"alex is sb\")print(not \"alex\" in \"alex is sb\") # 不推荐使用 2.5 strip移除字符串左右两侧的符号strip 123msg='***hello world!***'res=msg.strip('*') # 如果里面没有值默认的是去两边的空格部分，如果中间有*或空格不去 除 print(res) # hello world! 补充：lstrip(去左边的*或空格),rstrip(去右边的*或空格)2.6 split把一个字符串按照某种分隔符进行切分，得到一个列表 123info='egon:18:male' #如果':'是空格，split()默认分隔符是空格res=info.split(':')print(res) # ['egon', '18', 'male'] 补充：print(info.split(&apos;:&apos;,1)) # [&quot;egon&quot;,&quot;18:male&quot;] #分隔第一个 print(info.rsplit(&apos;:&apos;,1)) # [&quot;egon:18&quot;,&quot;male&quot;] #分隔最后一个2.7 join用于将序列中的元素以指定的字符连接生成一个新的字符串 12345s1 = \"-\"s2 = \"\"seq = (\"r\", \"u\", \"n\", \"o\", \"o\", \"b\") # 字符串序列print (s1.join( seq )) # r-u-n-o-o-bprint (s2.join( seq )) # runoob 2.8 replace把字符串中的 old（旧字符串） 替换成 new(新字符串) 123msg=\"you can you up no can no bb\"print(msg.replace(\"you\",\"YOU\",))print(msg.replace(\"you\",\"YOU\",1)) # 如果指定第三个参数max，则替换不超过 max次。 2.9 isdigit判断字符串是否由纯数字组成 1print('123'.isdigit()) #ture 2.10 find and index的区别find:如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定索引值，返回的是索引值在字符串中的起始位置。如果不包含索引值，返回-1。index:方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，该方法与 python find()方法一样，只不过如果str不在 string中会报一个异常语法：str.index(str, beg=0, end=len(string)) 123msg='hello egon hahaha'print(msg.find('egon'))print(msg.index('e')) 2.11 了解 折叠代码块 1、find,rfind,index,rindex,count msg='hello egon hahaha' 找到返回起始索引 print(msg.find('e')) # 返回要查找的字符串在大字符串中的起始索引 print(msg.find('egon')) print(msg.index('e')) print(msg.index('egon')) 找不到 print(msg.find('xxx')) # 返回-1，代表找不到 print(msg.index('xxx')) # 抛出异常 msg='hello egon hahaha egon、 egon' print(msg.count('egon')) 2、center,ljust,rjust,zfillprint(‘egon’.center(50,’‘))print(‘egon’.ljust(50,’‘))print(‘egon’.rjust(50,’*’))print(‘egon’.zfill(10)) 3、expandtabsmsg=’hello\\tworld’print(msg.expandtabs(2)) # 设置制表符代表的空格数为2 4、captalize,swapcase,titleprint(“hello world egon”.capitalize())print(“Hello WorLd EGon”.swapcase())print(“hello world egon”.title()) 5、is数字系列.6、is其他print(‘abc’.islower())print(‘ABC’.isupper())print(‘Hello World’.istitle())print(‘123123aadsf’.isalnum()) # 字符串由字母或数字组成结果为Trueprint(‘ad’.isalpha()) # 字符串由由字母组成结果为Trueprint(‘ ‘.isspace()) # 字符串由空格组成结果为Trueprint(‘print’.isidentifier())print(‘age_of_egon’.isidentifier())print(‘1age_of_egon’.isidentifier()) num1=b’4’ #bytesnum2=u’4’ #unicode,python3中无需加u就是unicodenum3=’四’ #中文数字num4=’Ⅳ’ #罗马数字 isdigit只能识别：num1、num2print(num1.isdigit()) # Trueprint(num2.isdigit()) # Trueprint(num3.isdigit()) # Falseprint(num4.isdigit()) # False isnumberic可以识别：num2、num3、num4print(num2.isnumeric()) # Trueprint(num3.isnumeric()) # Trueprint(num4.isnumeric()) # True isdecimal只能识别：num2print(num2.isdecimal()) # Trueprint(num3.isdecimal()) # Falseprint(num4.isdecimal()) # False # 2.列表及内置方法 ## 1 作用： 用来存多个值，按索引取值 ## 2.定义： 1list3 = [\"a\", \"b\", \"c\", \"d\"] ## 3.类型转换： 字典转换成list只能取到它的key的值，而且还是无序的, 12res=list(&#123;'k1':111,'k2':222,'k3':333&#125;)print(res) ## 4.内置方法 ### 4.1按索引取值 可取可改： 正向取，反向取， 123l=[111,'ccc','bb','aa']print(l[0]) #正向取print(l[-1]) # 反向取 但是如果取值操作的索引不存在就会报错 ### 4.2 切片 (顾头不顾尾，步长)但是切片等同于拷贝行为，而且相当于浅copy ### 4.3长度 len用来计算它的长度 4.4 添加值append， insert，extend三种 123456789101112l=[1,'c','b','a']l.append(0) #按索引print(l)l.insert(0,'al') #指定索引位置添加print(l)l.extend('abc') #列表末尾一次性追加另一个序列中的多个值print(l)'''[1, 'c', 'b', 'a', 0]['al', 1, 'c', 'b', 'a', 0]['al', 1, 'c', 'b', 'a', 0, 'a', 'b', 'c']''' 4.5 删除操作del ,pop ,remove 123456789101112 l=[111,'ccc','bb','aa'] del l[0] # 通用的删除方法，且没有返回值，索引不能进行赋值操作 print(l) l.pop(0) # 根据索引删除的，不传索引，默认删除最后一个 print(l) l.remove('bb') # 按指定元素删除 print(l)'''['ccc', 'bb', 'aa']['bb', 'aa']['aa']''' 4.6 了解的内置方法index() 查找指定元素clear()清除listreverse():不是排序，就是将列表倒过来 ，反转listcount() 统计元素出现的个数sort ()排序 升序 3.元组及内置方法1.作用一个不可变的列表”作用：按照索引/位置存放多个值，只用于读不用于改 2. 定义元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可 3. 类型转换123print(tuple('hello'))print(tuple([1,2,3]))print(tuple(&#123;'a1':111,'a2':333&#125;)) 4.内置方法因为元组只能取不能改。所以内置方法少 4.1 按索引取值()正向取，反向取 12t=('aa','bbb','cc')print(t[0]) 4.2 切片(顾头不顾尾，步长)123t=('aa','bbb','cc','dd','eee')print(t[0:3])print(t[::-1]) 4.3 长度len()计算元组的长度 4.4 循环12for x in t:print(x) 字典3.1 作用字典是另一种可变容器模型，且可存储任意类型对象 3.2 定义{}内用逗号分隔开多个key：value，其中value可以使任意类型，但是key必须是不可变类型,且不能重复 3.3 造字典方式一： 12d=dict(x=1,y=2,z=3)print(d) 方式二 12345678910info=[ ['name','egon'], ('age',18), ['gender','male'] ] res=dict(info)print(res)'''&#123;'name': 'egon', 'age': 18, 'gender': 'male'&#125;''' 方式三： 123456keys=['name','age','gender']d=&#123;&#125;.fromkeys(keys,None)print(d)'''&#123;'name': None, 'age': None, 'gender': None&#125;''' 4 内置方法4.1按key存取值按key存取值，可存可取，但是针对赋值key存在则修改，不存在，则创建新值 4.2长度len是计算key,key有多少，len就多长 4.3 删除操作del ，pop， popitem 12345678910111213a=&#123;'k1':111,'k2':222,'k3':333&#125;del a['k1']print(a)res=a.pop('k2') # 根据key删除元素，返回删除key对应的那个value值print(res)res1 = a.popitem() # 随机删除，返回元组(删除的key,删除的value)print(res1)'''&#123;'k2': 222, 'k3': 333&#125;222('k3', 333)''' # 键keys()，值values()，键值对items() =&gt;在python3中得到的是老母鸡 不占内存空间 4.4了解items:以列表返回可遍历的(键, 值) 元组数组keys:返回一个迭代器，可以使用 list() 来转换为列表values:返回一个迭代器，可以使用 list() 来转换为列表setdefault:如果key有则不添加,返回字典中key对应的值,如果key没有则添加，返回字典中key对应的值 1234567b=&#123;'a1':'bbb','a2':'ccc','a3':'ddd'&#125;b.setdefault('name','enum')print(b)'''&#123;'a1': 'bbb', 'a2': 'ccc', 'a3': 'ddd', 'name': 'enum'&#125;''' update:更新 123456d=&#123;'k1':111&#125;d.update(&#123;'k2':222,'k3':333,'k1':1&#125;)print(d)'''&#123;'k1': 1, 'k2': 222, 'k3': 333&#125;''' get 1234&#123;'k1': 1, 'k2': 222, 'k3': 333&#125;print(d['k2']) # key不存在则报错print(d.get('k1')) # 1print(d.get('k4')) # key不存在不报错，返回None 4. 集合：1.定义：1：每个元素必须是不可变类型 2：集合内没有重复的元素 3：集合内元素无序2.使用：关系运算：1234567891011121314151617181920212223242526272829friends1=&#123;'zc','bc','ac','bb'&#125;friends2=&#123;'zc','bb','cc','lk'&#125;res=friends1|friends2print(res)交集res=friends1&amp;friends2print(res)差集res=friends1-friends2print(res)对称集res=friends1^friends2print(res)判断值res=friends2==friends1rint(res)去重l=[ &#123;'name':'lili','age':18,'sex':'male'&#125;, &#123;'name':'jack','age':73,'sex':'male'&#125;, &#123;'name':'tom','age':20,'sex':'female'&#125;, &#123;'name':'lili','age':18,'sex':'male'&#125;, &#123;'name':'lili','age':18,'sex':'male'&#125;,]dic=[]for i in l: if i not in dic: dic.append(i)print(dic) 3.其他的内置方法1234567891011121314151617181920212223242526s=&#123;1,2,3&#125;需要掌握的内置方法1：discards.discard(4) # 删除元素不存在do nothingprint(s)s.remove(4) # 删除元素不存在则报错需要掌握的内置方法2：updates.update(&#123;1,3,5&#125;)print(s)需要掌握的内置方法3：popres=s.pop()print(res)需要掌握的内置方法4：adds.add(4)print(s)其余方法全为了解res=s.isdisjoint(&#123;3,4,5,6&#125;) # 两个集合完全独立、没有共同部分，返回Trueprint(res)了解s.difference_update(&#123;3,4,5&#125;) # s=s.difference(&#123;3,4,5&#125;)print(s)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python入门","date":"2017-10-03T16:00:00.000Z","path":"2017/10/04/1.python入门/","text":"python入门编程是是一件枯燥乏味的事情，但是编程虐我千百遍，我待编程如初恋，那么我们一定会学成前面我们介绍了计算机的基础以及操作系统。 编程语言介绍好的现在呢，我们来介绍一下编程语言，我们想要操作计算机，我们就要把我们的想法被表达出来，那么我们就要把它想象一下我们的奴隶去操纵它，计算机只能理解二进制，所以，如果我们想要操纵计算机完成我们下达的任务，就必须用计算机能听懂的语言，编程语言分三种。 1.机器语言所谓的机器语言就是直接用二进制编程，用二进制编程直接操作我们计算机底层的硬件，所以机器语言是属于低级语言。 总结 1. 执行效率最高 2. 开发效率最低 3. 跨平台性差2.汇编语言汇编语言是用一些二进制编程一个个英文，所以一组二进制就是一个英文标符，汇编语言有着近似机器语言的权威，不同的是，中央处理器对它行跪拜礼。 总结 1.执行效率高 2.开发效率低 3.跨平台性差3.高级语言由于汇编语言依赖于硬件体系，且助记符量大难记，于是人们又发明了更加易用的所谓高级语言。在这种语言下，其语法和结构更类似普通英文，且由于远离对硬件的直接操作。但是高级语言有分编译型和解释型。 3.1编译型 编译型就是直接翻译，类似于有道词典翻译，编译成能够识别的二进制，然后操作系统直接操作计算机硬件。 总结 1.执行效率高 2.开发效率低 3.跨平台性差 3.2解释型 类似于同声翻译，写一行，翻译一行 总结 1.执行效率高 2.开发效率低 3.跨平台性差 总结： 1、执行效率：机器语言&gt;汇编语言&gt;高级语言（编译型&gt;解释型） 2、开发效率：机器语言&lt;汇编语言&lt;高级语言（编译型&lt;解释型） 3、跨平台性：解释型具有极强的跨平台型python介绍1.python语言：Python是一种计算机程序设计语言，由吉多·范罗苏姆创造，第一版发布于1991年，可以视之为一种改良的LISP。Python的设计哲学强调代码的可读性和简洁的语法。相比于C++或Java，Python让开发者能够用更少的代码表达想法2.python解释器专门用来识别python这门语言的语法并解释执行的 3.解释器多版本共存设置（请参考下面博客）由于时间仓促，谅解。 [薛贤奇博客](https://www.cnblogs.com/xuexianqi/p/12400896.html)运行python1.运行python程序的两种方式交互式： 即时得到程序的运行结果，多用于调试 脚本方式： 把程序写到文件里(约定俗称文件名后缀为.py)，然后用python解释器解释执行其中的内容（例如：python3.8 python程序文件的路径）2.一个python应用程序的运行的三个步骤python3.8执行python程序的三个步骤 1.先启动python3.8解释器 2.解释器会送系统调试-&gt;读入内存-&gt;转译字符 3.解释器执行识别python语法 对比文本编辑器读取C:\\a\\b\\c.py文件内容也经历了三个步骤 1.启动文本器 2.文本器发送调试，把c.py的内容从硬盘读入内存 3.文本编辑会将刚刚读入内存的内容控制输出到屏幕上总结： 二者在前两个阶段做的事情完全一致 唯一不同的就是第三个阶段对读入内存的python代码的处理方式不同 3.注释注释是对关键代码的解释说明 单行注释：# 多行注释：&quot;&quot;&quot; &quot;&quot;&quot; 被注释的代码不会被执行","tags":[{"name":"drf","slug":"drf","permalink":"http://yoursite.com/tags/drf/"}]},{"title":"python与用户交互","date":"2017-10-03T16:00:00.000Z","path":"2017/10/04/3 python与用户交互/","text":"就是计算机与用户之间的关系 1.1 接收用户的输入 在python3：input会将用户输入的所有的内容都存成字符串类型 1234567username=input('请输入您的名字') #'zh'print(username,type(username)) age=input('请输入您的年龄：') # \"18\"print(age,type(age))age=int(age) # int只能将纯数字的字符串转换成整型print(age &gt; 16) 在python2中：raw_input:用法与python3中的input一模一样input：要求用户必须输入一个明确的数据类型，输入的是什么类型，就存成什么类型，很不方便用户的使用 age=input(“18”) age,type(age) 结果：18 (18, &lt;type ‘int’&gt;) 1.2 字符串的格式化输出 %输出按照位置与%s一一对应，不多不少 12345res='my name is %s,my age is %s'%('zc','18') # my name is zc my age is 18res='my name is %s,my age is %s'%('18','zc') # my name is 18 my age is zcres='my name is %s'%'zc' # my name is zc 以字典的形式传值，打破位置的限制 1res='我的名字是%(name)s,我的年龄是%(age)s'%&#123;'age':'18','name':'zc'&#125; 但是%s可以接受任意类型，%d只能接受int str.format :兼容性好。按照位置传值 12res='我的名字是&#123;&#125;，我的年龄是&#123;&#125;'.format&#123;'zc',180&#125;print(res) 打破位置的传值，按照key=value传值 12res='我的名字是&#123;name&#125;,我的年龄是&#123;age&#125;'.format(age=18,name='zc')print(res) 了解知识： 123456789101112131415161718192021 了解知识\"\"\"2.4 填充与格式化# 先取到值,然后在冒号后设定填充格式：[填充字符][对齐方式][宽度]# *&lt;10：左对齐，总共10个字符，不够的用*号填充print('&#123;0:*&lt;10&#125;'.format('开始执行')) # 开始执行******# *&gt;10：右对齐，总共10个字符，不够的用*号填充print('&#123;0:*&gt;10&#125;'.format('开始执行')) # ******开始执行# *^10：居中显示，总共10个字符，不够的用*号填充print('&#123;0:*^10&#125;'.format('开始执行')) # ***开始执行***2.5 精度与进制print('&#123;salary:.3f&#125;'.format(salary=1232132.12351)) #精确到小数点后3位，四舍五入，结果为：1232132.124print('&#123;0:b&#125;'.format(123)) # 转成二进制，结果为：1111011print('&#123;0:o&#125;'.format(9)) # 转成八进制，结果为：11print('&#123;0:x&#125;'.format(15)) # 转成十六进制，结果为：fprint('&#123;0:,&#125;'.format(99812939393931)) # 千分位格式化，结果为：99,812,939,393,931\"\"\" 2.3 ff:python3.5以后才推出 1234x &#x3D; input(&#39;your name: &#39;)y &#x3D; input(&#39;your age: &#39;)res &#x3D; f&#39;我的名字是&#123;x&#125; 我的年龄是&#123;y&#125;&#39;print(res)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python运算符","date":"2017-10-03T16:00:00.000Z","path":"2017/10/04/4 python运算符/","text":"2.1算数运算符 print(10 + 3.1)print(10 + 3)print(10 / 3) # 结果带小数print(10 // 3) # 只保留整数部分print(10 % 3) # 取模、取余数print(10 ** 3) # 取模、取余数 2.2比较运算符 、&gt;=、&lt;、&lt;=、==、!= 12345678print(10 &gt; 3)print(10 &#x3D;&#x3D; 10)print(10 &gt;&#x3D; 10)print(10 &gt;&#x3D; 3)name&#x3D;input(&#39;your name: &#39;)print(name &#x3D;&#x3D; &#39;egon&#39;) 2.3赋值运算符 变量的赋值增量赋值： 12345age &#x3D; 18age +&#x3D; 1 # age&#x3D;age + 1print(age)age*&#x3D;3 链式赋值 123456x&#x3D;10y&#x3D;xz&#x3D;yz &#x3D; y &#x3D; x &#x3D; 10 # 链式赋值print(x, y, z)print(id(x), id(y), id(z)) 2.4 交叉赋值 123456789m&#x3D;10n&#x3D;20temp&#x3D;mm&#x3D;nn&#x3D;tempprint(m,n)m,n&#x3D;n,m # 交叉赋值print(m,n) 2.5 解压赋值 把五个月的工资取出来分别赋值给不同的变量名 123456789101112salaries&#x3D;[111,222,333,444,555]mon0&#x3D;salaries[0]mon1&#x3D;salaries[1]mon2&#x3D;salaries[2]mon3&#x3D;salaries[3]mon4&#x3D;salaries[4]mon0,mon1,mon2,mon3,mon4&#x3D;salariesprint(mon0)print(mon1)print(mon2)print(mon3)print(mon4) 这样取值太麻烦，如下面解压赋值 12mon0,mon1,mon2,mon3&#x3D;salaries # 对应的变量名少一个不行mon0,mon1,mon2,mon3,mon4,mon5&#x3D;salaries # 对应的变量名多一个也不行 引入，可以帮助我们取两头的值，无法取中间的值取前三个值x,y,z,=salaries=[111,222,333,444,555] # *会将没有对应关系的值存成列表然后赋值给紧跟其后的那个变量名，此处为print(x,y,z)print(_) 取后三个值 12345*_,x,y,z=salaries=[111,222,333,444,555]print(x,y,z)x,*_,y,z=salaries=[111,222,333,444,555]print(x,y,z) 解压字典默认解压出来的是字典的key 12x,y,z&#x3D;dic&#x3D;&#123;&#39;a&#39;:1,&#39;b&#39;:2,&#39;c&#39;:3&#125;print(x,y,z) 2.6 可变和不可变类型 可变类型：值改变，id不变，证明改的是原值，证明原值是可以被改变的不可变类型：值改变，id也变了，证明是产生新的值，压根没有改变原值，证明原值是不可以被修改的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# int型：不可变x&#x3D;10print(id(x))x&#x3D;11 # 产生新值print(id(x)# float型：不可变x&#x3D;3.1print(id(x))x&#x3D;3.2print(id(x))# str是不可变类型x&#x3D;&quot;abc&quot;print(id(x))x&#x3D;&#39;gggg&#39;print(id(x))# list是可变类型l&#x3D;[&#39;aaa&#39;,&#39;bbb&#39;,&#39;ccc&#39;]print(id(l))l[0]&#x3D;&#39;AAA&#39;print(l)print(id(l))# dictdic&#x3D;&#123;&#39;k1&#39;:111,&#39;k2&#39;:222&#125;print(id(dic))dic[&#39;k1&#39;]&#x3D;3333333333# print(dic)print(id(dic))#bool不可变关于字典补充：定义：&#123;&#125;内用逗号分隔开多key:value, 其中value可以是任意类型 但是key必须是不可变类型dic&#x3D;&#123; &#39;k1&#39;:111, &#39;k2&#39;:3.1, &#39;k3&#39;:[333,], &#39;k4&#39;:&#123;&#39;name&#39;:&#39;egon&#39;&#125;&#125;dic&#x3D;&#123; 2222:111, 3.3:3.1, &#39;k3&#39;:[333,], &#39;k4&#39;:&#123;&#39;name&#39;:&#39;egon&#39;&#125;&#125;print(dic[3.3])dic&#x3D;&#123;[1,2,3]:33333333&#125;dic&#x3D;&#123;&#123;&#39;a&#39;:1&#125;:33333333&#125; 2.7条件运算符 条件可以是：比较运算符 12age &#x3D; 18print(age &gt; 16) # 条件判断之后会得到一个布尔值 条件可以是：True、False 12is_beautiful&#x3D;Trueprint(is_beautiful) 第二大类：隐式布尔值，所有的值都可以当成条件去用其中0、None、空(空字符串、空列表、空字典)=》代表的布尔值为False，其余都为真 2.8逻辑运算 not：就是把紧跟其后的那个条件结果取反ps:not与紧跟其后的那个条件是一个不可分割的整体 12print(not 16 &gt; 13)print(not True) and：逻辑与，and用来链接左右两个条件，两个条件同时为True，最终结果才为真 123print(True and 10 &gt; 3)print(True and 10 &gt; 3 and 10 and 0) # 条件全为真，最终结果才为Trueprint( 10 &gt; 3 and 10 and 0 and 1 &gt; 3 and 4 &#x3D;&#x3D; 4 and 3 !&#x3D; 3) # 偷懒原则 or：逻辑或，or用来链接左右两个条件，两个条件但凡有一个为True，最终结果就为True，两个条件都为False的情况下，最终结果才为False 12print(3 &gt; 2 or 0)print(3 &gt; 4 or False or 3 !&#x3D; 2 or 3 &gt; 2 or True) # 偷懒原则 ps:优先级not&gt;and&gt;orps：如果单独就只是一串and链接，或者说单独就只是一串or链接，按照从左到右的顺讯依次运算即可（偷懒原则）如果是混用，则需要考虑优先级了 12res&#x3D;3&gt;4 and not 4&gt;3 or 1&#x3D;&#x3D;3 and &#39;x&#39; &#x3D;&#x3D; &#39;x&#39; or 3 &gt;3print(res) 2.9 成员运算符 12345678910print(&quot;egon&quot; in &quot;hello egon&quot;) # 判断一个字符串是否存在于一个大字符串中print(111 in [111,222,33]) # 判断元素是否存在于列表判断key是否存在于字典print(111 in &#123;&quot;k1&quot;:111,&#39;k2&#39;:222&#125;)print(&quot;k1&quot; in &#123;&quot;k1&quot;:111,&#39;k2&#39;:222&#125;)not inprint(&quot;egon&quot; not in &quot;hello egon&quot;) # 推荐使用print(not &quot;egon&quot; in &quot;hello egon&quot;) # 逻辑同上，但语义不明确，不推荐 2.10 身份运算符 身份运算符is # 判断的是id是否相等","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python的变量和基本数据类型","date":"2017-10-03T16:00:00.000Z","path":"2017/10/04/2. python的变量和基本数据类型/","text":"1.变量首先呢，我们在学习的时候，我们要思考问题要从三个问题考虑，是什么？为什么？怎们用？就是我们来到这个世界也要思考一样，我是谁？我从哪里来？我要做什么？ 1.1变量的基本使用： 什么是变量： 变量是可以变化的量，事物的一切都在变化的，万物皆可变，变量就像一个盒子，里面可以装各种东西。装了苹果，当箱子和其它东西合作时，它就是苹果；装了鸭梨，和其它东西合作时，它就是鸭梨。为什么要有变量： 是为了让计算机能够像人一样去记忆事物的某种状态，而且状态是可以变化的，序执行的本质就是一系列状态的变化，变是程序执行的直接体现，所以我们需要有一种机制能够反映或者说是保存下来程 如何使用变量： 我们要遵守先定义，后使用的原则 12name='zhangchen'print('name') 1.2变量的三大组成部分1.变量名(name) 2.等于号(=) 3.变量值(zhangchen)1.3变量名的命名规则（原则：变量名要见名知意）变量名只是字母，下划线，数字组成 变量名的第一个字符不能是数字 关键字不能作为变量名（eg:print,int,if等等） ps：不要用拼音，不要用中文，在见名知意的前提下尽可能短1.4变量名的命名风格纯小写加下划线的方式(在python中，关于变量名的命名推荐使用这种方式) 12age_of_alex = 73print(age_of_alex) 驼峰体： 12AgeOfAlex=73print(AgeOfAlex) 1.5变量值的三个重要特征id ：反映的是变量值的内存地址，内存地址不同id则不同 type：不同类型的值用来表示记录不同的状态 value：值本身 id不同的情况下，值有可能相同，即两块不同的内存空间里可以存相同的值 id相同的情况下，值一定相同，x is y成立，x == y也必然成立 (eg:x=&apos;info：Egon：18&apos; y=&apos;info：Egon：18&apos; print(x,y) info：Egon：18 info：Egon：18 print(id(x),id(y)) 4565819264 4566192176 x == y True x is y False)2.基本数据类型2.1整型intage = 18 print(type(age)) level = 1 level=level + 1 print(level) print(10 *3) print(10 + 3.3) # int与float之间可以相加 age = 19 print(age &gt; 18)作用：记录年龄、身份证号、个数等等 2.2字符串123name=\"egon\"print(name)print(type(name)) x=18 print(type(x)) x=&apos;18&apos; # 由数字组成的字符串，是字符串类型，不是int类型 print(type(x)) 字符串之间可以相加，但仅限于str与str之间进行， 代表字符串的拼接，了解即可，不推荐使用，因为str之间的 相加效率极低 代码块 print('my name is '+'egon') print('='*20) print('hello world') print('='*20) 2.3列表索引对应值，索引从0开始，0代表第一个作用：按位置记录多个值（同一个人的多个爱好、同一个班级的所有学校姓名、同一个人12个月的薪资），并且可以按照索引取指定位置的值 定义：在[]内用逗号分隔开多个任意类型的值,一个值称之为一个元素 代码块 students_info=[ ['tony',18,['jack',]], ['jason',18,['play','sleep']] ] #取出第一个学生的第一个爱好 print(students_info[0][2][0]) 2.4字典类型key对应值，其中key通常为字符串类型，所以key对值可以有描述性的功能作用：用来存多个值，每个值都有唯一一个key与其对应，key对值有描述性功能定义：在{}内用逗号分开各多个key：value 代码块 info={ \"name\":'egon', \"age\":18, \"gender\":'male', \"salary\":19 } print(info[\"salary\"]) 代码块 students_info=[ {\"name\":'egon1','age1':19,'gender':'male'}, {\"name\":'egon2','age1':19,'gender':'male'}, {\"name\":'egon3','age1':19,'gender':'male'}, ] print(students_info[1]['gender'])","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python控制语句","date":"2017-10-03T16:00:00.000Z","path":"2017/10/04/5 python控制语句/","text":"1.if判断语法1:if 条件: 代码1 1234age&#x3D;16if age&#x3D;&#x3D;16: print(&#39;你猜对了&#39;)print(&#39;运行结束&#39;) 语法2:if 条件: 代码1else: 代码1 12345age&#x3D;16if age&#x3D;&#x3D;16: print(&#39;你猜对了&#39;)else print(&#39;运行结束&#39;) 语法3:if 条件1: 代码elif 条件2: 代码elif 条件2: 代码 123456789改进score &#x3D; input(&#39;请输入您的成绩：&#39;) # score&#x3D;&quot;18&quot;score&#x3D;int(score)if score &gt;&#x3D; 90: print(&#39;优秀&#39;)elif score &gt;&#x3D; 80: print(&#39;良好&#39;)elif score &gt;&#x3D; 70: print(&#39;普通&#39;) if嵌套if 12345678910111213age &#x3D; 17is_beautifustar &#x3D; &#39;水平座&#39;if 16 &lt; age &lt; 20 and is_beautiful and star &#x3D;&#x3D; &#39;水平座&#39;: print(&#39;开始表白。。。。。&#39;) is_successful &#x3D; True if is_successful: print(&#39;两个从此过上没羞没臊的生活。。。&#39;)else: print(&#39;阿姨好，我逗你玩呢，深藏功与名&#39;)print(&#39;其他代码.............&#39;) 2.while 循环2.1循环的语法与基本使用 123456print(1)while 条件: 代码1 代码2 代码3print(3) 1234count&#x3D;0while count &lt; 5: # 5 &lt; 5 print(count) # 0,1,2,3,4 count+&#x3D;1 # 5 死循环与效率问题count=0while count &lt; 5: # 5 &lt; 5 print(count) # 0,1,2,3,4 纯计算无io的死讯会导致致命的效率问题 12while True: 1+1 #纯计算无io的死讯会导致致命的效率问题 2.2循环的应用 12345678910111213username &#x3D; &#39;egon&#39;password &#x3D; &#39;123&#39;while True: inp_name&#x3D;input(&#39;请输入您的账号：&#39;) inp_pwd&#x3D;input(&#39;请输入您的密码：&#39;) if inp_name &#x3D;&#x3D; username and inp_pwd &#x3D;&#x3D; password: print(&#39;登录成功&#39;) else: print(&#39;账号名或密码错误&#39;)&quot;&quot;&quot;1.代码重复 2.输入对了，不应该重复&quot;&quot;&quot; 那么我们应该如何退出程序呢两种方式：方式一：将条件改为False,等待下次循环判断条件是才会生效 12345678910tag=Truewhile tag: inp_name=input('请输入您的账号：') inp_pwd=input('请输入您的密码：') if inp_name == username and inp_pwd == password: print('登录成功') tag = False # 之后的代码还会运行，下次循环判断条件时才生效 else: print('账号名或密码错误') 方式二：break，只要运行到break就会立刻终止本层循环 123456789while True: inp_name=input('请输入您的账号：') inp_pwd=input('请输入您的密码：') if inp_name == username and inp_pwd == password: print('登录成功') break # 立刻终止本层循环 else: print('账号名或密码错误') 2.3 while循环的嵌套与结束 123456while True: while True: while True: break break break break: 1234567891011121314while True: inp_name=input('请输入您的账号：') inp_pwd=input('请输入您的密码：') if inp_name == username and inp_pwd == password: print('登录成功') while True: cmd=input(\"输入命令&gt;: \") if cmd == 'q': break print('命令&#123;x&#125;正在运行'.format(x=cmd)) break # 立刻终止本层循环 else: print('账号名或密码错误') 12345678910111213141516171819tag=Truewhile tag: inp_name=input('请输入您的账号：') inp_pwd=input('请输入您的密码：') if inp_name == username and inp_pwd == password: print('登录成功') while tag: cmd=input(\"输入命令&gt;: \") if cmd == 'q': tag=False else: print('命令&#123;x&#125;正在运行'.format(x=cmd)) else: print('账号名或密码错误')'''改变条件的方式结束''' 2.4while +continue：结束本次循环，直接进入下一次 强调：在continue之后添加同级代码毫无意义，因为永远无法运行 1234567count=0while count &lt; 6: if count == 4: count+=1 continue # count+=1 # 错误# print(count) count+=1 while +else：针对break 123456789count=0while count &lt; 6: if count == 4: count+=1 continue print(count) count+=1 else: print('else包含的代码会在while循环结束后，并且while循环是在没有被break打断的情况下正常结束的，才不会运行') while +else:针对break 12345678910111213141516171819count=0while count &lt; 3: inp_name=input('请输入您的账号：') inp_pwd=input('请输入您的密码：') if inp_name == username and inp_pwd == password: print('登录成功') while True: cmd=input(\"输入命令&gt;: \") if cmd == 'q': # 整个程序结束，退出所有while循环 break else: print('命令&#123;x&#125;正在运行'.format(x=cmd)) break else: print('账号名或密码错误') count+=1else: print('输错3次，退出') 额外：深浅copy 控制语句forfor循环‘’’1、什么是for循环 循环就是重复做某件事，for循环是python提供第二种循环机制 2、为何要有for循环 理论上for循环能做的事情，while循环都可以做 之所以要有for循环，是因为for循环在循环取值（遍历取值）比while循环更简洁 3、如何用for循环语法：for 变量名 in 可迭代对象:# 可迭代对象可以是：列表、字典、字符串、元组、集合 代码1 代码2 代码3 …‘’’一：for基本使用之循环取值案例1：列表循环取值简单版 123l = ['alex_dsb', 'lxx_dsb', 'egon_nb']for x in l: # x='lxx_dsb' print(x) 复杂版： 12345l = ['alex_dsb', 'lxx_dsb', 'egon_nb']i=0while i &lt; 3: print(l[i]) i+=1 案例2：字典循环取值简单版 123dic=&#123;'k1':111,'k2':2222,'k3':333&#125;for k in dic: print(k,dic[k]) 复杂版：while循环可以遍历字典，太麻烦了 案例3：字符串循环取值简单版 123msg=\"you can you up,no can no bb\"for x in msg: print(x) 复杂版：while循环可以遍历字典，太麻烦了 二：总结for循环与while循环的异同1、相同之处：都是循环，for循环可以干的事，while循环也可以干2、不同之处： while循环称之为条件循环，循环次数取决于条件何时变为假 for循环称之为”取值循环”，循环次数取决in后包含的值的个数 123for x in [1,2,3]: print('===&gt;') print('8888') 三：for循环控制循环次数：range()in后直接放一个数据类型来控制循环次数有局限性：当循环次数过多时，数据类型包含值的格式需要伴随着增加 123for x in 'a c': inp_name=input('please input your name: ') inp_pwd=input('please input your password: ') range功能介绍 12for i in range(30): print('===&gt;') for+break: 同while循环一样for+else：同while循环一样 1234567891011username='egon'password='123'for i in range(3): inp_name = input('请输入您的账号：') inp_pwd = input('请输入您的密码：') if inp_name == username and inp_pwd == password: print('登录成功') breakelse: print('输错账号密码次数过多') 四：range补充知识（了解）1、for搭配range，可以按照索引取值，但是麻烦，所以不推荐 123456l=['aaa','bbb','ccc'] # len(l)for i in range(len(l)): print(i,l[i])for x in l: print(l) 2、range()在python3里得到的是一只”会下蛋的老母鸡” 五：for+continue 1234for i in range(6): # 0 1 2 3 4 5 if i == 4: continue print(i) 六：for循环嵌套:外层循环循环一次，内层循环需要完整的循环完毕 1234for i in range(3): print('外层循环--&gt;', i) for j in range(5): print('内层--&gt;', j)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python文件操作","date":"2017-10-03T16:00:00.000Z","path":"2017/10/04/8 文件操作/","text":"1.什么是文件文件是操作系统提供给用户 / 应用程序操作硬盘的一种虚拟的概念 / 接口 2.为什么要用文件用户 / 应用程序可以通过文件将数据永久保存的硬盘中即操作文件就是操作硬盘用户 / 应用程序直接操作的是文件，对文件进行的所有的操作，都是在向操作系统发送系统调用，然后再由操作将其转换成具体的硬盘操作![](https: // img2020.cnblogs.com / blog / 1897826 / 202003 / 1897826 - 20200313164643094 - 1815780787.jpg) 3.如何操控文件三个步骤：打开(open), 操作(read, write), 关闭(close) 3.1基本操作流程12f = open(r'aaa/a.txt', mode='rt') # f的值是一种变量，占用的是应用程序的内存空间f.close # 回收操作系统资源 打开相对路径，从当前路径下开始找，如果文件不存在，则报错操作关闭 文件对象又称为文件句柄 123with open('a.txt', mode='rt') as f1: # f1=open('a.txt',mode='rt') res = f1.read()print(res) 其中rt中的t是对文本的操作，因为受t的影响，会将f.read()读出的结果解码成unicode，所以我们要在最后加上encoding = ‘utf-8’，那么我们要是去掉t，我们会多写两行代码，把它转换成utf - 8内存：utf - 8格式的二进制———————解码———————》unicode硬盘(a.txt内容：utf - 8格式的二进制) 4.文件的操作模式4.1rt wt atr(默认的操作模式): 只读模式，当文件不存在时报错，当文件存在时文件指针跳到开始位置 1234with open('r.txt', mode='rt', encoding='utf-8') as f: print('第一次读'.center(50, '*')) res = f.read() # 把所有内容从硬盘读入内存 print(res) w: 只写模式，当文件不存在时会创建空文件，当文件存在时会清空文件，指针位于开始位置, 如果重新以w模式打开文件，则会清空文件内容 12with open('w.txt', mode='wt', encoding='utf-8') as f: f.write('傻逼\\n') a: 只追加写，在文件不存在时会创建空文档，在文件存在时文件指针会直接跳到末尾 12with open('w.txt', mode='at', encoding='utf-8') as f: f.write('傻逼\\n') 小案例： 1234567891011# rtusername = input('请输入你的账号：').strip()password = input('请输入你的密码：').strip()with open('a.txt', mode='rt', encoding='utf-8') as f1: for line in f1: inp_name, inp_pwd = line.strip().split(':') if username == inp_name and password == inp_pwd: print('登录成功！') break else: print('登陆失败！') 12345678# wtsrc_file = input('源文件路径&gt;&gt;: ').strip()dst_file = input('源文件路径&gt;&gt;: ').strip()with open(r'&#123;&#125;'.format(src_file), mode='rt', encoding='utf-8') as f1, \\ open(r'&#123;&#125;'.format(dst_file), mode='wt', encoding='utf-8') as f2: res = f1.read() f2.write(res) 12345# atname = input('your name&gt;&gt;: ')pwd = input('your name&gt;&gt;: ')with open('db.txt', mode='at', encoding='utf-8') as f: f.write('&#123;&#125;:&#123;&#125;\\n'.format(name, pwd)) 4.2+（了解）123with open('g.txt', mode='rt+', encoding='utf-8') as f: print(f.read()) f.write('中国') 123with open('g.txt', mode='w+t', encoding='utf-8') as f: f.write('111\\n') print('====&gt;', f.read()) 123with open(&#39;g.txt&#39;, mode&#x3D;&#39;a+t&#39;, encoding&#x3D;&#39;utf-8&#39;) as f: f.write(&#39;5555\\n&#39;) print(f.read()) 4.3 x,b模式x: 只写模式[不可读，不存在则创建，存在则报错] 12with open('d.txt', mode='x', encoding='utf-8') as f: f.write('哈哈哈\\n') b和t：控制文件读写内容的模式t：1、读写都是以字符串（unicode）为单位2、只能针对文本文件3、必须指定字符编码，即必须指定encoding参数b：binary模式1、读写都是以bytes为单位2、可以针对所有文件3、一定不能指定字符编码，即一定不能指定encoding参数 总结：1、在操作纯文本文件方面t模式帮我们省去了编码与解码的环节，b模式则需要手动编码与解码，所以此时t模式更为方便2、针对非文本文件（如图片、视频、音频等）只能使用b模式 12345678910111213141516171819202122# b: 读写都是以二进制位单位with open('1.mp4', mode='rb') as f: data = f.read() print(type(data)) # 输出结果为：&lt;class 'bytes'&gt;with open('a.txt', mode='wb') as f: msg = \"你好\" res = msg.encode('utf-8') # res为bytes类型 f.write(res) # 在b模式下写入文件的只能是bytes类型# 强调：b模式对比t模式1、在操作纯文本文件方面t模式帮我们省去了编码与解码的环节，b模式则需要手动编码与解码，所以此时t模式更为方便2、针对非文本文件（如图片、视频、音频等）只能使用b模式# 小练习： 编写拷贝工具src_file = input('源文件路径: ').strip()dst_file = input('目标文件路径: ').strip()with open(r'%s' % src_file, mode='rb') as read_f, /open(r'%s' % dst_file, mode='wb') as write_f:for line in read_f: # print(line) write_f.write(line) 操作文件的方法读操作f.read() # 读取所有内容,执行完该操作后，文件指针会移动到文件末尾f.readline() # 读取一行内容,光标移动到第二行首部f.readlines() # 读取每一行内容,存放于列表中 123456789101112131415161718# f.read()与f.readlines()都是将内容一次性读入内容，如果内容过大会导致内存溢出，若还想将内容全读入内存，则必须分多次读入，有两种实现方式：# 方式一with open('a.txt', mode='rt', encoding='utf-8') as f: for line in f: print(line) # 同一时刻只读入一行内容到内存中# 方式二with open('1.mp4', mode='rb') as f: while True: data = f.read(1024) # 同一时刻只读入1024个Bytes到内存中 if len(data) == 0: break print(data)# 写操作f.write('1111\\n222\\n') # 针对文本模式的写,需要自己写换行符f.write('1111\\n222\\n'.encode('utf-8')) # 针对b模式的写,需要自己写换行符f.writelines(['333\\n', '444\\n']) # 文件模式f.writelines([bytes('333\\n', encoding='utf-8'), '444\\n'.encode('utf-8')]) # b模式 了解内容： # 写操作f.write(‘1111\\n222\\n’) # 针对文本模式的写,需要自己写换行符f.write(‘1111\\n222\\n’.encode(‘utf-8’)) # 针对b模式的写,需要自己写换行符f.writelines([‘333\\n’, ‘444\\n’]) # 文件模式f.writelines([bytes(‘333\\n’, encoding=’utf-8’), ‘444\\n’.encode(‘utf-8’)]) # b模式 6.主动控制文件内指针移动指针移动的单位都是以bytes / 字节为单位只有一种情况特殊：t模式下的read(n), n代表的是字符个数之前文件内指针的移动都是由读 / 写操作而被动触发的，若想读取文件某一特定位置的数据，则则需要用f.seek方法主动控制文件内指针的移动，详细用法如下：f.seek(指针移动的字节数, 模式控制):模式控制:0: 默认的模式, 该模式代表指针移动的字节数是以文件开头为参照的 1234# abc你好with open('a.txt', mode='rb') as f: f.seek(6, 0) print(f.read().decode('utf-8')) # 输出结果为: 好 1: 该模式代表指针移动的字节数是以当前所在的位置为参照的 123456# abc你好with open('a.txt', mode='rb') as f: f.seek(3, 1) # 从当前位置往后移动3个字节，而此时的当前位置就是文件开头 print(f.tell()) # 输出结果为：3 f.seek(4, 1) # 从当前位置往后移动4个字节，而此时的当前位置为3 print(f.tell()) # 输出结果为：7 2: 该模式代表指针移动的字节数是以文件末尾的位置为参照的 123456# abc你好with open('a.txt', mode='rb') as f: f.seek(0, 2) # 参照文件末尾移动0个字节， 即直接跳到文件末尾 print(f.tell()) # 输出结果为：9 f.seek(-3, 2) # 参照文件末尾往前移动了3个字节 print(f.read().decode('utf-8')) # 输出结果为：好 强调: 其中0模式可以在t或者b模式使用, 而1跟2模式只能在b模式下用 7 .文件的修改方式一：实现思路：将文件内容发一次性全部读入内存, 然后在内存中修改完毕后再覆盖写回原文件优点: 在文件修改过程中同一份数据只有一份缺点: 会过多地占用内存 1234567with open('c.txt', mode='rt', encoding='utf-8') as f: res = f.read() data = res.replace('alex', 'dsb') print(data)with open('c.txt', mode='wt', encoding='utf-8') as f1: f1.write(data) 方式二：实现思路：以读的方式打开原文件, 以写的方式打开一个临时文件, 一行行读取原文件内容, 修改完后写入临时文件…, 删掉原文件, 将临时文件重命名原文件名优点: 不会占用过多的内存缺点: 在文件修改过程中同一份数据存了两份 1234567891011with open('c.txt', mode='rt', encoding='utf-8') as f, \\ open('.c.txt.swap', mode='wt', encoding='utf-8') as f1: for line in f: f1.write(line.replace('alex', 'dsb'))os.remove('c.txt')os.rename('.c.txt.swap', 'c.txt')f = open('a.txt')res = f.read()print(res)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]}]